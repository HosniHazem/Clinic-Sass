"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/oauth4webapi";
exports.ids = ["vendor-chunks/oauth4webapi"];
exports.modules = {

/***/ "(rsc)/./node_modules/oauth4webapi/build/index.js":
/*!**************************************************!*\
  !*** ./node_modules/oauth4webapi/build/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AUTHORIZATION_RESPONSE_ERROR: () => (/* binding */ AUTHORIZATION_RESPONSE_ERROR),\n/* harmony export */   AuthorizationResponseError: () => (/* binding */ AuthorizationResponseError),\n/* harmony export */   ClientSecretBasic: () => (/* binding */ ClientSecretBasic),\n/* harmony export */   ClientSecretJwt: () => (/* binding */ ClientSecretJwt),\n/* harmony export */   ClientSecretPost: () => (/* binding */ ClientSecretPost),\n/* harmony export */   DPoP: () => (/* binding */ DPoP),\n/* harmony export */   HTTP_REQUEST_FORBIDDEN: () => (/* binding */ HTTP_REQUEST_FORBIDDEN),\n/* harmony export */   INVALID_REQUEST: () => (/* binding */ INVALID_REQUEST),\n/* harmony export */   INVALID_RESPONSE: () => (/* binding */ INVALID_RESPONSE),\n/* harmony export */   INVALID_SERVER_METADATA: () => (/* binding */ INVALID_SERVER_METADATA),\n/* harmony export */   JSON_ATTRIBUTE_COMPARISON: () => (/* binding */ JSON_ATTRIBUTE_COMPARISON),\n/* harmony export */   JWT_CLAIM_COMPARISON: () => (/* binding */ JWT_CLAIM_COMPARISON),\n/* harmony export */   JWT_TIMESTAMP_CHECK: () => (/* binding */ JWT_TIMESTAMP_CHECK),\n/* harmony export */   JWT_USERINFO_EXPECTED: () => (/* binding */ JWT_USERINFO_EXPECTED),\n/* harmony export */   KEY_SELECTION: () => (/* binding */ KEY_SELECTION),\n/* harmony export */   MISSING_SERVER_METADATA: () => (/* binding */ MISSING_SERVER_METADATA),\n/* harmony export */   None: () => (/* binding */ None),\n/* harmony export */   OperationProcessingError: () => (/* binding */ OperationProcessingError),\n/* harmony export */   PARSE_ERROR: () => (/* binding */ PARSE_ERROR),\n/* harmony export */   PrivateKeyJwt: () => (/* binding */ PrivateKeyJwt),\n/* harmony export */   REQUEST_PROTOCOL_FORBIDDEN: () => (/* binding */ REQUEST_PROTOCOL_FORBIDDEN),\n/* harmony export */   RESPONSE_BODY_ERROR: () => (/* binding */ RESPONSE_BODY_ERROR),\n/* harmony export */   RESPONSE_IS_NOT_CONFORM: () => (/* binding */ RESPONSE_IS_NOT_CONFORM),\n/* harmony export */   RESPONSE_IS_NOT_JSON: () => (/* binding */ RESPONSE_IS_NOT_JSON),\n/* harmony export */   ResponseBodyError: () => (/* binding */ ResponseBodyError),\n/* harmony export */   TlsClientAuth: () => (/* binding */ TlsClientAuth),\n/* harmony export */   UNSUPPORTED_OPERATION: () => (/* binding */ UNSUPPORTED_OPERATION),\n/* harmony export */   UnsupportedOperationError: () => (/* binding */ UnsupportedOperationError),\n/* harmony export */   WWWAuthenticateChallengeError: () => (/* binding */ WWWAuthenticateChallengeError),\n/* harmony export */   WWW_AUTHENTICATE_CHALLENGE: () => (/* binding */ WWW_AUTHENTICATE_CHALLENGE),\n/* harmony export */   _expectedIssuer: () => (/* binding */ _expectedIssuer),\n/* harmony export */   _nodiscoverycheck: () => (/* binding */ _nodiscoverycheck),\n/* harmony export */   _nopkce: () => (/* binding */ _nopkce),\n/* harmony export */   allowInsecureRequests: () => (/* binding */ allowInsecureRequests),\n/* harmony export */   authorizationCodeGrantRequest: () => (/* binding */ authorizationCodeGrantRequest),\n/* harmony export */   backchannelAuthenticationGrantRequest: () => (/* binding */ backchannelAuthenticationGrantRequest),\n/* harmony export */   backchannelAuthenticationRequest: () => (/* binding */ backchannelAuthenticationRequest),\n/* harmony export */   calculatePKCECodeChallenge: () => (/* binding */ calculatePKCECodeChallenge),\n/* harmony export */   checkProtocol: () => (/* binding */ checkProtocol),\n/* harmony export */   clientCredentialsGrantRequest: () => (/* binding */ clientCredentialsGrantRequest),\n/* harmony export */   clockSkew: () => (/* binding */ clockSkew),\n/* harmony export */   clockTolerance: () => (/* binding */ clockTolerance),\n/* harmony export */   customFetch: () => (/* binding */ customFetch),\n/* harmony export */   deviceAuthorizationRequest: () => (/* binding */ deviceAuthorizationRequest),\n/* harmony export */   deviceCodeGrantRequest: () => (/* binding */ deviceCodeGrantRequest),\n/* harmony export */   discoveryRequest: () => (/* binding */ discoveryRequest),\n/* harmony export */   dynamicClientRegistrationRequest: () => (/* binding */ dynamicClientRegistrationRequest),\n/* harmony export */   expectNoNonce: () => (/* binding */ expectNoNonce),\n/* harmony export */   expectNoState: () => (/* binding */ expectNoState),\n/* harmony export */   formPostResponse: () => (/* binding */ formPostResponse),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   generateRandomCodeVerifier: () => (/* binding */ generateRandomCodeVerifier),\n/* harmony export */   generateRandomNonce: () => (/* binding */ generateRandomNonce),\n/* harmony export */   generateRandomState: () => (/* binding */ generateRandomState),\n/* harmony export */   genericTokenEndpointRequest: () => (/* binding */ genericTokenEndpointRequest),\n/* harmony export */   getContentType: () => (/* binding */ getContentType),\n/* harmony export */   getValidatedIdTokenClaims: () => (/* binding */ getValidatedIdTokenClaims),\n/* harmony export */   introspectionRequest: () => (/* binding */ introspectionRequest),\n/* harmony export */   isDPoPNonceError: () => (/* binding */ isDPoPNonceError),\n/* harmony export */   issueRequestObject: () => (/* binding */ issueRequestObject),\n/* harmony export */   jweDecrypt: () => (/* binding */ jweDecrypt),\n/* harmony export */   jwksCache: () => (/* binding */ jwksCache),\n/* harmony export */   modifyAssertion: () => (/* binding */ modifyAssertion),\n/* harmony export */   nopkce: () => (/* binding */ nopkce),\n/* harmony export */   processAuthorizationCodeResponse: () => (/* binding */ processAuthorizationCodeResponse),\n/* harmony export */   processBackchannelAuthenticationGrantResponse: () => (/* binding */ processBackchannelAuthenticationGrantResponse),\n/* harmony export */   processBackchannelAuthenticationResponse: () => (/* binding */ processBackchannelAuthenticationResponse),\n/* harmony export */   processClientCredentialsResponse: () => (/* binding */ processClientCredentialsResponse),\n/* harmony export */   processDeviceAuthorizationResponse: () => (/* binding */ processDeviceAuthorizationResponse),\n/* harmony export */   processDeviceCodeResponse: () => (/* binding */ processDeviceCodeResponse),\n/* harmony export */   processDiscoveryResponse: () => (/* binding */ processDiscoveryResponse),\n/* harmony export */   processDynamicClientRegistrationResponse: () => (/* binding */ processDynamicClientRegistrationResponse),\n/* harmony export */   processGenericTokenEndpointResponse: () => (/* binding */ processGenericTokenEndpointResponse),\n/* harmony export */   processIntrospectionResponse: () => (/* binding */ processIntrospectionResponse),\n/* harmony export */   processPushedAuthorizationResponse: () => (/* binding */ processPushedAuthorizationResponse),\n/* harmony export */   processRefreshTokenResponse: () => (/* binding */ processRefreshTokenResponse),\n/* harmony export */   processResourceDiscoveryResponse: () => (/* binding */ processResourceDiscoveryResponse),\n/* harmony export */   processRevocationResponse: () => (/* binding */ processRevocationResponse),\n/* harmony export */   processUserInfoResponse: () => (/* binding */ processUserInfoResponse),\n/* harmony export */   protectedResourceRequest: () => (/* binding */ protectedResourceRequest),\n/* harmony export */   pushedAuthorizationRequest: () => (/* binding */ pushedAuthorizationRequest),\n/* harmony export */   refreshTokenGrantRequest: () => (/* binding */ refreshTokenGrantRequest),\n/* harmony export */   resolveEndpoint: () => (/* binding */ resolveEndpoint),\n/* harmony export */   resourceDiscoveryRequest: () => (/* binding */ resourceDiscoveryRequest),\n/* harmony export */   revocationRequest: () => (/* binding */ revocationRequest),\n/* harmony export */   skipAuthTimeCheck: () => (/* binding */ skipAuthTimeCheck),\n/* harmony export */   skipStateCheck: () => (/* binding */ skipStateCheck),\n/* harmony export */   skipSubjectCheck: () => (/* binding */ skipSubjectCheck),\n/* harmony export */   userInfoRequest: () => (/* binding */ userInfoRequest),\n/* harmony export */   validateApplicationLevelSignature: () => (/* binding */ validateApplicationLevelSignature),\n/* harmony export */   validateAuthResponse: () => (/* binding */ validateAuthResponse),\n/* harmony export */   validateCodeIdTokenResponse: () => (/* binding */ validateCodeIdTokenResponse),\n/* harmony export */   validateDetachedSignatureResponse: () => (/* binding */ validateDetachedSignatureResponse),\n/* harmony export */   validateJwtAccessToken: () => (/* binding */ validateJwtAccessToken),\n/* harmony export */   validateJwtAuthResponse: () => (/* binding */ validateJwtAuthResponse)\n/* harmony export */ });\nlet USER_AGENT;\nif (typeof navigator === \"undefined\" || !navigator.userAgent?.startsWith?.(\"Mozilla/5.0 \")) {\n    const NAME = \"oauth4webapi\";\n    const VERSION = \"v3.8.2\";\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nfunction looseInstanceOf(input, expected) {\n    if (input == null) {\n        return false;\n    }\n    try {\n        return input instanceof expected || Object.getPrototypeOf(input)[Symbol.toStringTag] === expected.prototype[Symbol.toStringTag];\n    } catch  {\n        return false;\n    }\n}\nconst ERR_INVALID_ARG_VALUE = \"ERR_INVALID_ARG_VALUE\";\nconst ERR_INVALID_ARG_TYPE = \"ERR_INVALID_ARG_TYPE\";\nfunction CodedTypeError(message, code, cause) {\n    const err = new TypeError(message, {\n        cause\n    });\n    Object.assign(err, {\n        code\n    });\n    return err;\n}\nconst allowInsecureRequests = Symbol();\nconst clockSkew = Symbol();\nconst clockTolerance = Symbol();\nconst customFetch = Symbol();\nconst modifyAssertion = Symbol();\nconst jweDecrypt = Symbol();\nconst jwksCache = Symbol();\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nfunction buf(input) {\n    if (typeof input === \"string\") {\n        return encoder.encode(input);\n    }\n    return decoder.decode(input);\n}\nlet encodeBase64Url;\nif (Uint8Array.prototype.toBase64) {\n    encodeBase64Url = (input)=>{\n        if (input instanceof ArrayBuffer) {\n            input = new Uint8Array(input);\n        }\n        return input.toBase64({\n            alphabet: \"base64url\",\n            omitPadding: true\n        });\n    };\n} else {\n    const CHUNK_SIZE = 0x8000;\n    encodeBase64Url = (input)=>{\n        if (input instanceof ArrayBuffer) {\n            input = new Uint8Array(input);\n        }\n        const arr = [];\n        for(let i = 0; i < input.byteLength; i += CHUNK_SIZE){\n            arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n        }\n        return btoa(arr.join(\"\")).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    };\n}\nlet decodeBase64Url;\nif (Uint8Array.fromBase64) {\n    decodeBase64Url = (input)=>{\n        try {\n            return Uint8Array.fromBase64(input, {\n                alphabet: \"base64url\"\n            });\n        } catch (cause) {\n            throw CodedTypeError(\"The input to be decoded is not correctly encoded.\", ERR_INVALID_ARG_VALUE, cause);\n        }\n    };\n} else {\n    decodeBase64Url = (input)=>{\n        try {\n            const binary = atob(input.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\"));\n            const bytes = new Uint8Array(binary.length);\n            for(let i = 0; i < binary.length; i++){\n                bytes[i] = binary.charCodeAt(i);\n            }\n            return bytes;\n        } catch (cause) {\n            throw CodedTypeError(\"The input to be decoded is not correctly encoded.\", ERR_INVALID_ARG_VALUE, cause);\n        }\n    };\n}\nfunction b64u(input) {\n    if (typeof input === \"string\") {\n        return decodeBase64Url(input);\n    }\n    return encodeBase64Url(input);\n}\nclass UnsupportedOperationError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = UNSUPPORTED_OPERATION;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass OperationProcessingError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        if (options?.code) {\n            this.code = options?.code;\n        }\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nfunction OPE(message, code, cause) {\n    return new OperationProcessingError(message, {\n        code,\n        cause\n    });\n}\nasync function calculateJwkThumbprint(jwk) {\n    let components;\n    switch(jwk.kty){\n        case \"EC\":\n            components = {\n                crv: jwk.crv,\n                kty: jwk.kty,\n                x: jwk.x,\n                y: jwk.y\n            };\n            break;\n        case \"OKP\":\n            components = {\n                crv: jwk.crv,\n                kty: jwk.kty,\n                x: jwk.x\n            };\n            break;\n        case \"AKP\":\n            components = {\n                alg: jwk.alg,\n                kty: jwk.kty,\n                pub: jwk.pub\n            };\n            break;\n        case \"RSA\":\n            components = {\n                e: jwk.e,\n                kty: jwk.kty,\n                n: jwk.n\n            };\n            break;\n        default:\n            throw new UnsupportedOperationError(\"unsupported JWK key type\", {\n                cause: jwk\n            });\n    }\n    return b64u(await crypto.subtle.digest(\"SHA-256\", buf(JSON.stringify(components))));\n}\nfunction assertCryptoKey(key, it) {\n    if (!(key instanceof CryptoKey)) {\n        throw CodedTypeError(`${it} must be a CryptoKey`, ERR_INVALID_ARG_TYPE);\n    }\n}\nfunction assertPrivateKey(key, it) {\n    assertCryptoKey(key, it);\n    if (key.type !== \"private\") {\n        throw CodedTypeError(`${it} must be a private CryptoKey`, ERR_INVALID_ARG_VALUE);\n    }\n}\nfunction assertPublicKey(key, it) {\n    assertCryptoKey(key, it);\n    if (key.type !== \"public\") {\n        throw CodedTypeError(`${it} must be a public CryptoKey`, ERR_INVALID_ARG_VALUE);\n    }\n}\nfunction normalizeTyp(value) {\n    return value.toLowerCase().replace(/^application\\//, \"\");\n}\nfunction isJsonObject(input) {\n    if (input === null || typeof input !== \"object\" || Array.isArray(input)) {\n        return false;\n    }\n    return true;\n}\nfunction prepareHeaders(input) {\n    if (looseInstanceOf(input, Headers)) {\n        input = Object.fromEntries(input.entries());\n    }\n    const headers = new Headers(input ?? {});\n    if (USER_AGENT && !headers.has(\"user-agent\")) {\n        headers.set(\"user-agent\", USER_AGENT);\n    }\n    if (headers.has(\"authorization\")) {\n        throw CodedTypeError('\"options.headers\" must not include the \"authorization\" header name', ERR_INVALID_ARG_VALUE);\n    }\n    return headers;\n}\nfunction signal(url, value) {\n    if (value !== undefined) {\n        if (typeof value === \"function\") {\n            value = value(url.href);\n        }\n        if (!(value instanceof AbortSignal)) {\n            throw CodedTypeError('\"options.signal\" must return or be an instance of AbortSignal', ERR_INVALID_ARG_TYPE);\n        }\n        return value;\n    }\n    return undefined;\n}\nfunction replaceDoubleSlash(pathname) {\n    if (pathname.includes(\"//\")) {\n        return pathname.replace(\"//\", \"/\");\n    }\n    return pathname;\n}\nfunction prependWellKnown(url, wellKnown, allowTerminatingSlash = false) {\n    if (url.pathname === \"/\") {\n        url.pathname = wellKnown;\n    } else {\n        url.pathname = replaceDoubleSlash(`${wellKnown}/${allowTerminatingSlash ? url.pathname : url.pathname.replace(/(\\/)$/, \"\")}`);\n    }\n    return url;\n}\nfunction appendWellKnown(url, wellKnown) {\n    url.pathname = replaceDoubleSlash(`${url.pathname}/${wellKnown}`);\n    return url;\n}\nasync function performDiscovery(input, urlName, transform, options) {\n    if (!(input instanceof URL)) {\n        throw CodedTypeError(`\"${urlName}\" must be an instance of URL`, ERR_INVALID_ARG_TYPE);\n    }\n    checkProtocol(input, options?.[allowInsecureRequests] !== true);\n    const url = transform(new URL(input.href));\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return (options?.[customFetch] || fetch)(url.href, {\n        body: undefined,\n        headers: Object.fromEntries(headers.entries()),\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: signal(url, options?.signal)\n    });\n}\nasync function discoveryRequest(issuerIdentifier, options) {\n    return performDiscovery(issuerIdentifier, \"issuerIdentifier\", (url)=>{\n        switch(options?.algorithm){\n            case undefined:\n            case \"oidc\":\n                appendWellKnown(url, \".well-known/openid-configuration\");\n                break;\n            case \"oauth2\":\n                prependWellKnown(url, \".well-known/oauth-authorization-server\");\n                break;\n            default:\n                throw CodedTypeError('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"', ERR_INVALID_ARG_VALUE);\n        }\n        return url;\n    }, options);\n}\nfunction assertNumber(input, allow0, it, code, cause) {\n    try {\n        if (typeof input !== \"number\" || !Number.isFinite(input)) {\n            throw CodedTypeError(`${it} must be a number`, ERR_INVALID_ARG_TYPE, cause);\n        }\n        if (input > 0) return;\n        if (allow0) {\n            if (input !== 0) {\n                throw CodedTypeError(`${it} must be a non-negative number`, ERR_INVALID_ARG_VALUE, cause);\n            }\n            return;\n        }\n        throw CodedTypeError(`${it} must be a positive number`, ERR_INVALID_ARG_VALUE, cause);\n    } catch (err) {\n        if (code) {\n            throw OPE(err.message, code, cause);\n        }\n        throw err;\n    }\n}\nfunction assertString(input, it, code, cause) {\n    try {\n        if (typeof input !== \"string\") {\n            throw CodedTypeError(`${it} must be a string`, ERR_INVALID_ARG_TYPE, cause);\n        }\n        if (input.length === 0) {\n            throw CodedTypeError(`${it} must not be empty`, ERR_INVALID_ARG_VALUE, cause);\n        }\n    } catch (err) {\n        if (code) {\n            throw OPE(err.message, code, cause);\n        }\n        throw err;\n    }\n}\nasync function processDiscoveryResponse(expectedIssuerIdentifier, response) {\n    const expected = expectedIssuerIdentifier;\n    if (!(expected instanceof URL) && expected !== _nodiscoverycheck) {\n        throw CodedTypeError('\"expectedIssuerIdentifier\" must be an instance of URL', ERR_INVALID_ARG_TYPE);\n    }\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    if (response.status !== 200) {\n        throw OPE('\"response\" is not a conform Authorization Server Metadata response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);\n    }\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.issuer, '\"response\" body \"issuer\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    if (expected !== _nodiscoverycheck && new URL(json.issuer).href !== expected.href) {\n        throw OPE('\"response\" body \"issuer\" property does not match the expected value', JSON_ATTRIBUTE_COMPARISON, {\n            expected: expected.href,\n            body: json,\n            attribute: \"issuer\"\n        });\n    }\n    return json;\n}\nfunction assertApplicationJson(response) {\n    assertContentType(response, \"application/json\");\n}\nfunction notJson(response, ...types) {\n    let msg = '\"response\" content-type must be ';\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `${types.join(\", \")}, or ${last}`;\n    } else if (types.length === 2) {\n        msg += `${types[0]} or ${types[1]}`;\n    } else {\n        msg += types[0];\n    }\n    return OPE(msg, RESPONSE_IS_NOT_JSON, response);\n}\nfunction assertContentTypes(response, ...types) {\n    if (!types.includes(getContentType(response))) {\n        throw notJson(response, ...types);\n    }\n}\nfunction assertContentType(response, contentType) {\n    if (getContentType(response) !== contentType) {\n        throw notJson(response, contentType);\n    }\n}\nfunction randomBytes() {\n    return b64u(crypto.getRandomValues(new Uint8Array(32)));\n}\nfunction generateRandomCodeVerifier() {\n    return randomBytes();\n}\nfunction generateRandomState() {\n    return randomBytes();\n}\nfunction generateRandomNonce() {\n    return randomBytes();\n}\nasync function calculatePKCECodeChallenge(codeVerifier) {\n    assertString(codeVerifier, \"codeVerifier\");\n    return b64u(await crypto.subtle.digest(\"SHA-256\", buf(codeVerifier)));\n}\nfunction getKeyAndKid(input) {\n    if (input instanceof CryptoKey) {\n        return {\n            key: input\n        };\n    }\n    if (!(input?.key instanceof CryptoKey)) {\n        return {};\n    }\n    if (input.kid !== undefined) {\n        assertString(input.kid, '\"kid\"');\n    }\n    return {\n        key: input.key,\n        kid: input.kid\n    };\n}\nfunction psAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"PS256\";\n        case \"SHA-384\":\n            return \"PS384\";\n        case \"SHA-512\":\n            return \"PS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\", {\n                cause: key\n            });\n    }\n}\nfunction rsAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"RS256\";\n        case \"SHA-384\":\n            return \"RS384\";\n        case \"SHA-512\":\n            return \"RS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\", {\n                cause: key\n            });\n    }\n}\nfunction esAlg(key) {\n    switch(key.algorithm.namedCurve){\n        case \"P-256\":\n            return \"ES256\";\n        case \"P-384\":\n            return \"ES384\";\n        case \"P-521\":\n            return \"ES512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported EcKeyAlgorithm namedCurve\", {\n                cause: key\n            });\n    }\n}\nfunction keyToJws(key) {\n    switch(key.algorithm.name){\n        case \"RSA-PSS\":\n            return psAlg(key);\n        case \"RSASSA-PKCS1-v1_5\":\n            return rsAlg(key);\n        case \"ECDSA\":\n            return esAlg(key);\n        case \"Ed25519\":\n        case \"ML-DSA-44\":\n        case \"ML-DSA-65\":\n        case \"ML-DSA-87\":\n            return key.algorithm.name;\n        case \"EdDSA\":\n            return \"Ed25519\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported CryptoKey algorithm name\", {\n                cause: key\n            });\n    }\n}\nfunction getClockSkew(client) {\n    const skew = client?.[clockSkew];\n    return typeof skew === \"number\" && Number.isFinite(skew) ? skew : 0;\n}\nfunction getClockTolerance(client) {\n    const tolerance = client?.[clockTolerance];\n    return typeof tolerance === \"number\" && Number.isFinite(tolerance) && Math.sign(tolerance) !== -1 ? tolerance : 30;\n}\nfunction epochTime() {\n    return Math.floor(Date.now() / 1000);\n}\nfunction assertAs(as) {\n    if (typeof as !== \"object\" || as === null) {\n        throw CodedTypeError('\"as\" must be an object', ERR_INVALID_ARG_TYPE);\n    }\n    assertString(as.issuer, '\"as.issuer\"');\n}\nfunction assertClient(client) {\n    if (typeof client !== \"object\" || client === null) {\n        throw CodedTypeError('\"client\" must be an object', ERR_INVALID_ARG_TYPE);\n    }\n    assertString(client.client_id, '\"client.client_id\"');\n}\nfunction formUrlEncode(token) {\n    return encodeURIComponent(token).replace(/(?:[-_.!~*'()]|%20)/g, (substring)=>{\n        switch(substring){\n            case \"-\":\n            case \"_\":\n            case \".\":\n            case \"!\":\n            case \"~\":\n            case \"*\":\n            case \"'\":\n            case \"(\":\n            case \")\":\n                return `%${substring.charCodeAt(0).toString(16).toUpperCase()}`;\n            case \"%20\":\n                return \"+\";\n            default:\n                throw new Error();\n        }\n    });\n}\nfunction ClientSecretPost(clientSecret) {\n    assertString(clientSecret, '\"clientSecret\"');\n    return (_as, client, body, _headers)=>{\n        body.set(\"client_id\", client.client_id);\n        body.set(\"client_secret\", clientSecret);\n    };\n}\nfunction ClientSecretBasic(clientSecret) {\n    assertString(clientSecret, '\"clientSecret\"');\n    return (_as, client, _body, headers)=>{\n        const username = formUrlEncode(client.client_id);\n        const password = formUrlEncode(clientSecret);\n        const credentials = btoa(`${username}:${password}`);\n        headers.set(\"authorization\", `Basic ${credentials}`);\n    };\n}\nfunction clientAssertionPayload(as, client) {\n    const now = epochTime() + getClockSkew(client);\n    return {\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n        sub: client.client_id\n    };\n}\nfunction PrivateKeyJwt(clientPrivateKey, options) {\n    const { key, kid } = getKeyAndKid(clientPrivateKey);\n    assertPrivateKey(key, '\"clientPrivateKey.key\"');\n    return async (as, client, body, _headers)=>{\n        const header = {\n            alg: keyToJws(key),\n            kid\n        };\n        const payload = clientAssertionPayload(as, client);\n        options?.[modifyAssertion]?.(header, payload);\n        body.set(\"client_id\", client.client_id);\n        body.set(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n        body.set(\"client_assertion\", await signJwt(header, payload, key));\n    };\n}\nfunction ClientSecretJwt(clientSecret, options) {\n    assertString(clientSecret, '\"clientSecret\"');\n    const modify = options?.[modifyAssertion];\n    let key;\n    return async (as, client, body, _headers)=>{\n        key ||= await crypto.subtle.importKey(\"raw\", buf(clientSecret), {\n            hash: \"SHA-256\",\n            name: \"HMAC\"\n        }, false, [\n            \"sign\"\n        ]);\n        const header = {\n            alg: \"HS256\"\n        };\n        const payload = clientAssertionPayload(as, client);\n        modify?.(header, payload);\n        const data = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(payload)))}`;\n        const hmac = await crypto.subtle.sign(key.algorithm, key, buf(data));\n        body.set(\"client_id\", client.client_id);\n        body.set(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n        body.set(\"client_assertion\", `${data}.${b64u(new Uint8Array(hmac))}`);\n    };\n}\nfunction None() {\n    return (_as, client, body, _headers)=>{\n        body.set(\"client_id\", client.client_id);\n    };\n}\nfunction TlsClientAuth() {\n    return None();\n}\nasync function signJwt(header, payload, key) {\n    if (!key.usages.includes(\"sign\")) {\n        throw CodedTypeError('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"', ERR_INVALID_ARG_VALUE);\n    }\n    const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(payload)))}`;\n    const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));\n    return `${input}.${signature}`;\n}\nasync function issueRequestObject(as, client, parameters, privateKey, options) {\n    assertAs(as);\n    assertClient(client);\n    parameters = new URLSearchParams(parameters);\n    const { key, kid } = getKeyAndKid(privateKey);\n    assertPrivateKey(key, '\"privateKey.key\"');\n    parameters.set(\"client_id\", client.client_id);\n    const now = epochTime() + getClockSkew(client);\n    const claims = {\n        ...Object.fromEntries(parameters.entries()),\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id\n    };\n    let resource;\n    if (parameters.has(\"resource\") && (resource = parameters.getAll(\"resource\")) && resource.length > 1) {\n        claims.resource = resource;\n    }\n    {\n        let value = parameters.get(\"max_age\");\n        if (value !== null) {\n            claims.max_age = parseInt(value, 10);\n            assertNumber(claims.max_age, true, '\"max_age\" parameter');\n        }\n    }\n    {\n        let value = parameters.get(\"claims\");\n        if (value !== null) {\n            try {\n                claims.claims = JSON.parse(value);\n            } catch (cause) {\n                throw OPE('failed to parse the \"claims\" parameter as JSON', PARSE_ERROR, cause);\n            }\n            if (!isJsonObject(claims.claims)) {\n                throw CodedTypeError('\"claims\" parameter must be a JSON with a top level object', ERR_INVALID_ARG_VALUE);\n            }\n        }\n    }\n    {\n        let value = parameters.get(\"authorization_details\");\n        if (value !== null) {\n            try {\n                claims.authorization_details = JSON.parse(value);\n            } catch (cause) {\n                throw OPE('failed to parse the \"authorization_details\" parameter as JSON', PARSE_ERROR, cause);\n            }\n            if (!Array.isArray(claims.authorization_details)) {\n                throw CodedTypeError('\"authorization_details\" parameter must be a JSON with a top level array', ERR_INVALID_ARG_VALUE);\n            }\n        }\n    }\n    const header = {\n        alg: keyToJws(key),\n        typ: \"oauth-authz-req+jwt\",\n        kid\n    };\n    options?.[modifyAssertion]?.(header, claims);\n    return signJwt(header, claims, key);\n}\nlet jwkCache;\nasync function getSetPublicJwkCache(key, alg) {\n    const { kty, e, n, x, y, crv, pub } = await crypto.subtle.exportKey(\"jwk\", key);\n    const jwk = {\n        kty,\n        e,\n        n,\n        x,\n        y,\n        crv,\n        pub\n    };\n    if (kty === \"AKP\") jwk.alg = alg;\n    jwkCache.set(key, jwk);\n    return jwk;\n}\nasync function publicJwk(key, alg) {\n    jwkCache ||= new WeakMap();\n    return jwkCache.get(key) || getSetPublicJwkCache(key, alg);\n}\nconst URLParse = URL.parse ? (url, base)=>URL.parse(url, base) : (url, base)=>{\n    try {\n        return new URL(url, base);\n    } catch  {\n        return null;\n    }\n};\nfunction checkProtocol(url, enforceHttps) {\n    if (enforceHttps && url.protocol !== \"https:\") {\n        throw OPE(\"only requests to HTTPS are allowed\", HTTP_REQUEST_FORBIDDEN, url);\n    }\n    if (url.protocol !== \"https:\" && url.protocol !== \"http:\") {\n        throw OPE(\"only HTTP and HTTPS requests are allowed\", REQUEST_PROTOCOL_FORBIDDEN, url);\n    }\n}\nfunction validateEndpoint(value, endpoint, useMtlsAlias, enforceHttps) {\n    let url;\n    if (typeof value !== \"string\" || !(url = URLParse(value))) {\n        throw OPE(`authorization server metadata does not contain a valid ${useMtlsAlias ? `\"as.mtls_endpoint_aliases.${endpoint}\"` : `\"as.${endpoint}\"`}`, value === undefined ? MISSING_SERVER_METADATA : INVALID_SERVER_METADATA, {\n            attribute: useMtlsAlias ? `mtls_endpoint_aliases.${endpoint}` : endpoint\n        });\n    }\n    checkProtocol(url, enforceHttps);\n    return url;\n}\nfunction resolveEndpoint(as, endpoint, useMtlsAlias, enforceHttps) {\n    if (useMtlsAlias && as.mtls_endpoint_aliases && endpoint in as.mtls_endpoint_aliases) {\n        return validateEndpoint(as.mtls_endpoint_aliases[endpoint], endpoint, useMtlsAlias, enforceHttps);\n    }\n    return validateEndpoint(as[endpoint], endpoint, useMtlsAlias, enforceHttps);\n}\nasync function pushedAuthorizationRequest(as, client, clientAuthentication, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"pushed_authorization_request_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        assertDPoP(options.DPoP);\n        await options.DPoP.addProof(url, headers, \"POST\");\n    }\n    const response = await authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n    options?.DPoP?.cacheNonce(response, url);\n    return response;\n}\nclass DPoPHandler {\n    #header;\n    #privateKey;\n    #publicKey;\n    #clockSkew;\n    #modifyAssertion;\n    #map;\n    #jkt;\n    constructor(client, keyPair, options){\n        assertPrivateKey(keyPair?.privateKey, '\"DPoP.privateKey\"');\n        assertPublicKey(keyPair?.publicKey, '\"DPoP.publicKey\"');\n        if (!keyPair.publicKey.extractable) {\n            throw CodedTypeError('\"DPoP.publicKey.extractable\" must be true', ERR_INVALID_ARG_VALUE);\n        }\n        this.#modifyAssertion = options?.[modifyAssertion];\n        this.#clockSkew = getClockSkew(client);\n        this.#privateKey = keyPair.privateKey;\n        this.#publicKey = keyPair.publicKey;\n        branded.add(this);\n    }\n    #get(key) {\n        this.#map ||= new Map();\n        let item = this.#map.get(key);\n        if (item) {\n            this.#map.delete(key);\n            this.#map.set(key, item);\n        }\n        return item;\n    }\n    #set(key, val) {\n        this.#map ||= new Map();\n        this.#map.delete(key);\n        if (this.#map.size === 100) {\n            this.#map.delete(this.#map.keys().next().value);\n        }\n        this.#map.set(key, val);\n    }\n    async calculateThumbprint() {\n        if (!this.#jkt) {\n            const jwk = await crypto.subtle.exportKey(\"jwk\", this.#publicKey);\n            this.#jkt ||= await calculateJwkThumbprint(jwk);\n        }\n        return this.#jkt;\n    }\n    async addProof(url, headers, htm, accessToken) {\n        const alg = keyToJws(this.#privateKey);\n        this.#header ||= {\n            alg,\n            typ: \"dpop+jwt\",\n            jwk: await publicJwk(this.#publicKey, alg)\n        };\n        const nonce = this.#get(url.origin);\n        const now = epochTime() + this.#clockSkew;\n        const payload = {\n            iat: now,\n            jti: randomBytes(),\n            htm,\n            nonce,\n            htu: `${url.origin}${url.pathname}`,\n            ath: accessToken ? b64u(await crypto.subtle.digest(\"SHA-256\", buf(accessToken))) : undefined\n        };\n        this.#modifyAssertion?.(this.#header, payload);\n        headers.set(\"dpop\", await signJwt(this.#header, payload, this.#privateKey));\n    }\n    cacheNonce(response, url) {\n        try {\n            const nonce = response.headers.get(\"dpop-nonce\");\n            if (nonce) {\n                this.#set(url.origin, nonce);\n            }\n        } catch  {}\n    }\n}\nfunction isDPoPNonceError(err) {\n    if (err instanceof WWWAuthenticateChallengeError) {\n        const { 0: challenge, length } = err.cause;\n        return length === 1 && challenge.scheme === \"dpop\" && challenge.parameters.error === \"use_dpop_nonce\";\n    }\n    if (err instanceof ResponseBodyError) {\n        return err.error === \"use_dpop_nonce\";\n    }\n    return false;\n}\nfunction DPoP(client, keyPair, options) {\n    return new DPoPHandler(client, keyPair, options);\n}\nclass ResponseBodyError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = RESPONSE_BODY_ERROR;\n        this.cause = options.cause;\n        this.error = options.cause.error;\n        this.status = options.response.status;\n        this.error_description = options.cause.error_description;\n        Object.defineProperty(this, \"response\", {\n            enumerable: false,\n            value: options.response\n        });\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass AuthorizationResponseError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = AUTHORIZATION_RESPONSE_ERROR;\n        this.cause = options.cause;\n        this.error = options.cause.get(\"error\");\n        this.error_description = options.cause.get(\"error_description\") ?? undefined;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass WWWAuthenticateChallengeError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = WWW_AUTHENTICATE_CHALLENGE;\n        this.cause = options.cause;\n        this.status = options.response.status;\n        this.response = options.response;\n        Object.defineProperty(this, \"response\", {\n            enumerable: false\n        });\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nconst tokenMatch = \"[a-zA-Z0-9!#$%&\\\\'\\\\*\\\\+\\\\-\\\\.\\\\^_`\\\\|~]+\";\nconst token68Match = \"[a-zA-Z0-9\\\\-\\\\._\\\\~\\\\+\\\\/]+[=]{0,2}\";\nconst quotedMatch = '\"((?:[^\"\\\\\\\\]|\\\\\\\\.)*)\"';\nconst quotedParamMatcher = \"(\" + tokenMatch + \")\\\\s*=\\\\s*\" + quotedMatch;\nconst paramMatcher = \"(\" + tokenMatch + \")\\\\s*=\\\\s*(\" + tokenMatch + \")\";\nconst schemeRE = new RegExp(\"^[,\\\\s]*(\" + tokenMatch + \")\\\\s(.*)\");\nconst quotedParamRE = new RegExp(\"^[,\\\\s]*\" + quotedParamMatcher + \"[,\\\\s]*(.*)\");\nconst unquotedParamRE = new RegExp(\"^[,\\\\s]*\" + paramMatcher + \"[,\\\\s]*(.*)\");\nconst token68ParamRE = new RegExp(\"^(\" + token68Match + \")(?:$|[,\\\\s])(.*)\");\nfunction parseWwwAuthenticateChallenges(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    const header = response.headers.get(\"www-authenticate\");\n    if (header === null) {\n        return undefined;\n    }\n    const challenges = [];\n    let rest = header;\n    while(rest){\n        let match = rest.match(schemeRE);\n        const scheme = match?.[\"1\"].toLowerCase();\n        rest = match?.[\"2\"];\n        if (!scheme) {\n            return undefined;\n        }\n        const parameters = {};\n        let token68;\n        while(rest){\n            let key;\n            let value;\n            if (match = rest.match(quotedParamRE)) {\n                ;\n                [, key, value, rest] = match;\n                if (value.includes(\"\\\\\")) {\n                    try {\n                        value = JSON.parse(`\"${value}\"`);\n                    } catch  {}\n                }\n                parameters[key.toLowerCase()] = value;\n                continue;\n            }\n            if (match = rest.match(unquotedParamRE)) {\n                ;\n                [, key, value, rest] = match;\n                parameters[key.toLowerCase()] = value;\n                continue;\n            }\n            if (match = rest.match(token68ParamRE)) {\n                if (Object.keys(parameters).length) {\n                    break;\n                }\n                ;\n                [, token68, rest] = match;\n                break;\n            }\n            return undefined;\n        }\n        const challenge = {\n            scheme,\n            parameters\n        };\n        if (token68) {\n            challenge.token68 = token68;\n        }\n        challenges.push(challenge);\n    }\n    if (!challenges.length) {\n        return undefined;\n    }\n    return challenges;\n}\nasync function processPushedAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 201, \"Pushed Authorization Request Endpoint\");\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.request_uri, '\"response\" body \"request_uri\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    let expiresIn = typeof json.expires_in !== \"number\" ? parseFloat(json.expires_in) : json.expires_in;\n    assertNumber(expiresIn, true, '\"response\" body \"expires_in\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    json.expires_in = expiresIn;\n    return json;\n}\nasync function parseOAuthResponseErrorBody(response) {\n    if (response.status > 399 && response.status < 500) {\n        assertReadableResponse(response);\n        assertApplicationJson(response);\n        try {\n            const json = await response.clone().json();\n            if (isJsonObject(json) && typeof json.error === \"string\" && json.error.length) {\n                return json;\n            }\n        } catch  {}\n    }\n    return undefined;\n}\nasync function checkOAuthBodyError(response, expected, label) {\n    if (response.status !== expected) {\n        checkAuthenticationChallenges(response);\n        let err;\n        if (err = await parseOAuthResponseErrorBody(response)) {\n            await response.body?.cancel();\n            throw new ResponseBodyError(\"server responded with an error in the response body\", {\n                cause: err,\n                response\n            });\n        }\n        throw OPE(`\"response\" is not a conform ${label} response (unexpected HTTP status code)`, RESPONSE_IS_NOT_CONFORM, response);\n    }\n}\nfunction assertDPoP(option) {\n    if (!branded.has(option)) {\n        throw CodedTypeError('\"options.DPoP\" is not a valid DPoPHandle', ERR_INVALID_ARG_VALUE);\n    }\n}\nasync function resourceRequest(accessToken, method, url, headers, body, options) {\n    assertString(accessToken, '\"accessToken\"');\n    if (!(url instanceof URL)) {\n        throw CodedTypeError('\"url\" must be an instance of URL', ERR_INVALID_ARG_TYPE);\n    }\n    checkProtocol(url, options?.[allowInsecureRequests] !== true);\n    headers = prepareHeaders(headers);\n    if (options?.DPoP) {\n        assertDPoP(options.DPoP);\n        await options.DPoP.addProof(url, headers, method.toUpperCase(), accessToken);\n    }\n    headers.set(\"authorization\", `${headers.has(\"dpop\") ? \"DPoP\" : \"Bearer\"} ${accessToken}`);\n    const response = await (options?.[customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: \"manual\",\n        signal: signal(url, options?.signal)\n    });\n    options?.DPoP?.cacheNonce(response, url);\n    return response;\n}\nasync function protectedResourceRequest(accessToken, method, url, headers, body, options) {\n    const response = await resourceRequest(accessToken, method, url, headers, body, options);\n    checkAuthenticationChallenges(response);\n    return response;\n}\nasync function userInfoRequest(as, client, accessToken, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"userinfo_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const headers = prepareHeaders(options?.headers);\n    if (client.userinfo_signed_response_alg) {\n        headers.set(\"accept\", \"application/jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n        headers.append(\"accept\", \"application/jwt\");\n    }\n    return resourceRequest(accessToken, \"GET\", url, headers, null, {\n        ...options,\n        [clockSkew]: getClockSkew(client)\n    });\n}\nlet jwksMap;\nfunction setJwksCache(as, jwks, uat, cache) {\n    jwksMap ||= new WeakMap();\n    jwksMap.set(as, {\n        jwks,\n        uat,\n        get age () {\n            return epochTime() - this.uat;\n        }\n    });\n    if (cache) {\n        Object.assign(cache, {\n            jwks: structuredClone(jwks),\n            uat\n        });\n    }\n}\nfunction isFreshJwksCache(input) {\n    if (typeof input !== \"object\" || input === null) {\n        return false;\n    }\n    if (!(\"uat\" in input) || typeof input.uat !== \"number\" || epochTime() - input.uat >= 300) {\n        return false;\n    }\n    if (!(\"jwks\" in input) || !isJsonObject(input.jwks) || !Array.isArray(input.jwks.keys) || !Array.prototype.every.call(input.jwks.keys, isJsonObject)) {\n        return false;\n    }\n    return true;\n}\nfunction clearJwksCache(as, cache) {\n    jwksMap?.delete(as);\n    delete cache?.jwks;\n    delete cache?.uat;\n}\nasync function getPublicSigKeyFromIssuerJwksUri(as, options, header) {\n    const { alg, kid } = header;\n    checkSupportedJwsAlg(header);\n    if (!jwksMap?.has(as) && isFreshJwksCache(options?.[jwksCache])) {\n        setJwksCache(as, options?.[jwksCache].jwks, options?.[jwksCache].uat);\n    }\n    let jwks;\n    let age;\n    if (jwksMap?.has(as)) {\n        ;\n        ({ jwks, age } = jwksMap.get(as));\n        if (age >= 300) {\n            clearJwksCache(as, options?.[jwksCache]);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n    } else {\n        jwks = await jwksRequest(as, options).then(processJwksResponse);\n        age = 0;\n        setJwksCache(as, jwks, epochTime(), options?.[jwksCache]);\n    }\n    let kty;\n    switch(alg.slice(0, 2)){\n        case \"RS\":\n        case \"PS\":\n            kty = \"RSA\";\n            break;\n        case \"ES\":\n            kty = \"EC\";\n            break;\n        case \"Ed\":\n            kty = \"OKP\";\n            break;\n        case \"ML\":\n            kty = \"AKP\";\n            break;\n        default:\n            throw new UnsupportedOperationError(\"unsupported JWS algorithm\", {\n                cause: {\n                    alg\n                }\n            });\n    }\n    const candidates = jwks.keys.filter((jwk)=>{\n        if (jwk.kty !== kty) {\n            return false;\n        }\n        if (kid !== undefined && kid !== jwk.kid) {\n            return false;\n        }\n        if (jwk.alg !== undefined && alg !== jwk.alg) {\n            return false;\n        }\n        if (jwk.use !== undefined && jwk.use !== \"sig\") {\n            return false;\n        }\n        if (jwk.key_ops?.includes(\"verify\") === false) {\n            return false;\n        }\n        switch(true){\n            case alg === \"ES256\" && jwk.crv !== \"P-256\":\n            case alg === \"ES384\" && jwk.crv !== \"P-384\":\n            case alg === \"ES512\" && jwk.crv !== \"P-521\":\n            case alg === \"Ed25519\" && jwk.crv !== \"Ed25519\":\n            case alg === \"EdDSA\" && jwk.crv !== \"Ed25519\":\n                return false;\n        }\n        return true;\n    });\n    const { 0: jwk, length } = candidates;\n    if (!length) {\n        if (age >= 60) {\n            clearJwksCache(as, options?.[jwksCache]);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n        throw OPE(\"error when selecting a JWT verification key, no applicable keys found\", KEY_SELECTION, {\n            header,\n            candidates,\n            jwks_uri: new URL(as.jwks_uri)\n        });\n    }\n    if (length !== 1) {\n        throw OPE('error when selecting a JWT verification key, multiple applicable keys found, a \"kid\" JWT Header Parameter is required', KEY_SELECTION, {\n            header,\n            candidates,\n            jwks_uri: new URL(as.jwks_uri)\n        });\n    }\n    return importJwk(alg, jwk);\n}\nconst skipSubjectCheck = Symbol();\nfunction getContentType(input) {\n    return input.headers.get(\"content-type\")?.split(\";\")[0];\n}\nasync function processUserInfoResponse(as, client, expectedSubject, response, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    checkAuthenticationChallenges(response);\n    if (response.status !== 200) {\n        throw OPE('\"response\" is not a conform UserInfo Endpoint response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);\n    }\n    assertReadableResponse(response);\n    let json;\n    if (getContentType(response) === \"application/jwt\") {\n        const { claims, jwt } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported, undefined), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt]).then(validateOptionalAudience.bind(undefined, client.client_id)).then(validateOptionalIssuer.bind(undefined, as));\n        jwtRefs.set(response, jwt);\n        json = claims;\n    } else {\n        if (client.userinfo_signed_response_alg) {\n            throw OPE(\"JWT UserInfo Response expected\", JWT_USERINFO_EXPECTED, response);\n        }\n        json = await getResponseJsonBody(response);\n    }\n    assertString(json.sub, '\"response\" body \"sub\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    switch(expectedSubject){\n        case skipSubjectCheck:\n            break;\n        default:\n            assertString(expectedSubject, '\"expectedSubject\"');\n            if (json.sub !== expectedSubject) {\n                throw OPE('unexpected \"response\" body \"sub\" property value', JSON_ATTRIBUTE_COMPARISON, {\n                    expected: expectedSubject,\n                    body: json,\n                    attribute: \"sub\"\n                });\n            }\n    }\n    return json;\n}\nasync function authenticatedRequest(as, client, clientAuthentication, url, body, headers, options) {\n    await clientAuthentication(as, client, body, headers);\n    headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n    return (options?.[customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method: \"POST\",\n        redirect: \"manual\",\n        signal: signal(url, options?.signal)\n    });\n}\nasync function tokenEndpointRequest(as, client, clientAuthentication, grantType, parameters, options) {\n    const url = resolveEndpoint(as, \"token_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    parameters.set(\"grant_type\", grantType);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        assertDPoP(options.DPoP);\n        await options.DPoP.addProof(url, headers, \"POST\");\n    }\n    const response = await authenticatedRequest(as, client, clientAuthentication, url, parameters, headers, options);\n    options?.DPoP?.cacheNonce(response, url);\n    return response;\n}\nasync function refreshTokenGrantRequest(as, client, clientAuthentication, refreshToken, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(refreshToken, '\"refreshToken\"');\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"refresh_token\", refreshToken);\n    return tokenEndpointRequest(as, client, clientAuthentication, \"refresh_token\", parameters, options);\n}\nconst idTokenClaims = new WeakMap();\nconst jwtRefs = new WeakMap();\nfunction getValidatedIdTokenClaims(ref) {\n    if (!ref.id_token) {\n        return undefined;\n    }\n    const claims = idTokenClaims.get(ref);\n    if (!claims) {\n        throw CodedTypeError('\"ref\" was already garbage collected or did not resolve from the proper sources', ERR_INVALID_ARG_VALUE);\n    }\n    return claims;\n}\nasync function validateApplicationLevelSignature(as, ref, options) {\n    assertAs(as);\n    if (!jwtRefs.has(ref)) {\n        throw CodedTypeError('\"ref\" does not contain a processed JWT Response to verify the signature of', ERR_INVALID_ARG_VALUE);\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = jwtRefs.get(ref).split(\".\");\n    const header = JSON.parse(buf(b64u(protectedHeader)));\n    if (header.alg.startsWith(\"HS\")) {\n        throw new UnsupportedOperationError(\"unsupported JWS algorithm\", {\n            cause: {\n                alg: header.alg\n            }\n        });\n    }\n    let key;\n    key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, b64u(encodedSignature));\n}\nasync function processGenericAccessTokenResponse(as, client, response, additionalRequiredIdTokenClaims, decryptFn, recognizedTokenTypes) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, \"Token Endpoint\");\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.access_token, '\"response\" body \"access_token\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    assertString(json.token_type, '\"response\" body \"token_type\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    json.token_type = json.token_type.toLowerCase();\n    if (json.expires_in !== undefined) {\n        let expiresIn = typeof json.expires_in !== \"number\" ? parseFloat(json.expires_in) : json.expires_in;\n        assertNumber(expiresIn, true, '\"response\" body \"expires_in\" property', INVALID_RESPONSE, {\n            body: json\n        });\n        json.expires_in = expiresIn;\n    }\n    if (json.refresh_token !== undefined) {\n        assertString(json.refresh_token, '\"response\" body \"refresh_token\" property', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    if (json.scope !== undefined && typeof json.scope !== \"string\") {\n        throw OPE('\"response\" body \"scope\" property must be a string', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    if (json.id_token !== undefined) {\n        assertString(json.id_token, '\"response\" body \"id_token\" property', INVALID_RESPONSE, {\n            body: json\n        });\n        const requiredClaims = [\n            \"aud\",\n            \"exp\",\n            \"iat\",\n            \"iss\",\n            \"sub\"\n        ];\n        if (client.require_auth_time === true) {\n            requiredClaims.push(\"auth_time\");\n        }\n        if (client.default_max_age !== undefined) {\n            assertNumber(client.default_max_age, true, '\"client.default_max_age\"');\n            requiredClaims.push(\"auth_time\");\n        }\n        if (additionalRequiredIdTokenClaims?.length) {\n            requiredClaims.push(...additionalRequiredIdTokenClaims);\n        }\n        const { claims, jwt } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported, \"RS256\"), getClockSkew(client), getClockTolerance(client), decryptFn).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, client.client_id));\n        if (Array.isArray(claims.aud) && claims.aud.length !== 1) {\n            if (claims.azp === undefined) {\n                throw OPE('ID Token \"aud\" (audience) claim includes additional untrusted audiences', JWT_CLAIM_COMPARISON, {\n                    claims,\n                    claim: \"aud\"\n                });\n            }\n            if (claims.azp !== client.client_id) {\n                throw OPE('unexpected ID Token \"azp\" (authorized party) claim value', JWT_CLAIM_COMPARISON, {\n                    expected: client.client_id,\n                    claims,\n                    claim: \"azp\"\n                });\n            }\n        }\n        if (claims.auth_time !== undefined) {\n            assertNumber(claims.auth_time, true, 'ID Token \"auth_time\" (authentication time)', INVALID_RESPONSE, {\n                claims\n            });\n        }\n        jwtRefs.set(response, jwt);\n        idTokenClaims.set(json, claims);\n    }\n    if (recognizedTokenTypes?.[json.token_type] !== undefined) {\n        recognizedTokenTypes[json.token_type](response, json);\n    } else if (json.token_type !== \"dpop\" && json.token_type !== \"bearer\") {\n        throw new UnsupportedOperationError(\"unsupported `token_type` value\", {\n            cause: {\n                body: json\n            }\n        });\n    }\n    return json;\n}\nfunction checkAuthenticationChallenges(response) {\n    let challenges;\n    if (challenges = parseWwwAuthenticateChallenges(response)) {\n        throw new WWWAuthenticateChallengeError(\"server responded with a challenge in the WWW-Authenticate HTTP Header\", {\n            cause: challenges,\n            response\n        });\n    }\n}\nasync function processRefreshTokenResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nfunction validateOptionalAudience(expected, result) {\n    if (result.claims.aud !== undefined) {\n        return validateAudience(expected, result);\n    }\n    return result;\n}\nfunction validateAudience(expected, result) {\n    if (Array.isArray(result.claims.aud)) {\n        if (!result.claims.aud.includes(expected)) {\n            throw OPE('unexpected JWT \"aud\" (audience) claim value', JWT_CLAIM_COMPARISON, {\n                expected,\n                claims: result.claims,\n                claim: \"aud\"\n            });\n        }\n    } else if (result.claims.aud !== expected) {\n        throw OPE('unexpected JWT \"aud\" (audience) claim value', JWT_CLAIM_COMPARISON, {\n            expected,\n            claims: result.claims,\n            claim: \"aud\"\n        });\n    }\n    return result;\n}\nfunction validateOptionalIssuer(as, result) {\n    if (result.claims.iss !== undefined) {\n        return validateIssuer(as, result);\n    }\n    return result;\n}\nfunction validateIssuer(as, result) {\n    const expected = as[_expectedIssuer]?.(result) ?? as.issuer;\n    if (result.claims.iss !== expected) {\n        throw OPE('unexpected JWT \"iss\" (issuer) claim value', JWT_CLAIM_COMPARISON, {\n            expected,\n            claims: result.claims,\n            claim: \"iss\"\n        });\n    }\n    return result;\n}\nconst branded = new WeakSet();\nfunction brand(searchParams) {\n    branded.add(searchParams);\n    return searchParams;\n}\nconst nopkce = Symbol();\nasync function authorizationCodeGrantRequest(as, client, clientAuthentication, callbackParameters, redirectUri, codeVerifier, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!branded.has(callbackParameters)) {\n        throw CodedTypeError('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()', ERR_INVALID_ARG_VALUE);\n    }\n    assertString(redirectUri, '\"redirectUri\"');\n    const code = getURLSearchParameter(callbackParameters, \"code\");\n    if (!code) {\n        throw OPE('no authorization code in \"callbackParameters\"', INVALID_RESPONSE);\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"redirect_uri\", redirectUri);\n    parameters.set(\"code\", code);\n    if (codeVerifier !== nopkce) {\n        assertString(codeVerifier, '\"codeVerifier\"');\n        parameters.set(\"code_verifier\", codeVerifier);\n    }\n    return tokenEndpointRequest(as, client, clientAuthentication, \"authorization_code\", parameters, options);\n}\nconst jwtClaimNames = {\n    aud: \"audience\",\n    c_hash: \"code hash\",\n    client_id: \"client id\",\n    exp: \"expiration time\",\n    iat: \"issued at\",\n    iss: \"issuer\",\n    jti: \"jwt id\",\n    nonce: \"nonce\",\n    s_hash: \"state hash\",\n    sub: \"subject\",\n    ath: \"access token hash\",\n    htm: \"http method\",\n    htu: \"http uri\",\n    cnf: \"confirmation\",\n    auth_time: \"authentication time\"\n};\nfunction validatePresence(required, result) {\n    for (const claim of required){\n        if (result.claims[claim] === undefined) {\n            throw OPE(`JWT \"${claim}\" (${jwtClaimNames[claim]}) claim missing`, INVALID_RESPONSE, {\n                claims: result.claims\n            });\n        }\n    }\n    return result;\n}\nconst expectNoNonce = Symbol();\nconst skipAuthTimeCheck = Symbol();\nasync function processAuthorizationCodeResponse(as, client, response, options) {\n    if (typeof options?.expectedNonce === \"string\" || typeof options?.maxAge === \"number\" || options?.requireIdToken) {\n        return processAuthorizationCodeOpenIDResponse(as, client, response, options.expectedNonce, options.maxAge, options[jweDecrypt], options.recognizedTokenTypes);\n    }\n    return processAuthorizationCodeOAuth2Response(as, client, response, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nasync function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge, decryptFn, recognizedTokenTypes) {\n    const additionalRequiredClaims = [];\n    switch(expectedNonce){\n        case undefined:\n            expectedNonce = expectNoNonce;\n            break;\n        case expectNoNonce:\n            break;\n        default:\n            assertString(expectedNonce, '\"expectedNonce\" argument');\n            additionalRequiredClaims.push(\"nonce\");\n    }\n    maxAge ??= client.default_max_age;\n    switch(maxAge){\n        case undefined:\n            maxAge = skipAuthTimeCheck;\n            break;\n        case skipAuthTimeCheck:\n            break;\n        default:\n            assertNumber(maxAge, true, '\"maxAge\" argument');\n            additionalRequiredClaims.push(\"auth_time\");\n    }\n    const result = await processGenericAccessTokenResponse(as, client, response, additionalRequiredClaims, decryptFn, recognizedTokenTypes);\n    assertString(result.id_token, '\"response\" body \"id_token\" property', INVALID_RESPONSE, {\n        body: result\n    });\n    const claims = getValidatedIdTokenClaims(result);\n    if (maxAge !== skipAuthTimeCheck) {\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw OPE(\"too much time has elapsed since the last End-User authentication\", JWT_TIMESTAMP_CHECK, {\n                claims,\n                now,\n                tolerance,\n                claim: \"auth_time\"\n            });\n        }\n    }\n    if (expectedNonce === expectNoNonce) {\n        if (claims.nonce !== undefined) {\n            throw OPE('unexpected ID Token \"nonce\" claim value', JWT_CLAIM_COMPARISON, {\n                expected: undefined,\n                claims,\n                claim: \"nonce\"\n            });\n        }\n    } else if (claims.nonce !== expectedNonce) {\n        throw OPE('unexpected ID Token \"nonce\" claim value', JWT_CLAIM_COMPARISON, {\n            expected: expectedNonce,\n            claims,\n            claim: \"nonce\"\n        });\n    }\n    return result;\n}\nasync function processAuthorizationCodeOAuth2Response(as, client, response, decryptFn, recognizedTokenTypes) {\n    const result = await processGenericAccessTokenResponse(as, client, response, undefined, decryptFn, recognizedTokenTypes);\n    const claims = getValidatedIdTokenClaims(result);\n    if (claims) {\n        if (client.default_max_age !== undefined) {\n            assertNumber(client.default_max_age, true, '\"client.default_max_age\"');\n            const now = epochTime() + getClockSkew(client);\n            const tolerance = getClockTolerance(client);\n            if (claims.auth_time + client.default_max_age < now - tolerance) {\n                throw OPE(\"too much time has elapsed since the last End-User authentication\", JWT_TIMESTAMP_CHECK, {\n                    claims,\n                    now,\n                    tolerance,\n                    claim: \"auth_time\"\n                });\n            }\n        }\n        if (claims.nonce !== undefined) {\n            throw OPE('unexpected ID Token \"nonce\" claim value', JWT_CLAIM_COMPARISON, {\n                expected: undefined,\n                claims,\n                claim: \"nonce\"\n            });\n        }\n    }\n    return result;\n}\nconst WWW_AUTHENTICATE_CHALLENGE = \"OAUTH_WWW_AUTHENTICATE_CHALLENGE\";\nconst RESPONSE_BODY_ERROR = \"OAUTH_RESPONSE_BODY_ERROR\";\nconst UNSUPPORTED_OPERATION = \"OAUTH_UNSUPPORTED_OPERATION\";\nconst AUTHORIZATION_RESPONSE_ERROR = \"OAUTH_AUTHORIZATION_RESPONSE_ERROR\";\nconst JWT_USERINFO_EXPECTED = \"OAUTH_JWT_USERINFO_EXPECTED\";\nconst PARSE_ERROR = \"OAUTH_PARSE_ERROR\";\nconst INVALID_RESPONSE = \"OAUTH_INVALID_RESPONSE\";\nconst INVALID_REQUEST = \"OAUTH_INVALID_REQUEST\";\nconst RESPONSE_IS_NOT_JSON = \"OAUTH_RESPONSE_IS_NOT_JSON\";\nconst RESPONSE_IS_NOT_CONFORM = \"OAUTH_RESPONSE_IS_NOT_CONFORM\";\nconst HTTP_REQUEST_FORBIDDEN = \"OAUTH_HTTP_REQUEST_FORBIDDEN\";\nconst REQUEST_PROTOCOL_FORBIDDEN = \"OAUTH_REQUEST_PROTOCOL_FORBIDDEN\";\nconst JWT_TIMESTAMP_CHECK = \"OAUTH_JWT_TIMESTAMP_CHECK_FAILED\";\nconst JWT_CLAIM_COMPARISON = \"OAUTH_JWT_CLAIM_COMPARISON_FAILED\";\nconst JSON_ATTRIBUTE_COMPARISON = \"OAUTH_JSON_ATTRIBUTE_COMPARISON_FAILED\";\nconst KEY_SELECTION = \"OAUTH_KEY_SELECTION_FAILED\";\nconst MISSING_SERVER_METADATA = \"OAUTH_MISSING_SERVER_METADATA\";\nconst INVALID_SERVER_METADATA = \"OAUTH_INVALID_SERVER_METADATA\";\nfunction checkJwtType(expected, result) {\n    if (typeof result.header.typ !== \"string\" || normalizeTyp(result.header.typ) !== expected) {\n        throw OPE('unexpected JWT \"typ\" header parameter value', INVALID_RESPONSE, {\n            header: result.header\n        });\n    }\n    return result;\n}\nasync function clientCredentialsGrantRequest(as, client, clientAuthentication, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    return tokenEndpointRequest(as, client, clientAuthentication, \"client_credentials\", new URLSearchParams(parameters), options);\n}\nasync function genericTokenEndpointRequest(as, client, clientAuthentication, grantType, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(grantType, '\"grantType\"');\n    return tokenEndpointRequest(as, client, clientAuthentication, grantType, new URLSearchParams(parameters), options);\n}\nasync function processGenericTokenEndpointResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nasync function processClientCredentialsResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nasync function revocationRequest(as, client, clientAuthentication, token, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(token, '\"token\"');\n    const url = resolveEndpoint(as, \"revocation_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    headers.delete(\"accept\");\n    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n}\nasync function processRevocationResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, \"Revocation Endpoint\");\n    return undefined;\n}\nfunction assertReadableResponse(response) {\n    if (response.bodyUsed) {\n        throw CodedTypeError('\"response\" body has been used already', ERR_INVALID_ARG_VALUE);\n    }\n}\nasync function introspectionRequest(as, client, clientAuthentication, token, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(token, '\"token\"');\n    const url = resolveEndpoint(as, \"introspection_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    if (options?.requestJwtResponse ?? client.introspection_signed_response_alg) {\n        headers.set(\"accept\", \"application/token-introspection+jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n    }\n    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n}\nasync function processIntrospectionResponse(as, client, response, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, \"Introspection Endpoint\");\n    let json;\n    if (getContentType(response) === \"application/token-introspection+jwt\") {\n        assertReadableResponse(response);\n        const { claims, jwt } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.introspection_signed_response_alg, as.introspection_signing_alg_values_supported, \"RS256\"), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt]).then(checkJwtType.bind(undefined, \"token-introspection+jwt\")).then(validatePresence.bind(undefined, [\n            \"aud\",\n            \"iat\",\n            \"iss\"\n        ])).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, client.client_id));\n        jwtRefs.set(response, jwt);\n        if (!isJsonObject(claims.token_introspection)) {\n            throw OPE('JWT \"token_introspection\" claim must be a JSON object', INVALID_RESPONSE, {\n                claims\n            });\n        }\n        json = claims.token_introspection;\n    } else {\n        assertReadableResponse(response);\n        json = await getResponseJsonBody(response);\n    }\n    if (typeof json.active !== \"boolean\") {\n        throw OPE('\"response\" body \"active\" property must be a boolean', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    return json;\n}\nasync function jwksRequest(as, options) {\n    assertAs(as);\n    const url = resolveEndpoint(as, \"jwks_uri\", false, options?.[allowInsecureRequests] !== true);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    headers.append(\"accept\", \"application/jwk-set+json\");\n    return (options?.[customFetch] || fetch)(url.href, {\n        body: undefined,\n        headers: Object.fromEntries(headers.entries()),\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: signal(url, options?.signal)\n    });\n}\nasync function processJwksResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    if (response.status !== 200) {\n        throw OPE('\"response\" is not a conform JSON Web Key Set response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);\n    }\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response, (response)=>assertContentTypes(response, \"application/json\", \"application/jwk-set+json\"));\n    if (!Array.isArray(json.keys)) {\n        throw OPE('\"response\" body \"keys\" property must be an array', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    if (!Array.prototype.every.call(json.keys, isJsonObject)) {\n        throw OPE('\"response\" body \"keys\" property members must be JWK formatted objects', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    return json;\n}\nfunction supported(alg) {\n    switch(alg){\n        case \"PS256\":\n        case \"ES256\":\n        case \"RS256\":\n        case \"PS384\":\n        case \"ES384\":\n        case \"RS384\":\n        case \"PS512\":\n        case \"ES512\":\n        case \"RS512\":\n        case \"Ed25519\":\n        case \"EdDSA\":\n        case \"ML-DSA-44\":\n        case \"ML-DSA-65\":\n        case \"ML-DSA-87\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction checkSupportedJwsAlg(header) {\n    if (!supported(header.alg)) {\n        throw new UnsupportedOperationError('unsupported JWS \"alg\" identifier', {\n            cause: {\n                alg: header.alg\n            }\n        });\n    }\n}\nfunction checkRsaKeyAlgorithm(key) {\n    const { algorithm } = key;\n    if (typeof algorithm.modulusLength !== \"number\" || algorithm.modulusLength < 2048) {\n        throw new UnsupportedOperationError(`unsupported ${algorithm.name} modulusLength`, {\n            cause: key\n        });\n    }\n}\nfunction ecdsaHashName(key) {\n    const { algorithm } = key;\n    switch(algorithm.namedCurve){\n        case \"P-256\":\n            return \"SHA-256\";\n        case \"P-384\":\n            return \"SHA-384\";\n        case \"P-521\":\n            return \"SHA-512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported ECDSA namedCurve\", {\n                cause: key\n            });\n    }\n}\nfunction keyToSubtle(key) {\n    switch(key.algorithm.name){\n        case \"ECDSA\":\n            return {\n                name: key.algorithm.name,\n                hash: ecdsaHashName(key)\n            };\n        case \"RSA-PSS\":\n            {\n                checkRsaKeyAlgorithm(key);\n                switch(key.algorithm.hash.name){\n                    case \"SHA-256\":\n                    case \"SHA-384\":\n                    case \"SHA-512\":\n                        return {\n                            name: key.algorithm.name,\n                            saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3\n                        };\n                    default:\n                        throw new UnsupportedOperationError(\"unsupported RSA-PSS hash name\", {\n                            cause: key\n                        });\n                }\n            }\n        case \"RSASSA-PKCS1-v1_5\":\n            checkRsaKeyAlgorithm(key);\n            return key.algorithm.name;\n        case \"ML-DSA-44\":\n        case \"ML-DSA-65\":\n        case \"ML-DSA-87\":\n        case \"Ed25519\":\n            return key.algorithm.name;\n    }\n    throw new UnsupportedOperationError(\"unsupported CryptoKey algorithm name\", {\n        cause: key\n    });\n}\nasync function validateJwsSignature(protectedHeader, payload, key, signature) {\n    const data = buf(`${protectedHeader}.${payload}`);\n    const algorithm = keyToSubtle(key);\n    const verified = await crypto.subtle.verify(algorithm, key, signature, data);\n    if (!verified) {\n        throw OPE(\"JWT signature verification failed\", INVALID_RESPONSE, {\n            key,\n            data,\n            signature,\n            algorithm\n        });\n    }\n}\nasync function validateJwt(jws, checkAlg, clockSkew, clockTolerance, decryptJwt) {\n    let { 0: protectedHeader, 1: payload, length } = jws.split(\".\");\n    if (length === 5) {\n        if (decryptJwt !== undefined) {\n            jws = await decryptJwt(jws);\n            ({ 0: protectedHeader, 1: payload, length } = jws.split(\".\"));\n        } else {\n            throw new UnsupportedOperationError(\"JWE decryption is not configured\", {\n                cause: jws\n            });\n        }\n    }\n    if (length !== 3) {\n        throw OPE(\"Invalid JWT\", INVALID_RESPONSE, jws);\n    }\n    let header;\n    try {\n        header = JSON.parse(buf(b64u(protectedHeader)));\n    } catch (cause) {\n        throw OPE(\"failed to parse JWT Header body as base64url encoded JSON\", PARSE_ERROR, cause);\n    }\n    if (!isJsonObject(header)) {\n        throw OPE(\"JWT Header must be a top level object\", INVALID_RESPONSE, jws);\n    }\n    checkAlg(header);\n    if (header.crit !== undefined) {\n        throw new UnsupportedOperationError('no JWT \"crit\" header parameter extensions are supported', {\n            cause: {\n                header\n            }\n        });\n    }\n    let claims;\n    try {\n        claims = JSON.parse(buf(b64u(payload)));\n    } catch (cause) {\n        throw OPE(\"failed to parse JWT Payload body as base64url encoded JSON\", PARSE_ERROR, cause);\n    }\n    if (!isJsonObject(claims)) {\n        throw OPE(\"JWT Payload must be a top level object\", INVALID_RESPONSE, jws);\n    }\n    const now = epochTime() + clockSkew;\n    if (claims.exp !== undefined) {\n        if (typeof claims.exp !== \"number\") {\n            throw OPE('unexpected JWT \"exp\" (expiration time) claim type', INVALID_RESPONSE, {\n                claims\n            });\n        }\n        if (claims.exp <= now - clockTolerance) {\n            throw OPE('unexpected JWT \"exp\" (expiration time) claim value, expiration is past current timestamp', JWT_TIMESTAMP_CHECK, {\n                claims,\n                now,\n                tolerance: clockTolerance,\n                claim: \"exp\"\n            });\n        }\n    }\n    if (claims.iat !== undefined) {\n        if (typeof claims.iat !== \"number\") {\n            throw OPE('unexpected JWT \"iat\" (issued at) claim type', INVALID_RESPONSE, {\n                claims\n            });\n        }\n    }\n    if (claims.iss !== undefined) {\n        if (typeof claims.iss !== \"string\") {\n            throw OPE('unexpected JWT \"iss\" (issuer) claim type', INVALID_RESPONSE, {\n                claims\n            });\n        }\n    }\n    if (claims.nbf !== undefined) {\n        if (typeof claims.nbf !== \"number\") {\n            throw OPE('unexpected JWT \"nbf\" (not before) claim type', INVALID_RESPONSE, {\n                claims\n            });\n        }\n        if (claims.nbf > now + clockTolerance) {\n            throw OPE('unexpected JWT \"nbf\" (not before) claim value', JWT_TIMESTAMP_CHECK, {\n                claims,\n                now,\n                tolerance: clockTolerance,\n                claim: \"nbf\"\n            });\n        }\n    }\n    if (claims.aud !== undefined) {\n        if (typeof claims.aud !== \"string\" && !Array.isArray(claims.aud)) {\n            throw OPE('unexpected JWT \"aud\" (audience) claim type', INVALID_RESPONSE, {\n                claims\n            });\n        }\n    }\n    return {\n        header,\n        claims,\n        jwt: jws\n    };\n}\nasync function validateJwtAuthResponse(as, client, parameters, expectedState, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw CodedTypeError('\"parameters\" must be an instance of URLSearchParams, or URL', ERR_INVALID_ARG_TYPE);\n    }\n    const response = getURLSearchParameter(parameters, \"response\");\n    if (!response) {\n        throw OPE('\"parameters\" does not contain a JARM response', INVALID_RESPONSE);\n    }\n    const { claims, header, jwt } = await validateJwt(response, checkSigningAlgorithm.bind(undefined, client.authorization_signed_response_alg, as.authorization_signing_alg_values_supported, \"RS256\"), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt]).then(validatePresence.bind(undefined, [\n        \"aud\",\n        \"exp\",\n        \"iss\"\n    ])).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, client.client_id));\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = jwt.split(\".\");\n    const signature = b64u(encodedSignature);\n    const key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, signature);\n    const result = new URLSearchParams();\n    for (const [key, value] of Object.entries(claims)){\n        if (typeof value === \"string\" && key !== \"aud\") {\n            result.set(key, value);\n        }\n    }\n    return validateAuthResponse(as, client, result, expectedState);\n}\nasync function idTokenHash(data, header, claimName) {\n    let algorithm;\n    switch(header.alg){\n        case \"RS256\":\n        case \"PS256\":\n        case \"ES256\":\n            algorithm = \"SHA-256\";\n            break;\n        case \"RS384\":\n        case \"PS384\":\n        case \"ES384\":\n            algorithm = \"SHA-384\";\n            break;\n        case \"RS512\":\n        case \"PS512\":\n        case \"ES512\":\n        case \"Ed25519\":\n        case \"EdDSA\":\n            algorithm = \"SHA-512\";\n            break;\n        case \"ML-DSA-44\":\n        case \"ML-DSA-65\":\n        case \"ML-DSA-87\":\n            algorithm = {\n                name: \"cSHAKE256\",\n                length: 512\n            };\n            break;\n        default:\n            throw new UnsupportedOperationError(`unsupported JWS algorithm for ${claimName} calculation`, {\n                cause: {\n                    alg: header.alg\n                }\n            });\n    }\n    const digest = await crypto.subtle.digest(algorithm, buf(data));\n    return b64u(digest.slice(0, digest.byteLength / 2));\n}\nasync function idTokenHashMatches(data, actual, header, claimName) {\n    const expected = await idTokenHash(data, header, claimName);\n    return actual === expected;\n}\nasync function validateDetachedSignatureResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {\n    return validateHybridResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options, true);\n}\nasync function validateCodeIdTokenResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {\n    return validateHybridResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options, false);\n}\nasync function consumeStream(request) {\n    if (request.bodyUsed) {\n        throw CodedTypeError(\"form_post Request instances must contain a readable body\", ERR_INVALID_ARG_VALUE, {\n            cause: request\n        });\n    }\n    return request.text();\n}\nasync function formPostResponse(request) {\n    if (request.method !== \"POST\") {\n        throw CodedTypeError(\"form_post responses are expected to use the POST method\", ERR_INVALID_ARG_VALUE, {\n            cause: request\n        });\n    }\n    if (getContentType(request) !== \"application/x-www-form-urlencoded\") {\n        throw CodedTypeError(\"form_post responses are expected to use the application/x-www-form-urlencoded content-type\", ERR_INVALID_ARG_VALUE, {\n            cause: request\n        });\n    }\n    return consumeStream(request);\n}\nasync function validateHybridResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options, fapi) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        if (!parameters.hash.length) {\n            throw CodedTypeError('\"parameters\" as an instance of URL must contain a hash (fragment) with the Authorization Response parameters', ERR_INVALID_ARG_VALUE);\n        }\n        parameters = new URLSearchParams(parameters.hash.slice(1));\n    } else if (looseInstanceOf(parameters, Request)) {\n        parameters = new URLSearchParams(await formPostResponse(parameters));\n    } else if (parameters instanceof URLSearchParams) {\n        parameters = new URLSearchParams(parameters);\n    } else {\n        throw CodedTypeError('\"parameters\" must be an instance of URLSearchParams, URL, or Response', ERR_INVALID_ARG_TYPE);\n    }\n    const id_token = getURLSearchParameter(parameters, \"id_token\");\n    parameters.delete(\"id_token\");\n    switch(expectedState){\n        case undefined:\n        case expectNoState:\n            break;\n        default:\n            assertString(expectedState, '\"expectedState\" argument');\n    }\n    const result = validateAuthResponse({\n        ...as,\n        authorization_response_iss_parameter_supported: false\n    }, client, parameters, expectedState);\n    if (!id_token) {\n        throw OPE('\"parameters\" does not contain an ID Token', INVALID_RESPONSE);\n    }\n    const code = getURLSearchParameter(parameters, \"code\");\n    if (!code) {\n        throw OPE('\"parameters\" does not contain an Authorization Code', INVALID_RESPONSE);\n    }\n    const requiredClaims = [\n        \"aud\",\n        \"exp\",\n        \"iat\",\n        \"iss\",\n        \"sub\",\n        \"nonce\",\n        \"c_hash\"\n    ];\n    const state = parameters.get(\"state\");\n    if (fapi && (typeof expectedState === \"string\" || state !== null)) {\n        requiredClaims.push(\"s_hash\");\n    }\n    if (maxAge !== undefined) {\n        assertNumber(maxAge, true, '\"maxAge\" argument');\n    } else if (client.default_max_age !== undefined) {\n        assertNumber(client.default_max_age, true, '\"client.default_max_age\"');\n    }\n    maxAge ??= client.default_max_age ?? skipAuthTimeCheck;\n    if (client.require_auth_time || maxAge !== skipAuthTimeCheck) {\n        requiredClaims.push(\"auth_time\");\n    }\n    const { claims, header, jwt } = await validateJwt(id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported, \"RS256\"), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt]).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, client.client_id));\n    const clockSkew = getClockSkew(client);\n    const now = epochTime() + clockSkew;\n    if (claims.iat < now - 3600) {\n        throw OPE('unexpected JWT \"iat\" (issued at) claim value, it is too far in the past', JWT_TIMESTAMP_CHECK, {\n            now,\n            claims,\n            claim: \"iat\"\n        });\n    }\n    assertString(claims.c_hash, 'ID Token \"c_hash\" (code hash) claim value', INVALID_RESPONSE, {\n        claims\n    });\n    if (claims.auth_time !== undefined) {\n        assertNumber(claims.auth_time, true, 'ID Token \"auth_time\" (authentication time)', INVALID_RESPONSE, {\n            claims\n        });\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw OPE(\"too much time has elapsed since the last End-User authentication\", JWT_TIMESTAMP_CHECK, {\n                claims,\n                now,\n                tolerance,\n                claim: \"auth_time\"\n            });\n        }\n    }\n    assertString(expectedNonce, '\"expectedNonce\" argument');\n    if (claims.nonce !== expectedNonce) {\n        throw OPE('unexpected ID Token \"nonce\" claim value', JWT_CLAIM_COMPARISON, {\n            expected: expectedNonce,\n            claims,\n            claim: \"nonce\"\n        });\n    }\n    if (Array.isArray(claims.aud) && claims.aud.length !== 1) {\n        if (claims.azp === undefined) {\n            throw OPE('ID Token \"aud\" (audience) claim includes additional untrusted audiences', JWT_CLAIM_COMPARISON, {\n                claims,\n                claim: \"aud\"\n            });\n        }\n        if (claims.azp !== client.client_id) {\n            throw OPE('unexpected ID Token \"azp\" (authorized party) claim value', JWT_CLAIM_COMPARISON, {\n                expected: client.client_id,\n                claims,\n                claim: \"azp\"\n            });\n        }\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = jwt.split(\".\");\n    const signature = b64u(encodedSignature);\n    const key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, signature);\n    if (await idTokenHashMatches(code, claims.c_hash, header, \"c_hash\") !== true) {\n        throw OPE('invalid ID Token \"c_hash\" (code hash) claim value', JWT_CLAIM_COMPARISON, {\n            code,\n            alg: header.alg,\n            claim: \"c_hash\",\n            claims\n        });\n    }\n    if (fapi && state !== null || claims.s_hash !== undefined) {\n        assertString(claims.s_hash, 'ID Token \"s_hash\" (state hash) claim value', INVALID_RESPONSE, {\n            claims\n        });\n        assertString(state, '\"state\" response parameter', INVALID_RESPONSE, {\n            parameters\n        });\n        if (await idTokenHashMatches(state, claims.s_hash, header, \"s_hash\") !== true) {\n            throw OPE('invalid ID Token \"s_hash\" (state hash) claim value', JWT_CLAIM_COMPARISON, {\n                state,\n                alg: header.alg,\n                claim: \"s_hash\",\n                claims\n            });\n        }\n    }\n    return result;\n}\nfunction checkSigningAlgorithm(client, issuer, fallback, header) {\n    if (client !== undefined) {\n        if (typeof client === \"string\" ? header.alg !== client : !client.includes(header.alg)) {\n            throw OPE('unexpected JWT \"alg\" header parameter', INVALID_RESPONSE, {\n                header,\n                expected: client,\n                reason: \"client configuration\"\n            });\n        }\n        return;\n    }\n    if (Array.isArray(issuer)) {\n        if (!issuer.includes(header.alg)) {\n            throw OPE('unexpected JWT \"alg\" header parameter', INVALID_RESPONSE, {\n                header,\n                expected: issuer,\n                reason: \"authorization server metadata\"\n            });\n        }\n        return;\n    }\n    if (fallback !== undefined) {\n        if (typeof fallback === \"string\" ? header.alg !== fallback : typeof fallback === \"function\" ? !fallback(header.alg) : !fallback.includes(header.alg)) {\n            throw OPE('unexpected JWT \"alg\" header parameter', INVALID_RESPONSE, {\n                header,\n                expected: fallback,\n                reason: \"default value\"\n            });\n        }\n        return;\n    }\n    throw OPE('missing client or server configuration to verify used JWT \"alg\" header parameter', undefined, {\n        client,\n        issuer,\n        fallback\n    });\n}\nfunction getURLSearchParameter(parameters, name) {\n    const { 0: value, length } = parameters.getAll(name);\n    if (length > 1) {\n        throw OPE(`\"${name}\" parameter must be provided only once`, INVALID_RESPONSE);\n    }\n    return value;\n}\nconst skipStateCheck = Symbol();\nconst expectNoState = Symbol();\nfunction validateAuthResponse(as, client, parameters, expectedState) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw CodedTypeError('\"parameters\" must be an instance of URLSearchParams, or URL', ERR_INVALID_ARG_TYPE);\n    }\n    if (getURLSearchParameter(parameters, \"response\")) {\n        throw OPE('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()', INVALID_RESPONSE, {\n            parameters\n        });\n    }\n    const iss = getURLSearchParameter(parameters, \"iss\");\n    const state = getURLSearchParameter(parameters, \"state\");\n    if (!iss && as.authorization_response_iss_parameter_supported) {\n        throw OPE('response parameter \"iss\" (issuer) missing', INVALID_RESPONSE, {\n            parameters\n        });\n    }\n    if (iss && iss !== as.issuer) {\n        throw OPE('unexpected \"iss\" (issuer) response parameter value', INVALID_RESPONSE, {\n            expected: as.issuer,\n            parameters\n        });\n    }\n    switch(expectedState){\n        case undefined:\n        case expectNoState:\n            if (state !== undefined) {\n                throw OPE('unexpected \"state\" response parameter encountered', INVALID_RESPONSE, {\n                    expected: undefined,\n                    parameters\n                });\n            }\n            break;\n        case skipStateCheck:\n            break;\n        default:\n            assertString(expectedState, '\"expectedState\" argument');\n            if (state !== expectedState) {\n                throw OPE(state === undefined ? 'response parameter \"state\" missing' : 'unexpected \"state\" response parameter value', INVALID_RESPONSE, {\n                    expected: expectedState,\n                    parameters\n                });\n            }\n    }\n    const error = getURLSearchParameter(parameters, \"error\");\n    if (error) {\n        throw new AuthorizationResponseError(\"authorization response from the server is an error\", {\n            cause: parameters\n        });\n    }\n    const id_token = getURLSearchParameter(parameters, \"id_token\");\n    const token = getURLSearchParameter(parameters, \"token\");\n    if (id_token !== undefined || token !== undefined) {\n        throw new UnsupportedOperationError(\"implicit and hybrid flows are not supported\");\n    }\n    return brand(new URLSearchParams(parameters));\n}\nfunction algToSubtle(alg) {\n    switch(alg){\n        case \"PS256\":\n        case \"PS384\":\n        case \"PS512\":\n            return {\n                name: \"RSA-PSS\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"RS256\":\n        case \"RS384\":\n        case \"RS512\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"ES256\":\n        case \"ES384\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: `P-${alg.slice(-3)}`\n            };\n        case \"ES512\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-521\"\n            };\n        case \"EdDSA\":\n            return \"Ed25519\";\n        case \"Ed25519\":\n        case \"ML-DSA-44\":\n        case \"ML-DSA-65\":\n        case \"ML-DSA-87\":\n            return alg;\n        default:\n            throw new UnsupportedOperationError(\"unsupported JWS algorithm\", {\n                cause: {\n                    alg\n                }\n            });\n    }\n}\nasync function importJwk(alg, jwk) {\n    const { ext, key_ops, use, ...key } = jwk;\n    return crypto.subtle.importKey(\"jwk\", key, algToSubtle(alg), true, [\n        \"verify\"\n    ]);\n}\nasync function deviceAuthorizationRequest(as, client, clientAuthentication, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"device_authorization_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n}\nasync function processDeviceAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, \"Device Authorization Endpoint\");\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.device_code, '\"response\" body \"device_code\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    assertString(json.user_code, '\"response\" body \"user_code\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    assertString(json.verification_uri, '\"response\" body \"verification_uri\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    let expiresIn = typeof json.expires_in !== \"number\" ? parseFloat(json.expires_in) : json.expires_in;\n    assertNumber(expiresIn, true, '\"response\" body \"expires_in\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    json.expires_in = expiresIn;\n    if (json.verification_uri_complete !== undefined) {\n        assertString(json.verification_uri_complete, '\"response\" body \"verification_uri_complete\" property', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    if (json.interval !== undefined) {\n        assertNumber(json.interval, false, '\"response\" body \"interval\" property', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    return json;\n}\nasync function deviceCodeGrantRequest(as, client, clientAuthentication, deviceCode, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(deviceCode, '\"deviceCode\"');\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"device_code\", deviceCode);\n    return tokenEndpointRequest(as, client, clientAuthentication, \"urn:ietf:params:oauth:grant-type:device_code\", parameters, options);\n}\nasync function processDeviceCodeResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nasync function generateKeyPair(alg, options) {\n    assertString(alg, '\"alg\"');\n    const algorithm = algToSubtle(alg);\n    if (alg.startsWith(\"PS\") || alg.startsWith(\"RS\")) {\n        Object.assign(algorithm, {\n            modulusLength: options?.modulusLength ?? 2048,\n            publicExponent: new Uint8Array([\n                0x01,\n                0x00,\n                0x01\n            ])\n        });\n    }\n    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, [\n        \"sign\",\n        \"verify\"\n    ]);\n}\nfunction normalizeHtu(htu) {\n    const url = new URL(htu);\n    url.search = \"\";\n    url.hash = \"\";\n    return url.href;\n}\nasync function validateDPoP(request, accessToken, accessTokenClaims, options) {\n    const headerValue = request.headers.get(\"dpop\");\n    if (headerValue === null) {\n        throw OPE(\"operation indicated DPoP use but the request has no DPoP HTTP Header\", INVALID_REQUEST, {\n            headers: request.headers\n        });\n    }\n    if (request.headers.get(\"authorization\")?.toLowerCase().startsWith(\"dpop \") === false) {\n        throw OPE(`operation indicated DPoP use but the request's Authorization HTTP Header scheme is not DPoP`, INVALID_REQUEST, {\n            headers: request.headers\n        });\n    }\n    if (typeof accessTokenClaims.cnf?.jkt !== \"string\") {\n        throw OPE(\"operation indicated DPoP use but the JWT Access Token has no jkt confirmation claim\", INVALID_REQUEST, {\n            claims: accessTokenClaims\n        });\n    }\n    const clockSkew = getClockSkew(options);\n    const proof = await validateJwt(headerValue, checkSigningAlgorithm.bind(undefined, options?.signingAlgorithms, undefined, supported), clockSkew, getClockTolerance(options), undefined).then(checkJwtType.bind(undefined, \"dpop+jwt\")).then(validatePresence.bind(undefined, [\n        \"iat\",\n        \"jti\",\n        \"ath\",\n        \"htm\",\n        \"htu\"\n    ]));\n    const now = epochTime() + clockSkew;\n    const diff = Math.abs(now - proof.claims.iat);\n    if (diff > 300) {\n        throw OPE(\"DPoP Proof iat is not recent enough\", JWT_TIMESTAMP_CHECK, {\n            now,\n            claims: proof.claims,\n            claim: \"iat\"\n        });\n    }\n    if (proof.claims.htm !== request.method) {\n        throw OPE(\"DPoP Proof htm mismatch\", JWT_CLAIM_COMPARISON, {\n            expected: request.method,\n            claims: proof.claims,\n            claim: \"htm\"\n        });\n    }\n    if (typeof proof.claims.htu !== \"string\" || normalizeHtu(proof.claims.htu) !== normalizeHtu(request.url)) {\n        throw OPE(\"DPoP Proof htu mismatch\", JWT_CLAIM_COMPARISON, {\n            expected: normalizeHtu(request.url),\n            claims: proof.claims,\n            claim: \"htu\"\n        });\n    }\n    {\n        const expected = b64u(await crypto.subtle.digest(\"SHA-256\", buf(accessToken)));\n        if (proof.claims.ath !== expected) {\n            throw OPE(\"DPoP Proof ath mismatch\", JWT_CLAIM_COMPARISON, {\n                expected,\n                claims: proof.claims,\n                claim: \"ath\"\n            });\n        }\n    }\n    {\n        const expected = await calculateJwkThumbprint(proof.header.jwk);\n        if (accessTokenClaims.cnf.jkt !== expected) {\n            throw OPE(\"JWT Access Token confirmation mismatch\", JWT_CLAIM_COMPARISON, {\n                expected,\n                claims: accessTokenClaims,\n                claim: \"cnf.jkt\"\n            });\n        }\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = headerValue.split(\".\");\n    const signature = b64u(encodedSignature);\n    const { jwk, alg } = proof.header;\n    if (!jwk) {\n        throw OPE(\"DPoP Proof is missing the jwk header parameter\", INVALID_REQUEST, {\n            header: proof.header\n        });\n    }\n    const key = await importJwk(alg, jwk);\n    if (key.type !== \"public\") {\n        throw OPE(\"DPoP Proof jwk header parameter must contain a public key\", INVALID_REQUEST, {\n            header: proof.header\n        });\n    }\n    await validateJwsSignature(protectedHeader, payload, key, signature);\n}\nasync function validateJwtAccessToken(as, request, expectedAudience, options) {\n    assertAs(as);\n    if (!looseInstanceOf(request, Request)) {\n        throw CodedTypeError('\"request\" must be an instance of Request', ERR_INVALID_ARG_TYPE);\n    }\n    assertString(expectedAudience, '\"expectedAudience\"');\n    const authorization = request.headers.get(\"authorization\");\n    if (authorization === null) {\n        throw OPE('\"request\" is missing an Authorization HTTP Header', INVALID_REQUEST, {\n            headers: request.headers\n        });\n    }\n    let { 0: scheme, 1: accessToken, length } = authorization.split(\" \");\n    scheme = scheme.toLowerCase();\n    switch(scheme){\n        case \"dpop\":\n        case \"bearer\":\n            break;\n        default:\n            throw new UnsupportedOperationError(\"unsupported Authorization HTTP Header scheme\", {\n                cause: {\n                    headers: request.headers\n                }\n            });\n    }\n    if (length !== 2) {\n        throw OPE(\"invalid Authorization HTTP Header format\", INVALID_REQUEST, {\n            headers: request.headers\n        });\n    }\n    const requiredClaims = [\n        \"iss\",\n        \"exp\",\n        \"aud\",\n        \"sub\",\n        \"iat\",\n        \"jti\",\n        \"client_id\"\n    ];\n    if (options?.requireDPoP || scheme === \"dpop\" || request.headers.has(\"dpop\")) {\n        requiredClaims.push(\"cnf\");\n    }\n    const { claims, header } = await validateJwt(accessToken, checkSigningAlgorithm.bind(undefined, options?.signingAlgorithms, undefined, supported), getClockSkew(options), getClockTolerance(options), undefined).then(checkJwtType.bind(undefined, \"at+jwt\")).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, expectedAudience)).catch(reassignRSCode);\n    for (const claim of [\n        \"client_id\",\n        \"jti\",\n        \"sub\"\n    ]){\n        if (typeof claims[claim] !== \"string\") {\n            throw OPE(`unexpected JWT \"${claim}\" claim type`, INVALID_REQUEST, {\n                claims\n            });\n        }\n    }\n    if (\"cnf\" in claims) {\n        if (!isJsonObject(claims.cnf)) {\n            throw OPE('unexpected JWT \"cnf\" (confirmation) claim value', INVALID_REQUEST, {\n                claims\n            });\n        }\n        const { 0: cnf, length } = Object.keys(claims.cnf);\n        if (length) {\n            if (length !== 1) {\n                throw new UnsupportedOperationError(\"multiple confirmation claims are not supported\", {\n                    cause: {\n                        claims\n                    }\n                });\n            }\n            if (cnf !== \"jkt\") {\n                throw new UnsupportedOperationError(\"unsupported JWT Confirmation method\", {\n                    cause: {\n                        claims\n                    }\n                });\n            }\n        }\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = accessToken.split(\".\");\n    const signature = b64u(encodedSignature);\n    const key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, signature);\n    if (options?.requireDPoP || scheme === \"dpop\" || claims.cnf?.jkt !== undefined || request.headers.has(\"dpop\")) {\n        await validateDPoP(request, accessToken, claims, options).catch(reassignRSCode);\n    }\n    return claims;\n}\nfunction reassignRSCode(err) {\n    if (err instanceof OperationProcessingError && err?.code === INVALID_REQUEST) {\n        err.code = INVALID_RESPONSE;\n    }\n    throw err;\n}\nasync function backchannelAuthenticationRequest(as, client, clientAuthentication, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"backchannel_authentication_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n}\nasync function processBackchannelAuthenticationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, \"Backchannel Authentication Endpoint\");\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.auth_req_id, '\"response\" body \"auth_req_id\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    let expiresIn = typeof json.expires_in !== \"number\" ? parseFloat(json.expires_in) : json.expires_in;\n    assertNumber(expiresIn, true, '\"response\" body \"expires_in\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    json.expires_in = expiresIn;\n    if (json.interval !== undefined) {\n        assertNumber(json.interval, false, '\"response\" body \"interval\" property', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    return json;\n}\nasync function backchannelAuthenticationGrantRequest(as, client, clientAuthentication, authReqId, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(authReqId, '\"authReqId\"');\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"auth_req_id\", authReqId);\n    return tokenEndpointRequest(as, client, clientAuthentication, \"urn:openid:params:grant-type:ciba\", parameters, options);\n}\nasync function processBackchannelAuthenticationGrantResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nasync function dynamicClientRegistrationRequest(as, metadata, options) {\n    assertAs(as);\n    const url = resolveEndpoint(as, \"registration_endpoint\", metadata.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    headers.set(\"content-type\", \"application/json\");\n    const method = \"POST\";\n    if (options?.DPoP) {\n        assertDPoP(options.DPoP);\n        await options.DPoP.addProof(url, headers, method, options.initialAccessToken);\n    }\n    if (options?.initialAccessToken) {\n        headers.set(\"authorization\", `${headers.has(\"dpop\") ? \"DPoP\" : \"Bearer\"} ${options.initialAccessToken}`);\n    }\n    const response = await (options?.[customFetch] || fetch)(url.href, {\n        body: JSON.stringify(metadata),\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: \"manual\",\n        signal: signal(url, options?.signal)\n    });\n    options?.DPoP?.cacheNonce(response, url);\n    return response;\n}\nasync function processDynamicClientRegistrationResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 201, \"Dynamic Client Registration Endpoint\");\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.client_id, '\"response\" body \"client_id\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    if (json.client_secret !== undefined) {\n        assertString(json.client_secret, '\"response\" body \"client_secret\" property', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    if (json.client_secret) {\n        assertNumber(json.client_secret_expires_at, true, '\"response\" body \"client_secret_expires_at\" property', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    return json;\n}\nasync function resourceDiscoveryRequest(resourceIdentifier, options) {\n    return performDiscovery(resourceIdentifier, \"resourceIdentifier\", (url)=>{\n        prependWellKnown(url, \".well-known/oauth-protected-resource\", true);\n        return url;\n    }, options);\n}\nasync function processResourceDiscoveryResponse(expectedResourceIdentifier, response) {\n    const expected = expectedResourceIdentifier;\n    if (!(expected instanceof URL) && expected !== _nodiscoverycheck) {\n        throw CodedTypeError('\"expectedResourceIdentifier\" must be an instance of URL', ERR_INVALID_ARG_TYPE);\n    }\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    if (response.status !== 200) {\n        throw OPE('\"response\" is not a conform Resource Server Metadata response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);\n    }\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.resource, '\"response\" body \"resource\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    if (expected !== _nodiscoverycheck && new URL(json.resource).href !== expected.href) {\n        throw OPE('\"response\" body \"resource\" property does not match the expected value', JSON_ATTRIBUTE_COMPARISON, {\n            expected: expected.href,\n            body: json,\n            attribute: \"resource\"\n        });\n    }\n    return json;\n}\nasync function getResponseJsonBody(response, check = assertApplicationJson) {\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        check(response);\n        throw OPE('failed to parse \"response\" body as JSON', PARSE_ERROR, cause);\n    }\n    if (!isJsonObject(json)) {\n        throw OPE('\"response\" body must be a top level object', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    return json;\n}\nconst _nopkce = nopkce;\nconst _nodiscoverycheck = Symbol();\nconst _expectedIssuer = Symbol(); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb2F1dGg0d2ViYXBpL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUE7QUFDSixJQUFJLE9BQU9DLGNBQWMsZUFBZSxDQUFDQSxVQUFVQyxTQUFTLEVBQUVDLGFBQWEsaUJBQWlCO0lBQ3hGLE1BQU1DLE9BQU87SUFDYixNQUFNQyxVQUFVO0lBQ2hCTCxhQUFhLENBQUMsRUFBRUksS0FBSyxDQUFDLEVBQUVDLFFBQVEsQ0FBQztBQUNyQztBQUNBLFNBQVNDLGdCQUFnQkMsS0FBSyxFQUFFQyxRQUFRO0lBQ3BDLElBQUlELFNBQVMsTUFBTTtRQUNmLE9BQU87SUFDWDtJQUNBLElBQUk7UUFDQSxPQUFRQSxpQkFBaUJDLFlBQ3JCQyxPQUFPQyxjQUFjLENBQUNILE1BQU0sQ0FBQ0ksT0FBT0MsV0FBVyxDQUFDLEtBQUtKLFNBQVNLLFNBQVMsQ0FBQ0YsT0FBT0MsV0FBVyxDQUFDO0lBQ25HLEVBQ0EsT0FBTTtRQUNGLE9BQU87SUFDWDtBQUNKO0FBQ0EsTUFBTUUsd0JBQXdCO0FBQzlCLE1BQU1DLHVCQUF1QjtBQUM3QixTQUFTQyxlQUFlQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsS0FBSztJQUN4QyxNQUFNQyxNQUFNLElBQUlDLFVBQVVKLFNBQVM7UUFBRUU7SUFBTTtJQUMzQ1YsT0FBT2EsTUFBTSxDQUFDRixLQUFLO1FBQUVGO0lBQUs7SUFDMUIsT0FBT0U7QUFDWDtBQUNPLE1BQU1HLHdCQUF3QlosU0FBUztBQUN2QyxNQUFNYSxZQUFZYixTQUFTO0FBQzNCLE1BQU1jLGlCQUFpQmQsU0FBUztBQUNoQyxNQUFNZSxjQUFjZixTQUFTO0FBQzdCLE1BQU1nQixrQkFBa0JoQixTQUFTO0FBQ2pDLE1BQU1pQixhQUFhakIsU0FBUztB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LGFBQWFTLEtBQUswRixRQUFRLEVBQUUsdUNBQXVDdkYsa0JBQWtCO1FBQ2pGdEIsTUFBTW1CO0lBQ1Y7SUFDQSxJQUFJekksYUFBYW9JLHFCQUFxQixJQUFJakIsSUFBSXNCLEtBQUswRixRQUFRLEVBQUU1SCxJQUFJLEtBQUt2RyxTQUFTdUcsSUFBSSxFQUFFO1FBQ2pGLE1BQU14QyxJQUFJLHlFQUF5RThFLDJCQUEyQjtZQUFFN0ksVUFBVUEsU0FBU3VHLElBQUk7WUFBRWUsTUFBTW1CO1lBQU1LLFdBQVc7UUFBVztJQUMvSztJQUNBLE9BQU9MO0FBQ1g7QUFDQSxlQUFlQyxvQkFBb0JQLFFBQVEsRUFBRXVZLFFBQVEzWCxxQkFBcUI7SUFDdEUsSUFBSU47SUFDSixJQUFJO1FBQ0FBLE9BQU8sTUFBTU4sU0FBU00sSUFBSTtJQUM5QixFQUNBLE9BQU85SCxPQUFPO1FBQ1YrZixNQUFNdlk7UUFDTixNQUFNcEUsSUFBSSwyQ0FBMkMwSyxhQUFhOU47SUFDdEU7SUFDQSxJQUFJLENBQUMrRSxhQUFhK0MsT0FBTztRQUNyQixNQUFNMUUsSUFBSSw4Q0FBOEM2RSxrQkFBa0I7WUFBRXRCLE1BQU1tQjtRQUFLO0lBQzNGO0lBQ0EsT0FBT0E7QUFDWDtBQUNPLE1BQU1rWSxVQUFVckgsT0FBTztBQUN2QixNQUFNbFIsb0JBQW9CakksU0FBUztBQUNuQyxNQUFNK1ksa0JBQWtCL1ksU0FBUyxDQUN4QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWRmbG93LXNhYXMvLi9ub2RlX21vZHVsZXMvb2F1dGg0d2ViYXBpL2J1aWxkL2luZGV4LmpzPzNkNDEiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IFVTRVJfQUdFTlQ7XG5pZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci51c2VyQWdlbnQ/LnN0YXJ0c1dpdGg/LignTW96aWxsYS81LjAgJykpIHtcbiAgICBjb25zdCBOQU1FID0gJ29hdXRoNHdlYmFwaSc7XG4gICAgY29uc3QgVkVSU0lPTiA9ICd2My44LjInO1xuICAgIFVTRVJfQUdFTlQgPSBgJHtOQU1FfS8ke1ZFUlNJT059YDtcbn1cbmZ1bmN0aW9uIGxvb3NlSW5zdGFuY2VPZihpbnB1dCwgZXhwZWN0ZWQpIHtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoaW5wdXQgaW5zdGFuY2VvZiBleHBlY3RlZCB8fFxuICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0KVtTeW1ib2wudG9TdHJpbmdUYWddID09PSBleHBlY3RlZC5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IEVSUl9JTlZBTElEX0FSR19WQUxVRSA9ICdFUlJfSU5WQUxJRF9BUkdfVkFMVUUnO1xuY29uc3QgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSAnRVJSX0lOVkFMSURfQVJHX1RZUEUnO1xuZnVuY3Rpb24gQ29kZWRUeXBlRXJyb3IobWVzc2FnZSwgY29kZSwgY2F1c2UpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UsIHsgY2F1c2UgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihlcnIsIHsgY29kZSB9KTtcbiAgICByZXR1cm4gZXJyO1xufVxuZXhwb3J0IGNvbnN0IGFsbG93SW5zZWN1cmVSZXF1ZXN0cyA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGNsb2NrU2tldyA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGNsb2NrVG9sZXJhbmNlID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3QgY3VzdG9tRmV0Y2ggPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBtb2RpZnlBc3NlcnRpb24gPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBqd2VEZWNyeXB0ID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3Qgandrc0NhY2hlID0gU3ltYm9sKCk7XG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5mdW5jdGlvbiBidWYoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoaW5wdXQpO1xufVxubGV0IGVuY29kZUJhc2U2NFVybDtcbmlmIChVaW50OEFycmF5LnByb3RvdHlwZS50b0Jhc2U2NCkge1xuICAgIGVuY29kZUJhc2U2NFVybCA9IChpbnB1dCkgPT4ge1xuICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgaW5wdXQgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnRvQmFzZTY0KHsgYWxwaGFiZXQ6ICdiYXNlNjR1cmwnLCBvbWl0UGFkZGluZzogdHJ1ZSB9KTtcbiAgICB9O1xufVxuZWxzZSB7XG4gICAgY29uc3QgQ0hVTktfU0laRSA9IDB4ODAwMDtcbiAgICBlbmNvZGVCYXNlNjRVcmwgPSAoaW5wdXQpID0+IHtcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0LmJ5dGVMZW5ndGg7IGkgKz0gQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgYXJyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBpbnB1dC5zdWJhcnJheShpLCBpICsgQ0hVTktfU0laRSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnRvYShhcnIuam9pbignJykpLnJlcGxhY2UoLz0vZywgJycpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xuICAgIH07XG59XG5sZXQgZGVjb2RlQmFzZTY0VXJsO1xuaWYgKFVpbnQ4QXJyYXkuZnJvbUJhc2U2NCkge1xuICAgIGRlY29kZUJhc2U2NFVybCA9IChpbnB1dCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUJhc2U2NChpbnB1dCwgeyBhbHBoYWJldDogJ2Jhc2U2NHVybCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignVGhlIGlucHV0IHRvIGJlIGRlY29kZWQgaXMgbm90IGNvcnJlY3RseSBlbmNvZGVkLicsIEVSUl9JTlZBTElEX0FSR19WQUxVRSwgY2F1c2UpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIGRlY29kZUJhc2U2NFVybCA9IChpbnB1dCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5ID0gYXRvYihpbnB1dC5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnkubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXNbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdUaGUgaW5wdXQgdG8gYmUgZGVjb2RlZCBpcyBub3QgY29ycmVjdGx5IGVuY29kZWQuJywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFLCBjYXVzZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gYjY0dShpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVCYXNlNjRVcmwoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0VXJsKGlucHV0KTtcbn1cbmV4cG9ydCBjbGFzcyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvZGU7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB0aGlzLmNvZGUgPSBVTlNVUFBPUlRFRF9PUEVSQVRJT047XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlPy4odGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE9wZXJhdGlvblByb2Nlc3NpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb2RlO1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IG9wdGlvbnM/LmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/Lih0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBPUEUobWVzc2FnZSwgY29kZSwgY2F1c2UpIHtcbiAgICByZXR1cm4gbmV3IE9wZXJhdGlvblByb2Nlc3NpbmdFcnJvcihtZXNzYWdlLCB7IGNvZGUsIGNhdXNlIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlSndrVGh1bWJwcmludChqd2spIHtcbiAgICBsZXQgY29tcG9uZW50cztcbiAgICBzd2l0Y2ggKGp3ay5rdHkpIHtcbiAgICAgICAgY2FzZSAnRUMnOlxuICAgICAgICAgICAgY29tcG9uZW50cyA9IHtcbiAgICAgICAgICAgICAgICBjcnY6IGp3ay5jcnYsXG4gICAgICAgICAgICAgICAga3R5OiBqd2sua3R5LFxuICAgICAgICAgICAgICAgIHg6IGp3ay54LFxuICAgICAgICAgICAgICAgIHk6IGp3ay55LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdPS1AnOlxuICAgICAgICAgICAgY29tcG9uZW50cyA9IHtcbiAgICAgICAgICAgICAgICBjcnY6IGp3ay5jcnYsXG4gICAgICAgICAgICAgICAga3R5OiBqd2sua3R5LFxuICAgICAgICAgICAgICAgIHg6IGp3ay54LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBS1AnOlxuICAgICAgICAgICAgY29tcG9uZW50cyA9IHtcbiAgICAgICAgICAgICAgICBhbGc6IGp3ay5hbGcsXG4gICAgICAgICAgICAgICAga3R5OiBqd2sua3R5LFxuICAgICAgICAgICAgICAgIHB1YjogandrLnB1YixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUlNBJzpcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7XG4gICAgICAgICAgICAgICAgZTogandrLmUsXG4gICAgICAgICAgICAgICAga3R5OiBqd2sua3R5LFxuICAgICAgICAgICAgICAgIG46IGp3ay5uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIEpXSyBrZXkgdHlwZScsIHsgY2F1c2U6IGp3ayB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGI2NHUoYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBidWYoSlNPTi5zdHJpbmdpZnkoY29tcG9uZW50cykpKSk7XG59XG5mdW5jdGlvbiBhc3NlcnRDcnlwdG9LZXkoa2V5LCBpdCkge1xuICAgIGlmICghKGtleSBpbnN0YW5jZW9mIENyeXB0b0tleSkpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoYCR7aXR9IG11c3QgYmUgYSBDcnlwdG9LZXlgLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0UHJpdmF0ZUtleShrZXksIGl0KSB7XG4gICAgYXNzZXJ0Q3J5cHRvS2V5KGtleSwgaXQpO1xuICAgIGlmIChrZXkudHlwZSAhPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKGAke2l0fSBtdXN0IGJlIGEgcHJpdmF0ZSBDcnlwdG9LZXlgLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydFB1YmxpY0tleShrZXksIGl0KSB7XG4gICAgYXNzZXJ0Q3J5cHRvS2V5KGtleSwgaXQpO1xuICAgIGlmIChrZXkudHlwZSAhPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoYCR7aXR9IG11c3QgYmUgYSBwdWJsaWMgQ3J5cHRvS2V5YCwgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVUeXAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eYXBwbGljYXRpb25cXC8vLCAnJyk7XG59XG5mdW5jdGlvbiBpc0pzb25PYmplY3QoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcHJlcGFyZUhlYWRlcnMoaW5wdXQpIHtcbiAgICBpZiAobG9vc2VJbnN0YW5jZU9mKGlucHV0LCBIZWFkZXJzKSkge1xuICAgICAgICBpbnB1dCA9IE9iamVjdC5mcm9tRW50cmllcyhpbnB1dC5lbnRyaWVzKCkpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQgPz8ge30pO1xuICAgIGlmIChVU0VSX0FHRU5UICYmICFoZWFkZXJzLmhhcygndXNlci1hZ2VudCcpKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCd1c2VyLWFnZW50JywgVVNFUl9BR0VOVCk7XG4gICAgfVxuICAgIGlmIChoZWFkZXJzLmhhcygnYXV0aG9yaXphdGlvbicpKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcIm9wdGlvbnMuaGVhZGVyc1wiIG11c3Qgbm90IGluY2x1ZGUgdGhlIFwiYXV0aG9yaXphdGlvblwiIGhlYWRlciBuYW1lJywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBzaWduYWwodXJsLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUodXJsLmhyZWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpKSB7XG4gICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJvcHRpb25zLnNpZ25hbFwiIG11c3QgcmV0dXJuIG9yIGJlIGFuIGluc3RhbmNlIG9mIEFib3J0U2lnbmFsJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VEb3VibGVTbGFzaChwYXRobmFtZSkge1xuICAgIGlmIChwYXRobmFtZS5pbmNsdWRlcygnLy8nKSkge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWUucmVwbGFjZSgnLy8nLCAnLycpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aG5hbWU7XG59XG5mdW5jdGlvbiBwcmVwZW5kV2VsbEtub3duKHVybCwgd2VsbEtub3duLCBhbGxvd1Rlcm1pbmF0aW5nU2xhc2ggPSBmYWxzZSkge1xuICAgIGlmICh1cmwucGF0aG5hbWUgPT09ICcvJykge1xuICAgICAgICB1cmwucGF0aG5hbWUgPSB3ZWxsS25vd247XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cmwucGF0aG5hbWUgPSByZXBsYWNlRG91YmxlU2xhc2goYCR7d2VsbEtub3dufS8ke2FsbG93VGVybWluYXRpbmdTbGFzaCA/IHVybC5wYXRobmFtZSA6IHVybC5wYXRobmFtZS5yZXBsYWNlKC8oXFwvKSQvLCAnJyl9YCk7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59XG5mdW5jdGlvbiBhcHBlbmRXZWxsS25vd24odXJsLCB3ZWxsS25vd24pIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXBsYWNlRG91YmxlU2xhc2goYCR7dXJsLnBhdGhuYW1lfS8ke3dlbGxLbm93bn1gKTtcbiAgICByZXR1cm4gdXJsO1xufVxuYXN5bmMgZnVuY3Rpb24gcGVyZm9ybURpc2NvdmVyeShpbnB1dCwgdXJsTmFtZSwgdHJhbnNmb3JtLCBvcHRpb25zKSB7XG4gICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKGBcIiR7dXJsTmFtZX1cIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTGAsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgY2hlY2tQcm90b2NvbChpbnB1dCwgb3B0aW9ucz8uW2FsbG93SW5zZWN1cmVSZXF1ZXN0c10gIT09IHRydWUpO1xuICAgIGNvbnN0IHVybCA9IHRyYW5zZm9ybShuZXcgVVJMKGlucHV0LmhyZWYpKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgcmV0dXJuIChvcHRpb25zPy5bY3VzdG9tRmV0Y2hdIHx8IGZldGNoKSh1cmwuaHJlZiwge1xuICAgICAgICBib2R5OiB1bmRlZmluZWQsXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzLmVudHJpZXMoKSksXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgICAgc2lnbmFsOiBzaWduYWwodXJsLCBvcHRpb25zPy5zaWduYWwpLFxuICAgIH0pO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRpc2NvdmVyeVJlcXVlc3QoaXNzdWVySWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgIHJldHVybiBwZXJmb3JtRGlzY292ZXJ5KGlzc3VlcklkZW50aWZpZXIsICdpc3N1ZXJJZGVudGlmaWVyJywgKHVybCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKG9wdGlvbnM/LmFsZ29yaXRobSkge1xuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICBjYXNlICdvaWRjJzpcbiAgICAgICAgICAgICAgICBhcHBlbmRXZWxsS25vd24odXJsLCAnLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb24nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29hdXRoMic6XG4gICAgICAgICAgICAgICAgcHJlcGVuZFdlbGxLbm93bih1cmwsICcud2VsbC1rbm93bi9vYXV0aC1hdXRob3JpemF0aW9uLXNlcnZlcicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJvcHRpb25zLmFsZ29yaXRobVwiIG11c3QgYmUgXCJvaWRjXCIgKGRlZmF1bHQpLCBvciBcIm9hdXRoMlwiJywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH0sIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKGlucHV0LCBhbGxvdzAsIGl0LCBjb2RlLCBjYXVzZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNGaW5pdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcihgJHtpdH0gbXVzdCBiZSBhIG51bWJlcmAsIEVSUl9JTlZBTElEX0FSR19UWVBFLCBjYXVzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ID4gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGFsbG93MCkge1xuICAgICAgICAgICAgaWYgKGlucHV0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoYCR7aXR9IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyYCwgRVJSX0lOVkFMSURfQVJHX1ZBTFVFLCBjYXVzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoYCR7aXR9IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJgLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUsIGNhdXNlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKGVyci5tZXNzYWdlLCBjb2RlLCBjYXVzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydFN0cmluZyhpbnB1dCwgaXQsIGNvZGUsIGNhdXNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKGAke2l0fSBtdXN0IGJlIGEgc3RyaW5nYCwgRVJSX0lOVkFMSURfQVJHX1RZUEUsIGNhdXNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcihgJHtpdH0gbXVzdCBub3QgYmUgZW1wdHlgLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUsIGNhdXNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoZXJyLm1lc3NhZ2UsIGNvZGUsIGNhdXNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NEaXNjb3ZlcnlSZXNwb25zZShleHBlY3RlZElzc3VlcklkZW50aWZpZXIsIHJlc3BvbnNlKSB7XG4gICAgY29uc3QgZXhwZWN0ZWQgPSBleHBlY3RlZElzc3VlcklkZW50aWZpZXI7XG4gICAgaWYgKCEoZXhwZWN0ZWQgaW5zdGFuY2VvZiBVUkwpICYmIGV4cGVjdGVkICE9PSBfbm9kaXNjb3ZlcnljaGVjaykge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJleHBlY3RlZElzc3VlcklkZW50aWZpZXJcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTCcsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICB0aHJvdyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIEF1dGhvcml6YXRpb24gU2VydmVyIE1ldGFkYXRhIHJlc3BvbnNlICh1bmV4cGVjdGVkIEhUVFAgc3RhdHVzIGNvZGUpJywgUkVTUE9OU0VfSVNfTk9UX0NPTkZPUk0sIHJlc3BvbnNlKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGdldFJlc3BvbnNlSnNvbkJvZHkocmVzcG9uc2UpO1xuICAgIGFzc2VydFN0cmluZyhqc29uLmlzc3VlciwgJ1wicmVzcG9uc2VcIiBib2R5IFwiaXNzdWVyXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7IGJvZHk6IGpzb24gfSk7XG4gICAgaWYgKGV4cGVjdGVkICE9PSBfbm9kaXNjb3ZlcnljaGVjayAmJiBuZXcgVVJMKGpzb24uaXNzdWVyKS5ocmVmICE9PSBleHBlY3RlZC5ocmVmKSB7XG4gICAgICAgIHRocm93IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJpc3N1ZXJcIiBwcm9wZXJ0eSBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgdmFsdWUnLCBKU09OX0FUVFJJQlVURV9DT01QQVJJU09OLCB7IGV4cGVjdGVkOiBleHBlY3RlZC5ocmVmLCBib2R5OiBqc29uLCBhdHRyaWJ1dGU6ICdpc3N1ZXInIH0pO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmZ1bmN0aW9uIGFzc2VydEFwcGxpY2F0aW9uSnNvbihyZXNwb25zZSkge1xuICAgIGFzc2VydENvbnRlbnRUeXBlKHJlc3BvbnNlLCAnYXBwbGljYXRpb24vanNvbicpO1xufVxuZnVuY3Rpb24gbm90SnNvbihyZXNwb25zZSwgLi4udHlwZXMpIHtcbiAgICBsZXQgbXNnID0gJ1wicmVzcG9uc2VcIiBjb250ZW50LXR5cGUgbXVzdCBiZSAnO1xuICAgIGlmICh0eXBlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIGNvbnN0IGxhc3QgPSB0eXBlcy5wb3AoKTtcbiAgICAgICAgbXNnICs9IGAke3R5cGVzLmpvaW4oJywgJyl9LCBvciAke2xhc3R9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIG1zZyArPSBgJHt0eXBlc1swXX0gb3IgJHt0eXBlc1sxXX1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbXNnICs9IHR5cGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gT1BFKG1zZywgUkVTUE9OU0VfSVNfTk9UX0pTT04sIHJlc3BvbnNlKTtcbn1cbmZ1bmN0aW9uIGFzc2VydENvbnRlbnRUeXBlcyhyZXNwb25zZSwgLi4udHlwZXMpIHtcbiAgICBpZiAoIXR5cGVzLmluY2x1ZGVzKGdldENvbnRlbnRUeXBlKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgdGhyb3cgbm90SnNvbihyZXNwb25zZSwgLi4udHlwZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydENvbnRlbnRUeXBlKHJlc3BvbnNlLCBjb250ZW50VHlwZSkge1xuICAgIGlmIChnZXRDb250ZW50VHlwZShyZXNwb25zZSkgIT09IGNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHRocm93IG5vdEpzb24ocmVzcG9uc2UsIGNvbnRlbnRUeXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiByYW5kb21CeXRlcygpIHtcbiAgICByZXR1cm4gYjY0dShjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDMyKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tQ29kZVZlcmlmaWVyKCkge1xuICAgIHJldHVybiByYW5kb21CeXRlcygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tU3RhdGUoKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21Ob25jZSgpIHtcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMoKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVQS0NFQ29kZUNoYWxsZW5nZShjb2RlVmVyaWZpZXIpIHtcbiAgICBhc3NlcnRTdHJpbmcoY29kZVZlcmlmaWVyLCAnY29kZVZlcmlmaWVyJyk7XG4gICAgcmV0dXJuIGI2NHUoYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBidWYoY29kZVZlcmlmaWVyKSkpO1xufVxuZnVuY3Rpb24gZ2V0S2V5QW5kS2lkKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ3J5cHRvS2V5KSB7XG4gICAgICAgIHJldHVybiB7IGtleTogaW5wdXQgfTtcbiAgICB9XG4gICAgaWYgKCEoaW5wdXQ/LmtleSBpbnN0YW5jZW9mIENyeXB0b0tleSkpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAoaW5wdXQua2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXNzZXJ0U3RyaW5nKGlucHV0LmtpZCwgJ1wia2lkXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBpbnB1dC5rZXksXG4gICAgICAgIGtpZDogaW5wdXQua2lkLFxuICAgIH07XG59XG5mdW5jdGlvbiBwc0FsZyhrZXkpIHtcbiAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0uaGFzaC5uYW1lKSB7XG4gICAgICAgIGNhc2UgJ1NIQS0yNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdQUzI1Nic7XG4gICAgICAgIGNhc2UgJ1NIQS0zODQnOlxuICAgICAgICAgICAgcmV0dXJuICdQUzM4NCc7XG4gICAgICAgIGNhc2UgJ1NIQS01MTInOlxuICAgICAgICAgICAgcmV0dXJuICdQUzUxMic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgUnNhSGFzaGVkS2V5QWxnb3JpdGhtIGhhc2ggbmFtZScsIHtcbiAgICAgICAgICAgICAgICBjYXVzZToga2V5LFxuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcnNBbGcoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLmhhc2gubmFtZSkge1xuICAgICAgICBjYXNlICdTSEEtMjU2JzpcbiAgICAgICAgICAgIHJldHVybiAnUlMyNTYnO1xuICAgICAgICBjYXNlICdTSEEtMzg0JzpcbiAgICAgICAgICAgIHJldHVybiAnUlMzODQnO1xuICAgICAgICBjYXNlICdTSEEtNTEyJzpcbiAgICAgICAgICAgIHJldHVybiAnUlM1MTInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIFJzYUhhc2hlZEtleUFsZ29yaXRobSBoYXNoIG5hbWUnLCB7XG4gICAgICAgICAgICAgICAgY2F1c2U6IGtleSxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzQWxnKGtleSkge1xuICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKSB7XG4gICAgICAgIGNhc2UgJ1AtMjU2JzpcbiAgICAgICAgICAgIHJldHVybiAnRVMyNTYnO1xuICAgICAgICBjYXNlICdQLTM4NCc6XG4gICAgICAgICAgICByZXR1cm4gJ0VTMzg0JztcbiAgICAgICAgY2FzZSAnUC01MjEnOlxuICAgICAgICAgICAgcmV0dXJuICdFUzUxMic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgRWNLZXlBbGdvcml0aG0gbmFtZWRDdXJ2ZScsIHsgY2F1c2U6IGtleSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXlUb0p3cyhrZXkpIHtcbiAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0ubmFtZSkge1xuICAgICAgICBjYXNlICdSU0EtUFNTJzpcbiAgICAgICAgICAgIHJldHVybiBwc0FsZyhrZXkpO1xuICAgICAgICBjYXNlICdSU0FTU0EtUEtDUzEtdjFfNSc6XG4gICAgICAgICAgICByZXR1cm4gcnNBbGcoa2V5KTtcbiAgICAgICAgY2FzZSAnRUNEU0EnOlxuICAgICAgICAgICAgcmV0dXJuIGVzQWxnKGtleSk7XG4gICAgICAgIGNhc2UgJ0VkMjU1MTknOlxuICAgICAgICBjYXNlICdNTC1EU0EtNDQnOlxuICAgICAgICBjYXNlICdNTC1EU0EtNjUnOlxuICAgICAgICBjYXNlICdNTC1EU0EtODcnOlxuICAgICAgICAgICAgcmV0dXJuIGtleS5hbGdvcml0aG0ubmFtZTtcbiAgICAgICAgY2FzZSAnRWREU0EnOlxuICAgICAgICAgICAgcmV0dXJuICdFZDI1NTE5JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBDcnlwdG9LZXkgYWxnb3JpdGhtIG5hbWUnLCB7IGNhdXNlOiBrZXkgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q2xvY2tTa2V3KGNsaWVudCkge1xuICAgIGNvbnN0IHNrZXcgPSBjbGllbnQ/LltjbG9ja1NrZXddO1xuICAgIHJldHVybiB0eXBlb2Ygc2tldyA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKHNrZXcpID8gc2tldyA6IDA7XG59XG5mdW5jdGlvbiBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpIHtcbiAgICBjb25zdCB0b2xlcmFuY2UgPSBjbGllbnQ/LltjbG9ja1RvbGVyYW5jZV07XG4gICAgcmV0dXJuIHR5cGVvZiB0b2xlcmFuY2UgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZSh0b2xlcmFuY2UpICYmIE1hdGguc2lnbih0b2xlcmFuY2UpICE9PSAtMVxuICAgICAgICA/IHRvbGVyYW5jZVxuICAgICAgICA6IDMwO1xufVxuZnVuY3Rpb24gZXBvY2hUaW1lKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFzKGFzKSB7XG4gICAgaWYgKHR5cGVvZiBhcyAhPT0gJ29iamVjdCcgfHwgYXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wiYXNcIiBtdXN0IGJlIGFuIG9iamVjdCcsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgYXNzZXJ0U3RyaW5nKGFzLmlzc3VlciwgJ1wiYXMuaXNzdWVyXCInKTtcbn1cbmZ1bmN0aW9uIGFzc2VydENsaWVudChjbGllbnQpIHtcbiAgICBpZiAodHlwZW9mIGNsaWVudCAhPT0gJ29iamVjdCcgfHwgY2xpZW50ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcImNsaWVudFwiIG11c3QgYmUgYW4gb2JqZWN0JywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBhc3NlcnRTdHJpbmcoY2xpZW50LmNsaWVudF9pZCwgJ1wiY2xpZW50LmNsaWVudF9pZFwiJyk7XG59XG5mdW5jdGlvbiBmb3JtVXJsRW5jb2RlKHRva2VuKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh0b2tlbikucmVwbGFjZSgvKD86Wy1fLiF+KicoKV18JTIwKS9nLCAoc3Vic3RyaW5nKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoc3Vic3RyaW5nKSB7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIGNhc2UgJ18nOlxuICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgIGNhc2UgJ34nOlxuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCUke3N1YnN0cmluZy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgICAgICBjYXNlICclMjAnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnKyc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gQ2xpZW50U2VjcmV0UG9zdChjbGllbnRTZWNyZXQpIHtcbiAgICBhc3NlcnRTdHJpbmcoY2xpZW50U2VjcmV0LCAnXCJjbGllbnRTZWNyZXRcIicpO1xuICAgIHJldHVybiAoX2FzLCBjbGllbnQsIGJvZHksIF9oZWFkZXJzKSA9PiB7XG4gICAgICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9zZWNyZXQnLCBjbGllbnRTZWNyZXQpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gQ2xpZW50U2VjcmV0QmFzaWMoY2xpZW50U2VjcmV0KSB7XG4gICAgYXNzZXJ0U3RyaW5nKGNsaWVudFNlY3JldCwgJ1wiY2xpZW50U2VjcmV0XCInKTtcbiAgICByZXR1cm4gKF9hcywgY2xpZW50LCBfYm9keSwgaGVhZGVycykgPT4ge1xuICAgICAgICBjb25zdCB1c2VybmFtZSA9IGZvcm1VcmxFbmNvZGUoY2xpZW50LmNsaWVudF9pZCk7XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkID0gZm9ybVVybEVuY29kZShjbGllbnRTZWNyZXQpO1xuICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IGJ0b2EoYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YCk7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhdXRob3JpemF0aW9uJywgYEJhc2ljICR7Y3JlZGVudGlhbHN9YCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNsaWVudEFzc2VydGlvblBheWxvYWQoYXMsIGNsaWVudCkge1xuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgZ2V0Q2xvY2tTa2V3KGNsaWVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAganRpOiByYW5kb21CeXRlcygpLFxuICAgICAgICBhdWQ6IGFzLmlzc3VlcixcbiAgICAgICAgZXhwOiBub3cgKyA2MCxcbiAgICAgICAgaWF0OiBub3csXG4gICAgICAgIG5iZjogbm93LFxuICAgICAgICBpc3M6IGNsaWVudC5jbGllbnRfaWQsXG4gICAgICAgIHN1YjogY2xpZW50LmNsaWVudF9pZCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIFByaXZhdGVLZXlKd3QoY2xpZW50UHJpdmF0ZUtleSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsga2V5LCBraWQgfSA9IGdldEtleUFuZEtpZChjbGllbnRQcml2YXRlS2V5KTtcbiAgICBhc3NlcnRQcml2YXRlS2V5KGtleSwgJ1wiY2xpZW50UHJpdmF0ZUtleS5rZXlcIicpO1xuICAgIHJldHVybiBhc3luYyAoYXMsIGNsaWVudCwgYm9keSwgX2hlYWRlcnMpID0+IHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0geyBhbGc6IGtleVRvSndzKGtleSksIGtpZCB9O1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gY2xpZW50QXNzZXJ0aW9uUGF5bG9hZChhcywgY2xpZW50KTtcbiAgICAgICAgb3B0aW9ucz8uW21vZGlmeUFzc2VydGlvbl0/LihoZWFkZXIsIHBheWxvYWQpO1xuICAgICAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgICAgIGJvZHkuc2V0KCdjbGllbnRfYXNzZXJ0aW9uX3R5cGUnLCAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmNsaWVudC1hc3NlcnRpb24tdHlwZTpqd3QtYmVhcmVyJyk7XG4gICAgICAgIGJvZHkuc2V0KCdjbGllbnRfYXNzZXJ0aW9uJywgYXdhaXQgc2lnbkp3dChoZWFkZXIsIHBheWxvYWQsIGtleSkpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gQ2xpZW50U2VjcmV0Snd0KGNsaWVudFNlY3JldCwgb3B0aW9ucykge1xuICAgIGFzc2VydFN0cmluZyhjbGllbnRTZWNyZXQsICdcImNsaWVudFNlY3JldFwiJyk7XG4gICAgY29uc3QgbW9kaWZ5ID0gb3B0aW9ucz8uW21vZGlmeUFzc2VydGlvbl07XG4gICAgbGV0IGtleTtcbiAgICByZXR1cm4gYXN5bmMgKGFzLCBjbGllbnQsIGJvZHksIF9oZWFkZXJzKSA9PiB7XG4gICAgICAgIGtleSB8fD0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGJ1ZihjbGllbnRTZWNyZXQpLCB7IGhhc2g6ICdTSEEtMjU2JywgbmFtZTogJ0hNQUMnIH0sIGZhbHNlLCBbJ3NpZ24nXSk7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHsgYWxnOiAnSFMyNTYnIH07XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBjbGllbnRBc3NlcnRpb25QYXlsb2FkKGFzLCBjbGllbnQpO1xuICAgICAgICBtb2RpZnk/LihoZWFkZXIsIHBheWxvYWQpO1xuICAgICAgICBjb25zdCBkYXRhID0gYCR7YjY0dShidWYoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSkpfS4ke2I2NHUoYnVmKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKSl9YDtcbiAgICAgICAgY29uc3QgaG1hYyA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuc2lnbihrZXkuYWxnb3JpdGhtLCBrZXksIGJ1ZihkYXRhKSk7XG4gICAgICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9hc3NlcnRpb25fdHlwZScsICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Y2xpZW50LWFzc2VydGlvbi10eXBlOmp3dC1iZWFyZXInKTtcbiAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9hc3NlcnRpb24nLCBgJHtkYXRhfS4ke2I2NHUobmV3IFVpbnQ4QXJyYXkoaG1hYykpfWApO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gTm9uZSgpIHtcbiAgICByZXR1cm4gKF9hcywgY2xpZW50LCBib2R5LCBfaGVhZGVycykgPT4ge1xuICAgICAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBUbHNDbGllbnRBdXRoKCkge1xuICAgIHJldHVybiBOb25lKCk7XG59XG5hc3luYyBmdW5jdGlvbiBzaWduSnd0KGhlYWRlciwgcGF5bG9hZCwga2V5KSB7XG4gICAgaWYgKCFrZXkudXNhZ2VzLmluY2x1ZGVzKCdzaWduJykpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ0NyeXB0b0tleSBpbnN0YW5jZXMgdXNlZCBmb3Igc2lnbmluZyBhc3NlcnRpb25zIG11c3QgaW5jbHVkZSBcInNpZ25cIiBpbiB0aGVpciBcInVzYWdlc1wiJywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXQgPSBgJHtiNjR1KGJ1ZihKU09OLnN0cmluZ2lmeShoZWFkZXIpKSl9LiR7YjY0dShidWYoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpKX1gO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGI2NHUoYXdhaXQgY3J5cHRvLnN1YnRsZS5zaWduKGtleVRvU3VidGxlKGtleSksIGtleSwgYnVmKGlucHV0KSkpO1xuICAgIHJldHVybiBgJHtpbnB1dH0uJHtzaWduYXR1cmV9YDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc3N1ZVJlcXVlc3RPYmplY3QoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgcHJpdmF0ZUtleSwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBjb25zdCB7IGtleSwga2lkIH0gPSBnZXRLZXlBbmRLaWQocHJpdmF0ZUtleSk7XG4gICAgYXNzZXJ0UHJpdmF0ZUtleShrZXksICdcInByaXZhdGVLZXkua2V5XCInKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBnZXRDbG9ja1NrZXcoY2xpZW50KTtcbiAgICBjb25zdCBjbGFpbXMgPSB7XG4gICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhwYXJhbWV0ZXJzLmVudHJpZXMoKSksXG4gICAgICAgIGp0aTogcmFuZG9tQnl0ZXMoKSxcbiAgICAgICAgYXVkOiBhcy5pc3N1ZXIsXG4gICAgICAgIGV4cDogbm93ICsgNjAsXG4gICAgICAgIGlhdDogbm93LFxuICAgICAgICBuYmY6IG5vdyxcbiAgICAgICAgaXNzOiBjbGllbnQuY2xpZW50X2lkLFxuICAgIH07XG4gICAgbGV0IHJlc291cmNlO1xuICAgIGlmIChwYXJhbWV0ZXJzLmhhcygncmVzb3VyY2UnKSAmJlxuICAgICAgICAocmVzb3VyY2UgPSBwYXJhbWV0ZXJzLmdldEFsbCgncmVzb3VyY2UnKSkgJiZcbiAgICAgICAgcmVzb3VyY2UubGVuZ3RoID4gMSkge1xuICAgICAgICBjbGFpbXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICB9XG4gICAge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJhbWV0ZXJzLmdldCgnbWF4X2FnZScpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsYWltcy5tYXhfYWdlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICAgIGFzc2VydE51bWJlcihjbGFpbXMubWF4X2FnZSwgdHJ1ZSwgJ1wibWF4X2FnZVwiIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1ldGVycy5nZXQoJ2NsYWltcycpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2xhaW1zLmNsYWltcyA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgT1BFKCdmYWlsZWQgdG8gcGFyc2UgdGhlIFwiY2xhaW1zXCIgcGFyYW1ldGVyIGFzIEpTT04nLCBQQVJTRV9FUlJPUiwgY2F1c2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0pzb25PYmplY3QoY2xhaW1zLmNsYWltcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJjbGFpbXNcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhIEpTT04gd2l0aCBhIHRvcCBsZXZlbCBvYmplY3QnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1ldGVycy5nZXQoJ2F1dGhvcml6YXRpb25fZGV0YWlscycpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2xhaW1zLmF1dGhvcml6YXRpb25fZGV0YWlscyA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgT1BFKCdmYWlsZWQgdG8gcGFyc2UgdGhlIFwiYXV0aG9yaXphdGlvbl9kZXRhaWxzXCIgcGFyYW1ldGVyIGFzIEpTT04nLCBQQVJTRV9FUlJPUiwgY2F1c2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNsYWltcy5hdXRob3JpemF0aW9uX2RldGFpbHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wiYXV0aG9yaXphdGlvbl9kZXRhaWxzXCIgcGFyYW1ldGVyIG11c3QgYmUgYSBKU09OIHdpdGggYSB0b3AgbGV2ZWwgYXJyYXknLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IHtcbiAgICAgICAgYWxnOiBrZXlUb0p3cyhrZXkpLFxuICAgICAgICB0eXA6ICdvYXV0aC1hdXRoei1yZXErand0JyxcbiAgICAgICAga2lkLFxuICAgIH07XG4gICAgb3B0aW9ucz8uW21vZGlmeUFzc2VydGlvbl0/LihoZWFkZXIsIGNsYWltcyk7XG4gICAgcmV0dXJuIHNpZ25Kd3QoaGVhZGVyLCBjbGFpbXMsIGtleSk7XG59XG5sZXQgandrQ2FjaGU7XG5hc3luYyBmdW5jdGlvbiBnZXRTZXRQdWJsaWNKd2tDYWNoZShrZXksIGFsZykge1xuICAgIGNvbnN0IHsga3R5LCBlLCBuLCB4LCB5LCBjcnYsIHB1YiB9ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ2p3aycsIGtleSk7XG4gICAgY29uc3QgandrID0geyBrdHksIGUsIG4sIHgsIHksIGNydiwgcHViIH07XG4gICAgaWYgKGt0eSA9PT0gJ0FLUCcpXG4gICAgICAgIGp3ay5hbGcgPSBhbGc7XG4gICAgandrQ2FjaGUuc2V0KGtleSwgandrKTtcbiAgICByZXR1cm4gandrO1xufVxuYXN5bmMgZnVuY3Rpb24gcHVibGljSndrKGtleSwgYWxnKSB7XG4gICAgandrQ2FjaGUgfHw9IG5ldyBXZWFrTWFwKCk7XG4gICAgcmV0dXJuIGp3a0NhY2hlLmdldChrZXkpIHx8IGdldFNldFB1YmxpY0p3a0NhY2hlKGtleSwgYWxnKTtcbn1cbmNvbnN0IFVSTFBhcnNlID0gVVJMLnBhcnNlXG4gICAgP1xuICAgICAgICAodXJsLCBiYXNlKSA9PiBVUkwucGFyc2UodXJsLCBiYXNlKVxuICAgIDogKHVybCwgYmFzZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwodXJsLCBiYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tQcm90b2NvbCh1cmwsIGVuZm9yY2VIdHRwcykge1xuICAgIGlmIChlbmZvcmNlSHR0cHMgJiYgdXJsLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgICB0aHJvdyBPUEUoJ29ubHkgcmVxdWVzdHMgdG8gSFRUUFMgYXJlIGFsbG93ZWQnLCBIVFRQX1JFUVVFU1RfRk9SQklEREVOLCB1cmwpO1xuICAgIH1cbiAgICBpZiAodXJsLnByb3RvY29sICE9PSAnaHR0cHM6JyAmJiB1cmwucHJvdG9jb2wgIT09ICdodHRwOicpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdvbmx5IEhUVFAgYW5kIEhUVFBTIHJlcXVlc3RzIGFyZSBhbGxvd2VkJywgUkVRVUVTVF9QUk9UT0NPTF9GT1JCSURERU4sIHVybCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVFbmRwb2ludCh2YWx1ZSwgZW5kcG9pbnQsIHVzZU10bHNBbGlhcywgZW5mb3JjZUh0dHBzKSB7XG4gICAgbGV0IHVybDtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhKHVybCA9IFVSTFBhcnNlKHZhbHVlKSkpIHtcbiAgICAgICAgdGhyb3cgT1BFKGBhdXRob3JpemF0aW9uIHNlcnZlciBtZXRhZGF0YSBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgJHt1c2VNdGxzQWxpYXMgPyBgXCJhcy5tdGxzX2VuZHBvaW50X2FsaWFzZXMuJHtlbmRwb2ludH1cImAgOiBgXCJhcy4ke2VuZHBvaW50fVwiYH1gLCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gTUlTU0lOR19TRVJWRVJfTUVUQURBVEEgOiBJTlZBTElEX1NFUlZFUl9NRVRBREFUQSwgeyBhdHRyaWJ1dGU6IHVzZU10bHNBbGlhcyA/IGBtdGxzX2VuZHBvaW50X2FsaWFzZXMuJHtlbmRwb2ludH1gIDogZW5kcG9pbnQgfSk7XG4gICAgfVxuICAgIGNoZWNrUHJvdG9jb2wodXJsLCBlbmZvcmNlSHR0cHMpO1xuICAgIHJldHVybiB1cmw7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUVuZHBvaW50KGFzLCBlbmRwb2ludCwgdXNlTXRsc0FsaWFzLCBlbmZvcmNlSHR0cHMpIHtcbiAgICBpZiAodXNlTXRsc0FsaWFzICYmIGFzLm10bHNfZW5kcG9pbnRfYWxpYXNlcyAmJiBlbmRwb2ludCBpbiBhcy5tdGxzX2VuZHBvaW50X2FsaWFzZXMpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRW5kcG9pbnQoYXMubXRsc19lbmRwb2ludF9hbGlhc2VzW2VuZHBvaW50XSwgZW5kcG9pbnQsIHVzZU10bHNBbGlhcywgZW5mb3JjZUh0dHBzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlRW5kcG9pbnQoYXNbZW5kcG9pbnRdLCBlbmRwb2ludCwgdXNlTXRsc0FsaWFzLCBlbmZvcmNlSHR0cHMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHB1c2hlZEF1dGhvcml6YXRpb25SZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGNvbnN0IHVybCA9IHJlc29sdmVFbmRwb2ludChhcywgJ3B1c2hlZF9hdXRob3JpemF0aW9uX3JlcXVlc3RfZW5kcG9pbnQnLCBjbGllbnQudXNlX210bHNfZW5kcG9pbnRfYWxpYXNlcywgb3B0aW9ucz8uW2FsbG93SW5zZWN1cmVSZXF1ZXN0c10gIT09IHRydWUpO1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgaWYgKG9wdGlvbnM/LkRQb1AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnREUG9QKG9wdGlvbnMuRFBvUCk7XG4gICAgICAgIGF3YWl0IG9wdGlvbnMuRFBvUC5hZGRQcm9vZih1cmwsIGhlYWRlcnMsICdQT1NUJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG4gICAgb3B0aW9ucz8uRFBvUD8uY2FjaGVOb25jZShyZXNwb25zZSwgdXJsKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5jbGFzcyBEUG9QSGFuZGxlciB7XG4gICAgI2hlYWRlcjtcbiAgICAjcHJpdmF0ZUtleTtcbiAgICAjcHVibGljS2V5O1xuICAgICNjbG9ja1NrZXc7XG4gICAgI21vZGlmeUFzc2VydGlvbjtcbiAgICAjbWFwO1xuICAgICNqa3Q7XG4gICAgY29uc3RydWN0b3IoY2xpZW50LCBrZXlQYWlyLCBvcHRpb25zKSB7XG4gICAgICAgIGFzc2VydFByaXZhdGVLZXkoa2V5UGFpcj8ucHJpdmF0ZUtleSwgJ1wiRFBvUC5wcml2YXRlS2V5XCInKTtcbiAgICAgICAgYXNzZXJ0UHVibGljS2V5KGtleVBhaXI/LnB1YmxpY0tleSwgJ1wiRFBvUC5wdWJsaWNLZXlcIicpO1xuICAgICAgICBpZiAoIWtleVBhaXIucHVibGljS2V5LmV4dHJhY3RhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJEUG9QLnB1YmxpY0tleS5leHRyYWN0YWJsZVwiIG11c3QgYmUgdHJ1ZScsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbW9kaWZ5QXNzZXJ0aW9uID0gb3B0aW9ucz8uW21vZGlmeUFzc2VydGlvbl07XG4gICAgICAgIHRoaXMuI2Nsb2NrU2tldyA9IGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgICAgICB0aGlzLiNwcml2YXRlS2V5ID0ga2V5UGFpci5wcml2YXRlS2V5O1xuICAgICAgICB0aGlzLiNwdWJsaWNLZXkgPSBrZXlQYWlyLnB1YmxpY0tleTtcbiAgICAgICAgYnJhbmRlZC5hZGQodGhpcyk7XG4gICAgfVxuICAgICNnZXQoa2V5KSB7XG4gICAgICAgIHRoaXMuI21hcCB8fD0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuI21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuI21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgI3NldChrZXksIHZhbCkge1xuICAgICAgICB0aGlzLiNtYXAgfHw9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICBpZiAodGhpcy4jbWFwLnNpemUgPT09IDEwMCkge1xuICAgICAgICAgICAgdGhpcy4jbWFwLmRlbGV0ZSh0aGlzLiNtYXAua2V5cygpLm5leHQoKS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWFwLnNldChrZXksIHZhbCk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGN1bGF0ZVRodW1icHJpbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy4jamt0KSB7XG4gICAgICAgICAgICBjb25zdCBqd2sgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgnandrJywgdGhpcy4jcHVibGljS2V5KTtcbiAgICAgICAgICAgIHRoaXMuI2prdCB8fD0gYXdhaXQgY2FsY3VsYXRlSndrVGh1bWJwcmludChqd2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNqa3Q7XG4gICAgfVxuICAgIGFzeW5jIGFkZFByb29mKHVybCwgaGVhZGVycywgaHRtLCBhY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zdCBhbGcgPSBrZXlUb0p3cyh0aGlzLiNwcml2YXRlS2V5KTtcbiAgICAgICAgdGhpcy4jaGVhZGVyIHx8PSB7XG4gICAgICAgICAgICBhbGcsXG4gICAgICAgICAgICB0eXA6ICdkcG9wK2p3dCcsXG4gICAgICAgICAgICBqd2s6IGF3YWl0IHB1YmxpY0p3ayh0aGlzLiNwdWJsaWNLZXksIGFsZyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5vbmNlID0gdGhpcy4jZ2V0KHVybC5vcmlnaW4pO1xuICAgICAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIHRoaXMuI2Nsb2NrU2tldztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGlhdDogbm93LFxuICAgICAgICAgICAganRpOiByYW5kb21CeXRlcygpLFxuICAgICAgICAgICAgaHRtLFxuICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICBodHU6IGAke3VybC5vcmlnaW59JHt1cmwucGF0aG5hbWV9YCxcbiAgICAgICAgICAgIGF0aDogYWNjZXNzVG9rZW5cbiAgICAgICAgICAgICAgICA/IGI2NHUoYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBidWYoYWNjZXNzVG9rZW4pKSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jbW9kaWZ5QXNzZXJ0aW9uPy4odGhpcy4jaGVhZGVyLCBwYXlsb2FkKTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2Rwb3AnLCBhd2FpdCBzaWduSnd0KHRoaXMuI2hlYWRlciwgcGF5bG9hZCwgdGhpcy4jcHJpdmF0ZUtleSkpO1xuICAgIH1cbiAgICBjYWNoZU5vbmNlKHJlc3BvbnNlLCB1cmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2Rwb3Atbm9uY2UnKTtcbiAgICAgICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI3NldCh1cmwub3JpZ2luLCBub25jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggeyB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRFBvUE5vbmNlRXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFdXV0F1dGhlbnRpY2F0ZUNoYWxsZW5nZUVycm9yKSB7XG4gICAgICAgIGNvbnN0IHsgMDogY2hhbGxlbmdlLCBsZW5ndGggfSA9IGVyci5jYXVzZTtcbiAgICAgICAgcmV0dXJuIChsZW5ndGggPT09IDEgJiYgY2hhbGxlbmdlLnNjaGVtZSA9PT0gJ2Rwb3AnICYmIGNoYWxsZW5nZS5wYXJhbWV0ZXJzLmVycm9yID09PSAndXNlX2Rwb3Bfbm9uY2UnKTtcbiAgICB9XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFJlc3BvbnNlQm9keUVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnIuZXJyb3IgPT09ICd1c2VfZHBvcF9ub25jZSc7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBEUG9QKGNsaWVudCwga2V5UGFpciwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRFBvUEhhbmRsZXIoY2xpZW50LCBrZXlQYWlyLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBjbGFzcyBSZXNwb25zZUJvZHlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjYXVzZTtcbiAgICBjb2RlO1xuICAgIGVycm9yO1xuICAgIHN0YXR1cztcbiAgICBlcnJvcl9kZXNjcmlwdGlvbjtcbiAgICByZXNwb25zZTtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHRoaXMuY29kZSA9IFJFU1BPTlNFX0JPRFlfRVJST1I7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBvcHRpb25zLmNhdXNlO1xuICAgICAgICB0aGlzLmVycm9yID0gb3B0aW9ucy5jYXVzZS5lcnJvcjtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgdGhpcy5lcnJvcl9kZXNjcmlwdGlvbiA9IG9wdGlvbnMuY2F1c2UuZXJyb3JfZGVzY3JpcHRpb247XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVzcG9uc2UnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogb3B0aW9ucy5yZXNwb25zZSB9KTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/Lih0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXV0aG9yaXphdGlvblJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY2F1c2U7XG4gICAgY29kZTtcbiAgICBlcnJvcjtcbiAgICBlcnJvcl9kZXNjcmlwdGlvbjtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHRoaXMuY29kZSA9IEFVVEhPUklaQVRJT05fUkVTUE9OU0VfRVJST1I7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBvcHRpb25zLmNhdXNlO1xuICAgICAgICB0aGlzLmVycm9yID0gb3B0aW9ucy5jYXVzZS5nZXQoJ2Vycm9yJyk7XG4gICAgICAgIHRoaXMuZXJyb3JfZGVzY3JpcHRpb24gPSBvcHRpb25zLmNhdXNlLmdldCgnZXJyb3JfZGVzY3JpcHRpb24nKSA/PyB1bmRlZmluZWQ7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlPy4odGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdXV0F1dGhlbnRpY2F0ZUNoYWxsZW5nZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNhdXNlO1xuICAgIGNvZGU7XG4gICAgcmVzcG9uc2U7XG4gICAgc3RhdHVzO1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5jb2RlID0gV1dXX0FVVEhFTlRJQ0FURV9DSEFMTEVOR0U7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBvcHRpb25zLmNhdXNlO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMucmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZXNwb25zZScsIHsgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlPy4odGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxufVxuY29uc3QgdG9rZW5NYXRjaCA9IFwiW2EtekEtWjAtOSEjJCUmXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcLlxcXFxeX2BcXFxcfH5dK1wiO1xuY29uc3QgdG9rZW42OE1hdGNoID0gJ1thLXpBLVowLTlcXFxcLVxcXFwuX1xcXFx+XFxcXCtcXFxcL10rWz1dezAsMn0nO1xuY29uc3QgcXVvdGVkTWF0Y2ggPSAnXCIoKD86W15cIlxcXFxcXFxcXXxcXFxcXFxcXC4pKilcIic7XG5jb25zdCBxdW90ZWRQYXJhbU1hdGNoZXIgPSAnKCcgKyB0b2tlbk1hdGNoICsgJylcXFxccyo9XFxcXHMqJyArIHF1b3RlZE1hdGNoO1xuY29uc3QgcGFyYW1NYXRjaGVyID0gJygnICsgdG9rZW5NYXRjaCArICcpXFxcXHMqPVxcXFxzKignICsgdG9rZW5NYXRjaCArICcpJztcbmNvbnN0IHNjaGVtZVJFID0gbmV3IFJlZ0V4cCgnXlssXFxcXHNdKignICsgdG9rZW5NYXRjaCArICcpXFxcXHMoLiopJyk7XG5jb25zdCBxdW90ZWRQYXJhbVJFID0gbmV3IFJlZ0V4cCgnXlssXFxcXHNdKicgKyBxdW90ZWRQYXJhbU1hdGNoZXIgKyAnWyxcXFxcc10qKC4qKScpO1xuY29uc3QgdW5xdW90ZWRQYXJhbVJFID0gbmV3IFJlZ0V4cCgnXlssXFxcXHNdKicgKyBwYXJhbU1hdGNoZXIgKyAnWyxcXFxcc10qKC4qKScpO1xuY29uc3QgdG9rZW42OFBhcmFtUkUgPSBuZXcgUmVnRXhwKCdeKCcgKyB0b2tlbjY4TWF0Y2ggKyAnKSg/OiR8WyxcXFxcc10pKC4qKScpO1xuZnVuY3Rpb24gcGFyc2VXd3dBdXRoZW50aWNhdGVDaGFsbGVuZ2VzKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd3d3ctYXV0aGVudGljYXRlJyk7XG4gICAgaWYgKGhlYWRlciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjaGFsbGVuZ2VzID0gW107XG4gICAgbGV0IHJlc3QgPSBoZWFkZXI7XG4gICAgd2hpbGUgKHJlc3QpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gcmVzdC5tYXRjaChzY2hlbWVSRSk7XG4gICAgICAgIGNvbnN0IHNjaGVtZSA9IG1hdGNoPy5bJzEnXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXN0ID0gbWF0Y2g/LlsnMiddO1xuICAgICAgICBpZiAoIXNjaGVtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0ge307XG4gICAgICAgIGxldCB0b2tlbjY4O1xuICAgICAgICB3aGlsZSAocmVzdCkge1xuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgIGlmICgobWF0Y2ggPSByZXN0Lm1hdGNoKHF1b3RlZFBhcmFtUkUpKSkge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBbLCBrZXksIHZhbHVlLCByZXN0XSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcygnXFxcXCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UoYFwiJHt2YWx1ZX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtYXRjaCA9IHJlc3QubWF0Y2godW5xdW90ZWRQYXJhbVJFKSkpIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgWywga2V5LCB2YWx1ZSwgcmVzdF0gPSBtYXRjaDtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtYXRjaCA9IHJlc3QubWF0Y2godG9rZW42OFBhcmFtUkUpKSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBbLCB0b2tlbjY4LCByZXN0XSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFsbGVuZ2UgPSB7IHNjaGVtZSwgcGFyYW1ldGVycyB9O1xuICAgICAgICBpZiAodG9rZW42OCkge1xuICAgICAgICAgICAgY2hhbGxlbmdlLnRva2VuNjggPSB0b2tlbjY4O1xuICAgICAgICB9XG4gICAgICAgIGNoYWxsZW5nZXMucHVzaChjaGFsbGVuZ2UpO1xuICAgIH1cbiAgICBpZiAoIWNoYWxsZW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjaGFsbGVuZ2VzO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NQdXNoZWRBdXRob3JpemF0aW9uUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGF3YWl0IGNoZWNrT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UsIDIwMSwgJ1B1c2hlZCBBdXRob3JpemF0aW9uIFJlcXVlc3QgRW5kcG9pbnQnKTtcbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgZ2V0UmVzcG9uc2VKc29uQm9keShyZXNwb25zZSk7XG4gICAgYXNzZXJ0U3RyaW5nKGpzb24ucmVxdWVzdF91cmksICdcInJlc3BvbnNlXCIgYm9keSBcInJlcXVlc3RfdXJpXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgIGJvZHk6IGpzb24sXG4gICAgfSk7XG4gICAgbGV0IGV4cGlyZXNJbiA9IHR5cGVvZiBqc29uLmV4cGlyZXNfaW4gIT09ICdudW1iZXInID8gcGFyc2VGbG9hdChqc29uLmV4cGlyZXNfaW4pIDoganNvbi5leHBpcmVzX2luO1xuICAgIGFzc2VydE51bWJlcihleHBpcmVzSW4sIHRydWUsICdcInJlc3BvbnNlXCIgYm9keSBcImV4cGlyZXNfaW5cIiBwcm9wZXJ0eScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgYm9keToganNvbixcbiAgICB9KTtcbiAgICBqc29uLmV4cGlyZXNfaW4gPSBleHBpcmVzSW47XG4gICAgcmV0dXJuIGpzb247XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZU9BdXRoUmVzcG9uc2VFcnJvckJvZHkocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID4gMzk5ICYmIHJlc3BvbnNlLnN0YXR1cyA8IDUwMCkge1xuICAgICAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgYXNzZXJ0QXBwbGljYXRpb25Kc29uKHJlc3BvbnNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5jbG9uZSgpLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChpc0pzb25PYmplY3QoanNvbikgJiYgdHlwZW9mIGpzb24uZXJyb3IgPT09ICdzdHJpbmcnICYmIGpzb24uZXJyb3IubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggeyB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5hc3luYyBmdW5jdGlvbiBjaGVja09BdXRoQm9keUVycm9yKHJlc3BvbnNlLCBleHBlY3RlZCwgbGFiZWwpIHtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSBleHBlY3RlZCkge1xuICAgICAgICBjaGVja0F1dGhlbnRpY2F0aW9uQ2hhbGxlbmdlcyhyZXNwb25zZSk7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmICgoZXJyID0gYXdhaXQgcGFyc2VPQXV0aFJlc3BvbnNlRXJyb3JCb2R5KHJlc3BvbnNlKSkpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlc3BvbnNlLmJvZHk/LmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlc3BvbnNlQm9keUVycm9yKCdzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYW4gZXJyb3IgaW4gdGhlIHJlc3BvbnNlIGJvZHknLCB7XG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycixcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IE9QRShgXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gJHtsYWJlbH0gcmVzcG9uc2UgKHVuZXhwZWN0ZWQgSFRUUCBzdGF0dXMgY29kZSlgLCBSRVNQT05TRV9JU19OT1RfQ09ORk9STSwgcmVzcG9uc2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydERQb1Aob3B0aW9uKSB7XG4gICAgaWYgKCFicmFuZGVkLmhhcyhvcHRpb24pKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcIm9wdGlvbnMuRFBvUFwiIGlzIG5vdCBhIHZhbGlkIERQb1BIYW5kbGUnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc291cmNlUmVxdWVzdChhY2Nlc3NUb2tlbiwgbWV0aG9kLCB1cmwsIGhlYWRlcnMsIGJvZHksIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRTdHJpbmcoYWNjZXNzVG9rZW4sICdcImFjY2Vzc1Rva2VuXCInKTtcbiAgICBpZiAoISh1cmwgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcInVybFwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBjaGVja1Byb3RvY29sKHVybCwgb3B0aW9ucz8uW2FsbG93SW5zZWN1cmVSZXF1ZXN0c10gIT09IHRydWUpO1xuICAgIGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhoZWFkZXJzKTtcbiAgICBpZiAob3B0aW9ucz8uRFBvUCkge1xuICAgICAgICBhc3NlcnREUG9QKG9wdGlvbnMuRFBvUCk7XG4gICAgICAgIGF3YWl0IG9wdGlvbnMuRFBvUC5hZGRQcm9vZih1cmwsIGhlYWRlcnMsIG1ldGhvZC50b1VwcGVyQ2FzZSgpLCBhY2Nlc3NUb2tlbik7XG4gICAgfVxuICAgIGhlYWRlcnMuc2V0KCdhdXRob3JpemF0aW9uJywgYCR7aGVhZGVycy5oYXMoJ2Rwb3AnKSA/ICdEUG9QJyA6ICdCZWFyZXInfSAke2FjY2Vzc1Rva2VufWApO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKG9wdGlvbnM/LltjdXN0b21GZXRjaF0gfHwgZmV0Y2gpKHVybC5ocmVmLCB7XG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzLmVudHJpZXMoKSksXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcmVkaXJlY3Q6ICdtYW51YWwnLFxuICAgICAgICBzaWduYWw6IHNpZ25hbCh1cmwsIG9wdGlvbnM/LnNpZ25hbCksXG4gICAgfSk7XG4gICAgb3B0aW9ucz8uRFBvUD8uY2FjaGVOb25jZShyZXNwb25zZSwgdXJsKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvdGVjdGVkUmVzb3VyY2VSZXF1ZXN0KGFjY2Vzc1Rva2VuLCBtZXRob2QsIHVybCwgaGVhZGVycywgYm9keSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzb3VyY2VSZXF1ZXN0KGFjY2Vzc1Rva2VuLCBtZXRob2QsIHVybCwgaGVhZGVycywgYm9keSwgb3B0aW9ucyk7XG4gICAgY2hlY2tBdXRoZW50aWNhdGlvbkNoYWxsZW5nZXMocmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1c2VySW5mb1JlcXVlc3QoYXMsIGNsaWVudCwgYWNjZXNzVG9rZW4sIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZUVuZHBvaW50KGFzLCAndXNlcmluZm9fZW5kcG9pbnQnLCBjbGllbnQudXNlX210bHNfZW5kcG9pbnRfYWxpYXNlcywgb3B0aW9ucz8uW2FsbG93SW5zZWN1cmVSZXF1ZXN0c10gIT09IHRydWUpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50LnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qd3QnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICBoZWFkZXJzLmFwcGVuZCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2p3dCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb3VyY2VSZXF1ZXN0KGFjY2Vzc1Rva2VuLCAnR0VUJywgdXJsLCBoZWFkZXJzLCBudWxsLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIFtjbG9ja1NrZXddOiBnZXRDbG9ja1NrZXcoY2xpZW50KSxcbiAgICB9KTtcbn1cbmxldCBqd2tzTWFwO1xuZnVuY3Rpb24gc2V0Sndrc0NhY2hlKGFzLCBqd2tzLCB1YXQsIGNhY2hlKSB7XG4gICAgandrc01hcCB8fD0gbmV3IFdlYWtNYXAoKTtcbiAgICBqd2tzTWFwLnNldChhcywge1xuICAgICAgICBqd2tzLFxuICAgICAgICB1YXQsXG4gICAgICAgIGdldCBhZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXBvY2hUaW1lKCkgLSB0aGlzLnVhdDtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjYWNoZSwgeyBqd2tzOiBzdHJ1Y3R1cmVkQ2xvbmUoandrcyksIHVhdCB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0ZyZXNoSndrc0NhY2hlKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgfHwgaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoISgndWF0JyBpbiBpbnB1dCkgfHwgdHlwZW9mIGlucHV0LnVhdCAhPT0gJ251bWJlcicgfHwgZXBvY2hUaW1lKCkgLSBpbnB1dC51YXQgPj0gMzAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCEoJ2p3a3MnIGluIGlucHV0KSB8fFxuICAgICAgICAhaXNKc29uT2JqZWN0KGlucHV0Lmp3a3MpIHx8XG4gICAgICAgICFBcnJheS5pc0FycmF5KGlucHV0Lmp3a3Mua2V5cykgfHxcbiAgICAgICAgIUFycmF5LnByb3RvdHlwZS5ldmVyeS5jYWxsKGlucHV0Lmp3a3Mua2V5cywgaXNKc29uT2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2xlYXJKd2tzQ2FjaGUoYXMsIGNhY2hlKSB7XG4gICAgandrc01hcD8uZGVsZXRlKGFzKTtcbiAgICBkZWxldGUgY2FjaGU/Lmp3a3M7XG4gICAgZGVsZXRlIGNhY2hlPy51YXQ7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaShhcywgb3B0aW9ucywgaGVhZGVyKSB7XG4gICAgY29uc3QgeyBhbGcsIGtpZCB9ID0gaGVhZGVyO1xuICAgIGNoZWNrU3VwcG9ydGVkSndzQWxnKGhlYWRlcik7XG4gICAgaWYgKCFqd2tzTWFwPy5oYXMoYXMpICYmIGlzRnJlc2hKd2tzQ2FjaGUob3B0aW9ucz8uW2p3a3NDYWNoZV0pKSB7XG4gICAgICAgIHNldEp3a3NDYWNoZShhcywgb3B0aW9ucz8uW2p3a3NDYWNoZV0uandrcywgb3B0aW9ucz8uW2p3a3NDYWNoZV0udWF0KTtcbiAgICB9XG4gICAgbGV0IGp3a3M7XG4gICAgbGV0IGFnZTtcbiAgICBpZiAoandrc01hcD8uaGFzKGFzKSkge1xuICAgICAgICA7XG4gICAgICAgICh7IGp3a3MsIGFnZSB9ID0gandrc01hcC5nZXQoYXMpKTtcbiAgICAgICAgaWYgKGFnZSA+PSAzMDApIHtcbiAgICAgICAgICAgIGNsZWFySndrc0NhY2hlKGFzLCBvcHRpb25zPy5bandrc0NhY2hlXSk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkoYXMsIG9wdGlvbnMsIGhlYWRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGp3a3MgPSBhd2FpdCBqd2tzUmVxdWVzdChhcywgb3B0aW9ucykudGhlbihwcm9jZXNzSndrc1Jlc3BvbnNlKTtcbiAgICAgICAgYWdlID0gMDtcbiAgICAgICAgc2V0Sndrc0NhY2hlKGFzLCBqd2tzLCBlcG9jaFRpbWUoKSwgb3B0aW9ucz8uW2p3a3NDYWNoZV0pO1xuICAgIH1cbiAgICBsZXQga3R5O1xuICAgIHN3aXRjaCAoYWxnLnNsaWNlKDAsIDIpKSB7XG4gICAgICAgIGNhc2UgJ1JTJzpcbiAgICAgICAgY2FzZSAnUFMnOlxuICAgICAgICAgICAga3R5ID0gJ1JTQSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRVMnOlxuICAgICAgICAgICAga3R5ID0gJ0VDJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFZCc6XG4gICAgICAgICAgICBrdHkgPSAnT0tQJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNTCc6XG4gICAgICAgICAgICBrdHkgPSAnQUtQJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIEpXUyBhbGdvcml0aG0nLCB7IGNhdXNlOiB7IGFsZyB9IH0pO1xuICAgIH1cbiAgICBjb25zdCBjYW5kaWRhdGVzID0gandrcy5rZXlzLmZpbHRlcigoandrKSA9PiB7XG4gICAgICAgIGlmIChqd2sua3R5ICE9PSBrdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2lkICE9PSB1bmRlZmluZWQgJiYga2lkICE9PSBqd2sua2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGp3ay5hbGcgIT09IHVuZGVmaW5lZCAmJiBhbGcgIT09IGp3ay5hbGcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoandrLnVzZSAhPT0gdW5kZWZpbmVkICYmIGp3ay51c2UgIT09ICdzaWcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGp3ay5rZXlfb3BzPy5pbmNsdWRlcygndmVyaWZ5JykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIGFsZyA9PT0gJ0VTMjU2JyAmJiBqd2suY3J2ICE9PSAnUC0yNTYnOlxuICAgICAgICAgICAgY2FzZSBhbGcgPT09ICdFUzM4NCcgJiYgandrLmNydiAhPT0gJ1AtMzg0JzpcbiAgICAgICAgICAgIGNhc2UgYWxnID09PSAnRVM1MTInICYmIGp3ay5jcnYgIT09ICdQLTUyMSc6XG4gICAgICAgICAgICBjYXNlIGFsZyA9PT0gJ0VkMjU1MTknICYmIGp3ay5jcnYgIT09ICdFZDI1NTE5JzpcbiAgICAgICAgICAgIGNhc2UgYWxnID09PSAnRWREU0EnICYmIGp3ay5jcnYgIT09ICdFZDI1NTE5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgY29uc3QgeyAwOiBqd2ssIGxlbmd0aCB9ID0gY2FuZGlkYXRlcztcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBpZiAoYWdlID49IDYwKSB7XG4gICAgICAgICAgICBjbGVhckp3a3NDYWNoZShhcywgb3B0aW9ucz8uW2p3a3NDYWNoZV0pO1xuICAgICAgICAgICAgcmV0dXJuIGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpKGFzLCBvcHRpb25zLCBoZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IE9QRSgnZXJyb3Igd2hlbiBzZWxlY3RpbmcgYSBKV1QgdmVyaWZpY2F0aW9uIGtleSwgbm8gYXBwbGljYWJsZSBrZXlzIGZvdW5kJywgS0VZX1NFTEVDVElPTiwgeyBoZWFkZXIsIGNhbmRpZGF0ZXMsIGp3a3NfdXJpOiBuZXcgVVJMKGFzLmp3a3NfdXJpKSB9KTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBPUEUoJ2Vycm9yIHdoZW4gc2VsZWN0aW5nIGEgSldUIHZlcmlmaWNhdGlvbiBrZXksIG11bHRpcGxlIGFwcGxpY2FibGUga2V5cyBmb3VuZCwgYSBcImtpZFwiIEpXVCBIZWFkZXIgUGFyYW1ldGVyIGlzIHJlcXVpcmVkJywgS0VZX1NFTEVDVElPTiwgeyBoZWFkZXIsIGNhbmRpZGF0ZXMsIGp3a3NfdXJpOiBuZXcgVVJMKGFzLmp3a3NfdXJpKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydEp3ayhhbGcsIGp3ayk7XG59XG5leHBvcnQgY29uc3Qgc2tpcFN1YmplY3RDaGVjayA9IFN5bWJvbCgpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRlbnRUeXBlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKT8uc3BsaXQoJzsnKVswXTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzVXNlckluZm9SZXNwb25zZShhcywgY2xpZW50LCBleHBlY3RlZFN1YmplY3QsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBjaGVja0F1dGhlbnRpY2F0aW9uQ2hhbGxlbmdlcyhyZXNwb25zZSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gVXNlckluZm8gRW5kcG9pbnQgcmVzcG9uc2UgKHVuZXhwZWN0ZWQgSFRUUCBzdGF0dXMgY29kZSknLCBSRVNQT05TRV9JU19OT1RfQ09ORk9STSwgcmVzcG9uc2UpO1xuICAgIH1cbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBsZXQganNvbjtcbiAgICBpZiAoZ2V0Q29udGVudFR5cGUocmVzcG9uc2UpID09PSAnYXBwbGljYXRpb24vand0Jykge1xuICAgICAgICBjb25zdCB7IGNsYWltcywgand0IH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChhd2FpdCByZXNwb25zZS50ZXh0KCksIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcsIGFzLnVzZXJpbmZvX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQsIHVuZGVmaW5lZCksIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpLCBvcHRpb25zPy5bandlRGVjcnlwdF0pXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZU9wdGlvbmFsQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGNsaWVudC5jbGllbnRfaWQpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVPcHRpb25hbElzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMpKTtcbiAgICAgICAgand0UmVmcy5zZXQocmVzcG9uc2UsIGp3dCk7XG4gICAgICAgIGpzb24gPSBjbGFpbXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoY2xpZW50LnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgnSldUIFVzZXJJbmZvIFJlc3BvbnNlIGV4cGVjdGVkJywgSldUX1VTRVJJTkZPX0VYUEVDVEVELCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAganNvbiA9IGF3YWl0IGdldFJlc3BvbnNlSnNvbkJvZHkocmVzcG9uc2UpO1xuICAgIH1cbiAgICBhc3NlcnRTdHJpbmcoanNvbi5zdWIsICdcInJlc3BvbnNlXCIgYm9keSBcInN1YlwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwgeyBib2R5OiBqc29uIH0pO1xuICAgIHN3aXRjaCAoZXhwZWN0ZWRTdWJqZWN0KSB7XG4gICAgICAgIGNhc2Ugc2tpcFN1YmplY3RDaGVjazpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYXNzZXJ0U3RyaW5nKGV4cGVjdGVkU3ViamVjdCwgJ1wiZXhwZWN0ZWRTdWJqZWN0XCInKTtcbiAgICAgICAgICAgIGlmIChqc29uLnN1YiAhPT0gZXhwZWN0ZWRTdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIFwicmVzcG9uc2VcIiBib2R5IFwic3ViXCIgcHJvcGVydHkgdmFsdWUnLCBKU09OX0FUVFJJQlVURV9DT01QQVJJU09OLCB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZFN1YmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGpzb24sXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogJ3N1YicsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuYXN5bmMgZnVuY3Rpb24gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucykge1xuICAgIGF3YWl0IGNsaWVudEF1dGhlbnRpY2F0aW9uKGFzLCBjbGllbnQsIGJvZHksIGhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICByZXR1cm4gKG9wdGlvbnM/LltjdXN0b21GZXRjaF0gfHwgZmV0Y2gpKHVybC5ocmVmLCB7XG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzLmVudHJpZXMoKSksXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHVybCwgb3B0aW9ucz8uc2lnbmFsKSxcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCBncmFudFR5cGUsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICd0b2tlbl9lbmRwb2ludCcsIGNsaWVudC51c2VfbXRsc19lbmRwb2ludF9hbGlhc2VzLCBvcHRpb25zPy5bYWxsb3dJbnNlY3VyZVJlcXVlc3RzXSAhPT0gdHJ1ZSk7XG4gICAgcGFyYW1ldGVycy5zZXQoJ2dyYW50X3R5cGUnLCBncmFudFR5cGUpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBpZiAob3B0aW9ucz8uRFBvUCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydERQb1Aob3B0aW9ucy5EUG9QKTtcbiAgICAgICAgYXdhaXQgb3B0aW9ucy5EUG9QLmFkZFByb29mKHVybCwgaGVhZGVycywgJ1BPU1QnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgdXJsLCBwYXJhbWV0ZXJzLCBoZWFkZXJzLCBvcHRpb25zKTtcbiAgICBvcHRpb25zPy5EUG9QPy5jYWNoZU5vbmNlKHJlc3BvbnNlLCB1cmwpO1xuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWZyZXNoVG9rZW5HcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIHJlZnJlc2hUb2tlbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBhc3NlcnRTdHJpbmcocmVmcmVzaFRva2VuLCAnXCJyZWZyZXNoVG9rZW5cIicpO1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgncmVmcmVzaF90b2tlbicsIHJlZnJlc2hUb2tlbik7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCAncmVmcmVzaF90b2tlbicsIHBhcmFtZXRlcnMsIG9wdGlvbnMpO1xufVxuY29uc3QgaWRUb2tlbkNsYWltcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBqd3RSZWZzID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWxpZGF0ZWRJZFRva2VuQ2xhaW1zKHJlZikge1xuICAgIGlmICghcmVmLmlkX3Rva2VuKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGNsYWltcyA9IGlkVG9rZW5DbGFpbXMuZ2V0KHJlZik7XG4gICAgaWYgKCFjbGFpbXMpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicmVmXCIgd2FzIGFscmVhZHkgZ2FyYmFnZSBjb2xsZWN0ZWQgb3IgZGlkIG5vdCByZXNvbHZlIGZyb20gdGhlIHByb3BlciBzb3VyY2VzJywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYWltcztcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUFwcGxpY2F0aW9uTGV2ZWxTaWduYXR1cmUoYXMsIHJlZiwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBpZiAoIWp3dFJlZnMuaGFzKHJlZikpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicmVmXCIgZG9lcyBub3QgY29udGFpbiBhIHByb2Nlc3NlZCBKV1QgUmVzcG9uc2UgdG8gdmVyaWZ5IHRoZSBzaWduYXR1cmUgb2YnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgIH1cbiAgICBjb25zdCB7IDA6IHByb3RlY3RlZEhlYWRlciwgMTogcGF5bG9hZCwgMjogZW5jb2RlZFNpZ25hdHVyZSB9ID0gand0UmVmcy5nZXQocmVmKS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGhlYWRlciA9IEpTT04ucGFyc2UoYnVmKGI2NHUocHJvdGVjdGVkSGVhZGVyKSkpO1xuICAgIGlmIChoZWFkZXIuYWxnLnN0YXJ0c1dpdGgoJ0hTJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIEpXUyBhbGdvcml0aG0nLCB7IGNhdXNlOiB7IGFsZzogaGVhZGVyLmFsZyB9IH0pO1xuICAgIH1cbiAgICBsZXQga2V5O1xuICAgIGtleSA9IGF3YWl0IGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpKGFzLCBvcHRpb25zLCBoZWFkZXIpO1xuICAgIGF3YWl0IHZhbGlkYXRlSndzU2lnbmF0dXJlKHByb3RlY3RlZEhlYWRlciwgcGF5bG9hZCwga2V5LCBiNjR1KGVuY29kZWRTaWduYXR1cmUpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgYWRkaXRpb25hbFJlcXVpcmVkSWRUb2tlbkNsYWltcywgZGVjcnlwdEZuLCByZWNvZ25pemVkVG9rZW5UeXBlcykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgYXdhaXQgY2hlY2tPQXV0aEJvZHlFcnJvcihyZXNwb25zZSwgMjAwLCAnVG9rZW4gRW5kcG9pbnQnKTtcbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgZ2V0UmVzcG9uc2VKc29uQm9keShyZXNwb25zZSk7XG4gICAgYXNzZXJ0U3RyaW5nKGpzb24uYWNjZXNzX3Rva2VuLCAnXCJyZXNwb25zZVwiIGJvZHkgXCJhY2Nlc3NfdG9rZW5cIiBwcm9wZXJ0eScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgYm9keToganNvbixcbiAgICB9KTtcbiAgICBhc3NlcnRTdHJpbmcoanNvbi50b2tlbl90eXBlLCAnXCJyZXNwb25zZVwiIGJvZHkgXCJ0b2tlbl90eXBlXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgIGJvZHk6IGpzb24sXG4gICAgfSk7XG4gICAganNvbi50b2tlbl90eXBlID0ganNvbi50b2tlbl90eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGpzb24uZXhwaXJlc19pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBleHBpcmVzSW4gPSB0eXBlb2YganNvbi5leHBpcmVzX2luICE9PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQoanNvbi5leHBpcmVzX2luKSA6IGpzb24uZXhwaXJlc19pbjtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGV4cGlyZXNJbiwgdHJ1ZSwgJ1wicmVzcG9uc2VcIiBib2R5IFwiZXhwaXJlc19pblwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICAgICAgYm9keToganNvbixcbiAgICAgICAgfSk7XG4gICAgICAgIGpzb24uZXhwaXJlc19pbiA9IGV4cGlyZXNJbjtcbiAgICB9XG4gICAgaWYgKGpzb24ucmVmcmVzaF90b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydFN0cmluZyhqc29uLnJlZnJlc2hfdG9rZW4sICdcInJlc3BvbnNlXCIgYm9keSBcInJlZnJlc2hfdG9rZW5cIiBwcm9wZXJ0eScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgICAgIGJvZHk6IGpzb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoanNvbi5zY29wZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBqc29uLnNjb3BlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwic2NvcGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nJywgSU5WQUxJRF9SRVNQT05TRSwgeyBib2R5OiBqc29uIH0pO1xuICAgIH1cbiAgICBpZiAoanNvbi5pZF90b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydFN0cmluZyhqc29uLmlkX3Rva2VuLCAnXCJyZXNwb25zZVwiIGJvZHkgXCJpZF90b2tlblwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICAgICAgYm9keToganNvbixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkQ2xhaW1zID0gWydhdWQnLCAnZXhwJywgJ2lhdCcsICdpc3MnLCAnc3ViJ107XG4gICAgICAgIGlmIChjbGllbnQucmVxdWlyZV9hdXRoX3RpbWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlcXVpcmVkQ2xhaW1zLnB1c2goJ2F1dGhfdGltZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnQuZGVmYXVsdF9tYXhfYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydE51bWJlcihjbGllbnQuZGVmYXVsdF9tYXhfYWdlLCB0cnVlLCAnXCJjbGllbnQuZGVmYXVsdF9tYXhfYWdlXCInKTtcbiAgICAgICAgICAgIHJlcXVpcmVkQ2xhaW1zLnB1c2goJ2F1dGhfdGltZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbmFsUmVxdWlyZWRJZFRva2VuQ2xhaW1zPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcXVpcmVkQ2xhaW1zLnB1c2goLi4uYWRkaXRpb25hbFJlcXVpcmVkSWRUb2tlbkNsYWltcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjbGFpbXMsIGp3dCB9ID0gYXdhaXQgdmFsaWRhdGVKd3QoanNvbi5pZF90b2tlbiwgY2hlY2tTaWduaW5nQWxnb3JpdGhtLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuaWRfdG9rZW5fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMuaWRfdG9rZW5fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCwgJ1JTMjU2JyksIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpLCBkZWNyeXB0Rm4pXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZVByZXNlbmNlLmJpbmQodW5kZWZpbmVkLCByZXF1aXJlZENsYWltcykpXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZUlzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmNsaWVudF9pZCkpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjbGFpbXMuYXVkKSAmJiBjbGFpbXMuYXVkLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgaWYgKGNsYWltcy5henAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IE9QRSgnSUQgVG9rZW4gXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIGluY2x1ZGVzIGFkZGl0aW9uYWwgdW50cnVzdGVkIGF1ZGllbmNlcycsIEpXVF9DTEFJTV9DT01QQVJJU09OLCB7IGNsYWltcywgY2xhaW06ICdhdWQnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsYWltcy5henAgIT09IGNsaWVudC5jbGllbnRfaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJhenBcIiAoYXV0aG9yaXplZCBwYXJ0eSkgY2xhaW0gdmFsdWUnLCBKV1RfQ0xBSU1fQ09NUEFSSVNPTiwgeyBleHBlY3RlZDogY2xpZW50LmNsaWVudF9pZCwgY2xhaW1zLCBjbGFpbTogJ2F6cCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYWltcy5hdXRoX3RpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGNsYWltcy5hdXRoX3RpbWUsIHRydWUsICdJRCBUb2tlbiBcImF1dGhfdGltZVwiIChhdXRoZW50aWNhdGlvbiB0aW1lKScsIElOVkFMSURfUkVTUE9OU0UsIHsgY2xhaW1zIH0pO1xuICAgICAgICB9XG4gICAgICAgIGp3dFJlZnMuc2V0KHJlc3BvbnNlLCBqd3QpO1xuICAgICAgICBpZFRva2VuQ2xhaW1zLnNldChqc29uLCBjbGFpbXMpO1xuICAgIH1cbiAgICBpZiAocmVjb2duaXplZFRva2VuVHlwZXM/Lltqc29uLnRva2VuX3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVjb2duaXplZFRva2VuVHlwZXNbanNvbi50b2tlbl90eXBlXShyZXNwb25zZSwganNvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGpzb24udG9rZW5fdHlwZSAhPT0gJ2Rwb3AnICYmIGpzb24udG9rZW5fdHlwZSAhPT0gJ2JlYXJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIGB0b2tlbl90eXBlYCB2YWx1ZScsIHsgY2F1c2U6IHsgYm9keToganNvbiB9IH0pO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmZ1bmN0aW9uIGNoZWNrQXV0aGVudGljYXRpb25DaGFsbGVuZ2VzKHJlc3BvbnNlKSB7XG4gICAgbGV0IGNoYWxsZW5nZXM7XG4gICAgaWYgKChjaGFsbGVuZ2VzID0gcGFyc2VXd3dBdXRoZW50aWNhdGVDaGFsbGVuZ2VzKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdXV0F1dGhlbnRpY2F0ZUNoYWxsZW5nZUVycm9yKCdzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYSBjaGFsbGVuZ2UgaW4gdGhlIFdXVy1BdXRoZW50aWNhdGUgSFRUUCBIZWFkZXInLCB7IGNhdXNlOiBjaGFsbGVuZ2VzLCByZXNwb25zZSB9KTtcbiAgICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1JlZnJlc2hUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgdW5kZWZpbmVkLCBvcHRpb25zPy5bandlRGVjcnlwdF0sIG9wdGlvbnM/LnJlY29nbml6ZWRUb2tlblR5cGVzKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uYWxBdWRpZW5jZShleHBlY3RlZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5jbGFpbXMuYXVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlQXVkaWVuY2UoZXhwZWN0ZWQsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUF1ZGllbmNlKGV4cGVjdGVkLCByZXN1bHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQuY2xhaW1zLmF1ZCkpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQuY2xhaW1zLmF1ZC5pbmNsdWRlcyhleHBlY3RlZCkpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIHZhbHVlJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICBjbGFpbXM6IHJlc3VsdC5jbGFpbXMsXG4gICAgICAgICAgICAgICAgY2xhaW06ICdhdWQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdWx0LmNsYWltcy5hdWQgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIHZhbHVlJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAgICAgY2xhaW1zOiByZXN1bHQuY2xhaW1zLFxuICAgICAgICAgICAgY2xhaW06ICdhdWQnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uYWxJc3N1ZXIoYXMsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuY2xhaW1zLmlzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUlzc3VlcihhcywgcmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlSXNzdWVyKGFzLCByZXN1bHQpIHtcbiAgICBjb25zdCBleHBlY3RlZCA9IGFzW19leHBlY3RlZElzc3Vlcl0/LihyZXN1bHQpID8/IGFzLmlzc3VlcjtcbiAgICBpZiAocmVzdWx0LmNsYWltcy5pc3MgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBKV1QgXCJpc3NcIiAoaXNzdWVyKSBjbGFpbSB2YWx1ZScsIEpXVF9DTEFJTV9DT01QQVJJU09OLCB7XG4gICAgICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgICAgIGNsYWltczogcmVzdWx0LmNsYWltcyxcbiAgICAgICAgICAgIGNsYWltOiAnaXNzJyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBicmFuZGVkID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIGJyYW5kKHNlYXJjaFBhcmFtcykge1xuICAgIGJyYW5kZWQuYWRkKHNlYXJjaFBhcmFtcyk7XG4gICAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbmV4cG9ydCBjb25zdCBub3BrY2UgPSBTeW1ib2woKTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhdXRob3JpemF0aW9uQ29kZUdyYW50UmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgY2FsbGJhY2tQYXJhbWV0ZXJzLCByZWRpcmVjdFVyaSwgY29kZVZlcmlmaWVyLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghYnJhbmRlZC5oYXMoY2FsbGJhY2tQYXJhbWV0ZXJzKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJjYWxsYmFja1BhcmFtZXRlcnNcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTFNlYXJjaFBhcmFtcyBvYnRhaW5lZCBmcm9tIFwidmFsaWRhdGVBdXRoUmVzcG9uc2UoKVwiLCBvciBcInZhbGlkYXRlSnd0QXV0aFJlc3BvbnNlKCknLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgIH1cbiAgICBhc3NlcnRTdHJpbmcocmVkaXJlY3RVcmksICdcInJlZGlyZWN0VXJpXCInKTtcbiAgICBjb25zdCBjb2RlID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKGNhbGxiYWNrUGFyYW1ldGVycywgJ2NvZGUnKTtcbiAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdubyBhdXRob3JpemF0aW9uIGNvZGUgaW4gXCJjYWxsYmFja1BhcmFtZXRlcnNcIicsIElOVkFMSURfUkVTUE9OU0UpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zPy5hZGRpdGlvbmFsUGFyYW1ldGVycyk7XG4gICAgcGFyYW1ldGVycy5zZXQoJ3JlZGlyZWN0X3VyaScsIHJlZGlyZWN0VXJpKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgnY29kZScsIGNvZGUpO1xuICAgIGlmIChjb2RlVmVyaWZpZXIgIT09IG5vcGtjZSkge1xuICAgICAgICBhc3NlcnRTdHJpbmcoY29kZVZlcmlmaWVyLCAnXCJjb2RlVmVyaWZpZXJcIicpO1xuICAgICAgICBwYXJhbWV0ZXJzLnNldCgnY29kZV92ZXJpZmllcicsIGNvZGVWZXJpZmllcik7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbkVuZHBvaW50UmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgJ2F1dGhvcml6YXRpb25fY29kZScsIHBhcmFtZXRlcnMsIG9wdGlvbnMpO1xufVxuY29uc3Qgand0Q2xhaW1OYW1lcyA9IHtcbiAgICBhdWQ6ICdhdWRpZW5jZScsXG4gICAgY19oYXNoOiAnY29kZSBoYXNoJyxcbiAgICBjbGllbnRfaWQ6ICdjbGllbnQgaWQnLFxuICAgIGV4cDogJ2V4cGlyYXRpb24gdGltZScsXG4gICAgaWF0OiAnaXNzdWVkIGF0JyxcbiAgICBpc3M6ICdpc3N1ZXInLFxuICAgIGp0aTogJ2p3dCBpZCcsXG4gICAgbm9uY2U6ICdub25jZScsXG4gICAgc19oYXNoOiAnc3RhdGUgaGFzaCcsXG4gICAgc3ViOiAnc3ViamVjdCcsXG4gICAgYXRoOiAnYWNjZXNzIHRva2VuIGhhc2gnLFxuICAgIGh0bTogJ2h0dHAgbWV0aG9kJyxcbiAgICBodHU6ICdodHRwIHVyaScsXG4gICAgY25mOiAnY29uZmlybWF0aW9uJyxcbiAgICBhdXRoX3RpbWU6ICdhdXRoZW50aWNhdGlvbiB0aW1lJyxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVByZXNlbmNlKHJlcXVpcmVkLCByZXN1bHQpIHtcbiAgICBmb3IgKGNvbnN0IGNsYWltIG9mIHJlcXVpcmVkKSB7XG4gICAgICAgIGlmIChyZXN1bHQuY2xhaW1zW2NsYWltXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoYEpXVCBcIiR7Y2xhaW19XCIgKCR7and0Q2xhaW1OYW1lc1tjbGFpbV19KSBjbGFpbSBtaXNzaW5nYCwgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICAgICAgICAgIGNsYWltczogcmVzdWx0LmNsYWltcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY29uc3QgZXhwZWN0Tm9Ob25jZSA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IHNraXBBdXRoVGltZUNoZWNrID0gU3ltYm9sKCk7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnM/LmV4cGVjdGVkTm9uY2UgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiBvcHRpb25zPy5tYXhBZ2UgPT09ICdudW1iZXInIHx8XG4gICAgICAgIG9wdGlvbnM/LnJlcXVpcmVJZFRva2VuKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPcGVuSURSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgb3B0aW9ucy5leHBlY3RlZE5vbmNlLCBvcHRpb25zLm1heEFnZSwgb3B0aW9uc1tqd2VEZWNyeXB0XSwgb3B0aW9ucy5yZWNvZ25pemVkVG9rZW5UeXBlcyk7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPQXV0aDJSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgb3B0aW9ucz8uW2p3ZURlY3J5cHRdLCBvcHRpb25zPy5yZWNvZ25pemVkVG9rZW5UeXBlcyk7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPcGVuSURSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgZXhwZWN0ZWROb25jZSwgbWF4QWdlLCBkZWNyeXB0Rm4sIHJlY29nbml6ZWRUb2tlblR5cGVzKSB7XG4gICAgY29uc3QgYWRkaXRpb25hbFJlcXVpcmVkQ2xhaW1zID0gW107XG4gICAgc3dpdGNoIChleHBlY3RlZE5vbmNlKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgZXhwZWN0ZWROb25jZSA9IGV4cGVjdE5vTm9uY2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBleHBlY3ROb05vbmNlOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhc3NlcnRTdHJpbmcoZXhwZWN0ZWROb25jZSwgJ1wiZXhwZWN0ZWROb25jZVwiIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICBhZGRpdGlvbmFsUmVxdWlyZWRDbGFpbXMucHVzaCgnbm9uY2UnKTtcbiAgICB9XG4gICAgbWF4QWdlID8/PSBjbGllbnQuZGVmYXVsdF9tYXhfYWdlO1xuICAgIHN3aXRjaCAobWF4QWdlKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgbWF4QWdlID0gc2tpcEF1dGhUaW1lQ2hlY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBza2lwQXV0aFRpbWVDaGVjazpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKG1heEFnZSwgdHJ1ZSwgJ1wibWF4QWdlXCIgYXJndW1lbnQnKTtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxSZXF1aXJlZENsYWltcy5wdXNoKCdhdXRoX3RpbWUnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBhZGRpdGlvbmFsUmVxdWlyZWRDbGFpbXMsIGRlY3J5cHRGbiwgcmVjb2duaXplZFRva2VuVHlwZXMpO1xuICAgIGFzc2VydFN0cmluZyhyZXN1bHQuaWRfdG9rZW4sICdcInJlc3BvbnNlXCIgYm9keSBcImlkX3Rva2VuXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgIGJvZHk6IHJlc3VsdCxcbiAgICB9KTtcbiAgICBjb25zdCBjbGFpbXMgPSBnZXRWYWxpZGF0ZWRJZFRva2VuQ2xhaW1zKHJlc3VsdCk7XG4gICAgaWYgKG1heEFnZSAhPT0gc2tpcEF1dGhUaW1lQ2hlY2spIHtcbiAgICAgICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBnZXRDbG9ja1NrZXcoY2xpZW50KTtcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gZ2V0Q2xvY2tUb2xlcmFuY2UoY2xpZW50KTtcbiAgICAgICAgaWYgKGNsYWltcy5hdXRoX3RpbWUgKyBtYXhBZ2UgPCBub3cgLSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgndG9vIG11Y2ggdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBFbmQtVXNlciBhdXRoZW50aWNhdGlvbicsIEpXVF9USU1FU1RBTVBfQ0hFQ0ssIHsgY2xhaW1zLCBub3csIHRvbGVyYW5jZSwgY2xhaW06ICdhdXRoX3RpbWUnIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChleHBlY3RlZE5vbmNlID09PSBleHBlY3ROb05vbmNlKSB7XG4gICAgICAgIGlmIChjbGFpbXMubm9uY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwibm9uY2VcIiBjbGFpbSB2YWx1ZScsIEpXVF9DTEFJTV9DT01QQVJJU09OLCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBjbGFpbXMsXG4gICAgICAgICAgICAgICAgY2xhaW06ICdub25jZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjbGFpbXMubm9uY2UgIT09IGV4cGVjdGVkTm9uY2UpIHtcbiAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwibm9uY2VcIiBjbGFpbSB2YWx1ZScsIEpXVF9DTEFJTV9DT01QQVJJU09OLCB7XG4gICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWROb25jZSxcbiAgICAgICAgICAgIGNsYWltcyxcbiAgICAgICAgICAgIGNsYWltOiAnbm9uY2UnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NBdXRob3JpemF0aW9uQ29kZU9BdXRoMlJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBkZWNyeXB0Rm4sIHJlY29nbml6ZWRUb2tlblR5cGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCB1bmRlZmluZWQsIGRlY3J5cHRGbiwgcmVjb2duaXplZFRva2VuVHlwZXMpO1xuICAgIGNvbnN0IGNsYWltcyA9IGdldFZhbGlkYXRlZElkVG9rZW5DbGFpbXMocmVzdWx0KTtcbiAgICBpZiAoY2xhaW1zKSB7XG4gICAgICAgIGlmIChjbGllbnQuZGVmYXVsdF9tYXhfYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydE51bWJlcihjbGllbnQuZGVmYXVsdF9tYXhfYWdlLCB0cnVlLCAnXCJjbGllbnQuZGVmYXVsdF9tYXhfYWdlXCInKTtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgZ2V0Q2xvY2tTa2V3KGNsaWVudCk7XG4gICAgICAgICAgICBjb25zdCB0b2xlcmFuY2UgPSBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpO1xuICAgICAgICAgICAgaWYgKGNsYWltcy5hdXRoX3RpbWUgKyBjbGllbnQuZGVmYXVsdF9tYXhfYWdlIDwgbm93IC0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgT1BFKCd0b28gbXVjaCB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IEVuZC1Vc2VyIGF1dGhlbnRpY2F0aW9uJywgSldUX1RJTUVTVEFNUF9DSEVDSywgeyBjbGFpbXMsIG5vdywgdG9sZXJhbmNlLCBjbGFpbTogJ2F1dGhfdGltZScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYWltcy5ub25jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJub25jZVwiIGNsYWltIHZhbHVlJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNsYWltcyxcbiAgICAgICAgICAgICAgICBjbGFpbTogJ25vbmNlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY29uc3QgV1dXX0FVVEhFTlRJQ0FURV9DSEFMTEVOR0UgPSAnT0FVVEhfV1dXX0FVVEhFTlRJQ0FURV9DSEFMTEVOR0UnO1xuZXhwb3J0IGNvbnN0IFJFU1BPTlNFX0JPRFlfRVJST1IgPSAnT0FVVEhfUkVTUE9OU0VfQk9EWV9FUlJPUic7XG5leHBvcnQgY29uc3QgVU5TVVBQT1JURURfT1BFUkFUSU9OID0gJ09BVVRIX1VOU1VQUE9SVEVEX09QRVJBVElPTic7XG5leHBvcnQgY29uc3QgQVVUSE9SSVpBVElPTl9SRVNQT05TRV9FUlJPUiA9ICdPQVVUSF9BVVRIT1JJWkFUSU9OX1JFU1BPTlNFX0VSUk9SJztcbmV4cG9ydCBjb25zdCBKV1RfVVNFUklORk9fRVhQRUNURUQgPSAnT0FVVEhfSldUX1VTRVJJTkZPX0VYUEVDVEVEJztcbmV4cG9ydCBjb25zdCBQQVJTRV9FUlJPUiA9ICdPQVVUSF9QQVJTRV9FUlJPUic7XG5leHBvcnQgY29uc3QgSU5WQUxJRF9SRVNQT05TRSA9ICdPQVVUSF9JTlZBTElEX1JFU1BPTlNFJztcbmV4cG9ydCBjb25zdCBJTlZBTElEX1JFUVVFU1QgPSAnT0FVVEhfSU5WQUxJRF9SRVFVRVNUJztcbmV4cG9ydCBjb25zdCBSRVNQT05TRV9JU19OT1RfSlNPTiA9ICdPQVVUSF9SRVNQT05TRV9JU19OT1RfSlNPTic7XG5leHBvcnQgY29uc3QgUkVTUE9OU0VfSVNfTk9UX0NPTkZPUk0gPSAnT0FVVEhfUkVTUE9OU0VfSVNfTk9UX0NPTkZPUk0nO1xuZXhwb3J0IGNvbnN0IEhUVFBfUkVRVUVTVF9GT1JCSURERU4gPSAnT0FVVEhfSFRUUF9SRVFVRVNUX0ZPUkJJRERFTic7XG5leHBvcnQgY29uc3QgUkVRVUVTVF9QUk9UT0NPTF9GT1JCSURERU4gPSAnT0FVVEhfUkVRVUVTVF9QUk9UT0NPTF9GT1JCSURERU4nO1xuZXhwb3J0IGNvbnN0IEpXVF9USU1FU1RBTVBfQ0hFQ0sgPSAnT0FVVEhfSldUX1RJTUVTVEFNUF9DSEVDS19GQUlMRUQnO1xuZXhwb3J0IGNvbnN0IEpXVF9DTEFJTV9DT01QQVJJU09OID0gJ09BVVRIX0pXVF9DTEFJTV9DT01QQVJJU09OX0ZBSUxFRCc7XG5leHBvcnQgY29uc3QgSlNPTl9BVFRSSUJVVEVfQ09NUEFSSVNPTiA9ICdPQVVUSF9KU09OX0FUVFJJQlVURV9DT01QQVJJU09OX0ZBSUxFRCc7XG5leHBvcnQgY29uc3QgS0VZX1NFTEVDVElPTiA9ICdPQVVUSF9LRVlfU0VMRUNUSU9OX0ZBSUxFRCc7XG5leHBvcnQgY29uc3QgTUlTU0lOR19TRVJWRVJfTUVUQURBVEEgPSAnT0FVVEhfTUlTU0lOR19TRVJWRVJfTUVUQURBVEEnO1xuZXhwb3J0IGNvbnN0IElOVkFMSURfU0VSVkVSX01FVEFEQVRBID0gJ09BVVRIX0lOVkFMSURfU0VSVkVSX01FVEFEQVRBJztcbmZ1bmN0aW9uIGNoZWNrSnd0VHlwZShleHBlY3RlZCwgcmVzdWx0KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQuaGVhZGVyLnR5cCAhPT0gJ3N0cmluZycgfHwgbm9ybWFsaXplVHlwKHJlc3VsdC5oZWFkZXIudHlwKSAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIEpXVCBcInR5cFwiIGhlYWRlciBwYXJhbWV0ZXIgdmFsdWUnLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgICAgICBoZWFkZXI6IHJlc3VsdC5oZWFkZXIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsaWVudENyZWRlbnRpYWxzR3JhbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIHJldHVybiB0b2tlbkVuZHBvaW50UmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgJ2NsaWVudF9jcmVkZW50aWFscycsIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyksIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyaWNUb2tlbkVuZHBvaW50UmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgZ3JhbnRUeXBlLCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGFzc2VydFN0cmluZyhncmFudFR5cGUsICdcImdyYW50VHlwZVwiJyk7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCBncmFudFR5cGUsIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyksIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NHZW5lcmljVG9rZW5FbmRwb2ludFJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgdW5kZWZpbmVkLCBvcHRpb25zPy5bandlRGVjcnlwdF0sIG9wdGlvbnM/LnJlY29nbml6ZWRUb2tlblR5cGVzKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2xpZW50Q3JlZGVudGlhbHNSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIHVuZGVmaW5lZCwgb3B0aW9ucz8uW2p3ZURlY3J5cHRdLCBvcHRpb25zPy5yZWNvZ25pemVkVG9rZW5UeXBlcyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV2b2NhdGlvblJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIHRva2VuLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGFzc2VydFN0cmluZyh0b2tlbiwgJ1widG9rZW5cIicpO1xuICAgIGNvbnN0IHVybCA9IHJlc29sdmVFbmRwb2ludChhcywgJ3Jldm9jYXRpb25fZW5kcG9pbnQnLCBjbGllbnQudXNlX210bHNfZW5kcG9pbnRfYWxpYXNlcywgb3B0aW9ucz8uW2FsbG93SW5zZWN1cmVSZXF1ZXN0c10gIT09IHRydWUpO1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBib2R5LnNldCgndG9rZW4nLCB0b2tlbik7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuZGVsZXRlKCdhY2NlcHQnKTtcbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1Jldm9jYXRpb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBhd2FpdCBjaGVja09BdXRoQm9keUVycm9yKHJlc3BvbnNlLCAyMDAsICdSZXZvY2F0aW9uIEVuZHBvaW50Jyk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2UuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBib2R5IGhhcyBiZWVuIHVzZWQgYWxyZWFkeScsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGludHJvc3BlY3Rpb25SZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCB0b2tlbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBhc3NlcnRTdHJpbmcodG9rZW4sICdcInRva2VuXCInKTtcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICdpbnRyb3NwZWN0aW9uX2VuZHBvaW50JywgY2xpZW50LnVzZV9tdGxzX2VuZHBvaW50X2FsaWFzZXMsIG9wdGlvbnM/LlthbGxvd0luc2VjdXJlUmVxdWVzdHNdICE9PSB0cnVlKTtcbiAgICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zPy5hZGRpdGlvbmFsUGFyYW1ldGVycyk7XG4gICAgYm9keS5zZXQoJ3Rva2VuJywgdG9rZW4pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBpZiAob3B0aW9ucz8ucmVxdWVzdEp3dFJlc3BvbnNlID8/IGNsaWVudC5pbnRyb3NwZWN0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi90b2tlbi1pbnRyb3NwZWN0aW9uK2p3dCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgfVxuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzSW50cm9zcGVjdGlvblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBhd2FpdCBjaGVja09BdXRoQm9keUVycm9yKHJlc3BvbnNlLCAyMDAsICdJbnRyb3NwZWN0aW9uIEVuZHBvaW50Jyk7XG4gICAgbGV0IGpzb247XG4gICAgaWYgKGdldENvbnRlbnRUeXBlKHJlc3BvbnNlKSA9PT0gJ2FwcGxpY2F0aW9uL3Rva2VuLWludHJvc3BlY3Rpb24rand0Jykge1xuICAgICAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgeyBjbGFpbXMsIGp3dCB9ID0gYXdhaXQgdmFsaWRhdGVKd3QoYXdhaXQgcmVzcG9uc2UudGV4dCgpLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC5pbnRyb3NwZWN0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGcsIGFzLmludHJvc3BlY3Rpb25fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCwgJ1JTMjU2JyksIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpLCBvcHRpb25zPy5bandlRGVjcnlwdF0pXG4gICAgICAgICAgICAudGhlbihjaGVja0p3dFR5cGUuYmluZCh1bmRlZmluZWQsICd0b2tlbi1pbnRyb3NwZWN0aW9uK2p3dCcpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgWydhdWQnLCAnaWF0JywgJ2lzcyddKSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcykpXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZUF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuY2xpZW50X2lkKSk7XG4gICAgICAgIGp3dFJlZnMuc2V0KHJlc3BvbnNlLCBqd3QpO1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChjbGFpbXMudG9rZW5faW50cm9zcGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgnSldUIFwidG9rZW5faW50cm9zcGVjdGlvblwiIGNsYWltIG11c3QgYmUgYSBKU09OIG9iamVjdCcsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgICAgICAgICBjbGFpbXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBqc29uID0gY2xhaW1zLnRva2VuX2ludHJvc3BlY3Rpb247XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAganNvbiA9IGF3YWl0IGdldFJlc3BvbnNlSnNvbkJvZHkocmVzcG9uc2UpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb24uYWN0aXZlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImFjdGl2ZVwiIHByb3BlcnR5IG11c3QgYmUgYSBib29sZWFuJywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICAgICAgYm9keToganNvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuYXN5bmMgZnVuY3Rpb24gandrc1JlcXVlc3QoYXMsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZUVuZHBvaW50KGFzLCAnandrc191cmknLCBmYWxzZSwgb3B0aW9ucz8uW2FsbG93SW5zZWN1cmVSZXF1ZXN0c10gIT09IHRydWUpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBoZWFkZXJzLmFwcGVuZCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2p3ay1zZXQranNvbicpO1xuICAgIHJldHVybiAob3B0aW9ucz8uW2N1c3RvbUZldGNoXSB8fCBmZXRjaCkodXJsLmhyZWYsIHtcbiAgICAgICAgYm9keTogdW5kZWZpbmVkLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHVybCwgb3B0aW9ucz8uc2lnbmFsKSxcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NKd2tzUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gSlNPTiBXZWIgS2V5IFNldCByZXNwb25zZSAodW5leHBlY3RlZCBIVFRQIHN0YXR1cyBjb2RlKScsIFJFU1BPTlNFX0lTX05PVF9DT05GT1JNLCByZXNwb25zZSk7XG4gICAgfVxuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCBnZXRSZXNwb25zZUpzb25Cb2R5KHJlc3BvbnNlLCAocmVzcG9uc2UpID0+IGFzc2VydENvbnRlbnRUeXBlcyhyZXNwb25zZSwgJ2FwcGxpY2F0aW9uL2pzb24nLCAnYXBwbGljYXRpb24vandrLXNldCtqc29uJykpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uLmtleXMpKSB7XG4gICAgICAgIHRocm93IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJrZXlzXCIgcHJvcGVydHkgbXVzdCBiZSBhbiBhcnJheScsIElOVkFMSURfUkVTUE9OU0UsIHsgYm9keToganNvbiB9KTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5wcm90b3R5cGUuZXZlcnkuY2FsbChqc29uLmtleXMsIGlzSnNvbk9iamVjdCkpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImtleXNcIiBwcm9wZXJ0eSBtZW1iZXJzIG11c3QgYmUgSldLIGZvcm1hdHRlZCBvYmplY3RzJywgSU5WQUxJRF9SRVNQT05TRSwgeyBib2R5OiBqc29uIH0pO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRlZChhbGcpIHtcbiAgICBzd2l0Y2ggKGFsZykge1xuICAgICAgICBjYXNlICdQUzI1Nic6XG4gICAgICAgIGNhc2UgJ0VTMjU2JzpcbiAgICAgICAgY2FzZSAnUlMyNTYnOlxuICAgICAgICBjYXNlICdQUzM4NCc6XG4gICAgICAgIGNhc2UgJ0VTMzg0JzpcbiAgICAgICAgY2FzZSAnUlMzODQnOlxuICAgICAgICBjYXNlICdQUzUxMic6XG4gICAgICAgIGNhc2UgJ0VTNTEyJzpcbiAgICAgICAgY2FzZSAnUlM1MTInOlxuICAgICAgICBjYXNlICdFZDI1NTE5JzpcbiAgICAgICAgY2FzZSAnRWREU0EnOlxuICAgICAgICBjYXNlICdNTC1EU0EtNDQnOlxuICAgICAgICBjYXNlICdNTC1EU0EtNjUnOlxuICAgICAgICBjYXNlICdNTC1EU0EtODcnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tTdXBwb3J0ZWRKd3NBbGcoaGVhZGVyKSB7XG4gICAgaWYgKCFzdXBwb3J0ZWQoaGVhZGVyLmFsZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIEpXUyBcImFsZ1wiIGlkZW50aWZpZXInLCB7XG4gICAgICAgICAgICBjYXVzZTogeyBhbGc6IGhlYWRlci5hbGcgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tSc2FLZXlBbGdvcml0aG0oa2V5KSB7XG4gICAgY29uc3QgeyBhbGdvcml0aG0gfSA9IGtleTtcbiAgICBpZiAodHlwZW9mIGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA8IDIwNDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoYHVuc3VwcG9ydGVkICR7YWxnb3JpdGhtLm5hbWV9IG1vZHVsdXNMZW5ndGhgLCB7XG4gICAgICAgICAgICBjYXVzZToga2V5LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBlY2RzYUhhc2hOYW1lKGtleSkge1xuICAgIGNvbnN0IHsgYWxnb3JpdGhtIH0gPSBrZXk7XG4gICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZWRDdXJ2ZSkge1xuICAgICAgICBjYXNlICdQLTI1Nic6XG4gICAgICAgICAgICByZXR1cm4gJ1NIQS0yNTYnO1xuICAgICAgICBjYXNlICdQLTM4NCc6XG4gICAgICAgICAgICByZXR1cm4gJ1NIQS0zODQnO1xuICAgICAgICBjYXNlICdQLTUyMSc6XG4gICAgICAgICAgICByZXR1cm4gJ1NIQS01MTInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIEVDRFNBIG5hbWVkQ3VydmUnLCB7IGNhdXNlOiBrZXkgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5VG9TdWJ0bGUoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnRUNEU0EnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBrZXkuYWxnb3JpdGhtLm5hbWUsXG4gICAgICAgICAgICAgICAgaGFzaDogZWNkc2FIYXNoTmFtZShrZXkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnUlNBLVBTUyc6IHtcbiAgICAgICAgICAgIGNoZWNrUnNhS2V5QWxnb3JpdGhtKGtleSk7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0uaGFzaC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnU0hBLTI1Nic6XG4gICAgICAgICAgICAgICAgY2FzZSAnU0hBLTM4NCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnU0hBLTUxMic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrZXkuYWxnb3JpdGhtLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzYWx0TGVuZ3RoOiBwYXJzZUludChrZXkuYWxnb3JpdGhtLmhhc2gubmFtZS5zbGljZSgtMyksIDEwKSA+PiAzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBSU0EtUFNTIGhhc2ggbmFtZScsIHsgY2F1c2U6IGtleSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlICdSU0FTU0EtUEtDUzEtdjFfNSc6XG4gICAgICAgICAgICBjaGVja1JzYUtleUFsZ29yaXRobShrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGtleS5hbGdvcml0aG0ubmFtZTtcbiAgICAgICAgY2FzZSAnTUwtRFNBLTQ0JzpcbiAgICAgICAgY2FzZSAnTUwtRFNBLTY1JzpcbiAgICAgICAgY2FzZSAnTUwtRFNBLTg3JzpcbiAgICAgICAgY2FzZSAnRWQyNTUxOSc6XG4gICAgICAgICAgICByZXR1cm4ga2V5LmFsZ29yaXRobS5uYW1lO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgQ3J5cHRvS2V5IGFsZ29yaXRobSBuYW1lJywgeyBjYXVzZToga2V5IH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVKd3NTaWduYXR1cmUocHJvdGVjdGVkSGVhZGVyLCBwYXlsb2FkLCBrZXksIHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IGRhdGEgPSBidWYoYCR7cHJvdGVjdGVkSGVhZGVyfS4ke3BheWxvYWR9YCk7XG4gICAgY29uc3QgYWxnb3JpdGhtID0ga2V5VG9TdWJ0bGUoa2V5KTtcbiAgICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUudmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpO1xuICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdKV1Qgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgYWxnb3JpdGhtLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUp3dChqd3MsIGNoZWNrQWxnLCBjbG9ja1NrZXcsIGNsb2NrVG9sZXJhbmNlLCBkZWNyeXB0Snd0KSB7XG4gICAgbGV0IHsgMDogcHJvdGVjdGVkSGVhZGVyLCAxOiBwYXlsb2FkLCBsZW5ndGggfSA9IGp3cy5zcGxpdCgnLicpO1xuICAgIGlmIChsZW5ndGggPT09IDUpIHtcbiAgICAgICAgaWYgKGRlY3J5cHRKd3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgandzID0gYXdhaXQgZGVjcnlwdEp3dChqd3MpO1xuICAgICAgICAgICAgKHsgMDogcHJvdGVjdGVkSGVhZGVyLCAxOiBwYXlsb2FkLCBsZW5ndGggfSA9IGp3cy5zcGxpdCgnLicpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCdKV0UgZGVjcnlwdGlvbiBpcyBub3QgY29uZmlndXJlZCcsIHsgY2F1c2U6IGp3cyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IE9QRSgnSW52YWxpZCBKV1QnLCBJTlZBTElEX1JFU1BPTlNFLCBqd3MpO1xuICAgIH1cbiAgICBsZXQgaGVhZGVyO1xuICAgIHRyeSB7XG4gICAgICAgIGhlYWRlciA9IEpTT04ucGFyc2UoYnVmKGI2NHUocHJvdGVjdGVkSGVhZGVyKSkpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdmYWlsZWQgdG8gcGFyc2UgSldUIEhlYWRlciBib2R5IGFzIGJhc2U2NHVybCBlbmNvZGVkIEpTT04nLCBQQVJTRV9FUlJPUiwgY2F1c2UpO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChoZWFkZXIpKSB7XG4gICAgICAgIHRocm93IE9QRSgnSldUIEhlYWRlciBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcsIElOVkFMSURfUkVTUE9OU0UsIGp3cyk7XG4gICAgfVxuICAgIGNoZWNrQWxnKGhlYWRlcik7XG4gICAgaWYgKGhlYWRlci5jcml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ25vIEpXVCBcImNyaXRcIiBoZWFkZXIgcGFyYW1ldGVyIGV4dGVuc2lvbnMgYXJlIHN1cHBvcnRlZCcsIHtcbiAgICAgICAgICAgIGNhdXNlOiB7IGhlYWRlciB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGNsYWltcztcbiAgICB0cnkge1xuICAgICAgICBjbGFpbXMgPSBKU09OLnBhcnNlKGJ1ZihiNjR1KHBheWxvYWQpKSk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBKV1QgUGF5bG9hZCBib2R5IGFzIGJhc2U2NHVybCBlbmNvZGVkIEpTT04nLCBQQVJTRV9FUlJPUiwgY2F1c2UpO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChjbGFpbXMpKSB7XG4gICAgICAgIHRocm93IE9QRSgnSldUIFBheWxvYWQgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnLCBJTlZBTElEX1JFU1BPTlNFLCBqd3MpO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGNsb2NrU2tldztcbiAgICBpZiAoY2xhaW1zLmV4cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zLmV4cCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBKV1QgXCJleHBcIiAoZXhwaXJhdGlvbiB0aW1lKSBjbGFpbSB0eXBlJywgSU5WQUxJRF9SRVNQT05TRSwgeyBjbGFpbXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYWltcy5leHAgPD0gbm93IC0gY2xvY2tUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBKV1QgXCJleHBcIiAoZXhwaXJhdGlvbiB0aW1lKSBjbGFpbSB2YWx1ZSwgZXhwaXJhdGlvbiBpcyBwYXN0IGN1cnJlbnQgdGltZXN0YW1wJywgSldUX1RJTUVTVEFNUF9DSEVDSywgeyBjbGFpbXMsIG5vdywgdG9sZXJhbmNlOiBjbG9ja1RvbGVyYW5jZSwgY2xhaW06ICdleHAnIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGFpbXMuaWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMuaWF0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImlhdFwiIChpc3N1ZWQgYXQpIGNsYWltIHR5cGUnLCBJTlZBTElEX1JFU1BPTlNFLCB7IGNsYWltcyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xhaW1zLmlzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zLmlzcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBKV1QgXCJpc3NcIiAoaXNzdWVyKSBjbGFpbSB0eXBlJywgSU5WQUxJRF9SRVNQT05TRSwgeyBjbGFpbXMgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsYWltcy5uYmYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltcy5uYmYgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwibmJmXCIgKG5vdCBiZWZvcmUpIGNsYWltIHR5cGUnLCBJTlZBTElEX1JFU1BPTlNFLCB7IGNsYWltcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhaW1zLm5iZiA+IG5vdyArIGNsb2NrVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwibmJmXCIgKG5vdCBiZWZvcmUpIGNsYWltIHZhbHVlJywgSldUX1RJTUVTVEFNUF9DSEVDSywge1xuICAgICAgICAgICAgICAgIGNsYWltcyxcbiAgICAgICAgICAgICAgICBub3csXG4gICAgICAgICAgICAgICAgdG9sZXJhbmNlOiBjbG9ja1RvbGVyYW5jZSxcbiAgICAgICAgICAgICAgICBjbGFpbTogJ25iZicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xhaW1zLmF1ZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zLmF1ZCAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoY2xhaW1zLmF1ZCkpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIHR5cGUnLCBJTlZBTElEX1JFU1BPTlNFLCB7IGNsYWltcyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBoZWFkZXIsIGNsYWltcywgand0OiBqd3MgfTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUp3dEF1dGhSZXNwb25zZShhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZFN0YXRlLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmIChwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzLnNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgaWYgKCEocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicGFyYW1ldGVyc1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMU2VhcmNoUGFyYW1zLCBvciBVUkwnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdyZXNwb25zZScpO1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInBhcmFtZXRlcnNcIiBkb2VzIG5vdCBjb250YWluIGEgSkFSTSByZXNwb25zZScsIElOVkFMSURfUkVTUE9OU0UpO1xuICAgIH1cbiAgICBjb25zdCB7IGNsYWltcywgaGVhZGVyLCBqd3QgfSA9IGF3YWl0IHZhbGlkYXRlSnd0KHJlc3BvbnNlLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC5hdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGcsIGFzLmF1dGhvcml6YXRpb25fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCwgJ1JTMjU2JyksIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpLCBvcHRpb25zPy5bandlRGVjcnlwdF0pXG4gICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIFsnYXVkJywgJ2V4cCcsICdpc3MnXSkpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcykpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGNsaWVudC5jbGllbnRfaWQpKTtcbiAgICBjb25zdCB7IDA6IHByb3RlY3RlZEhlYWRlciwgMTogcGF5bG9hZCwgMjogZW5jb2RlZFNpZ25hdHVyZSB9ID0gand0LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYjY0dShlbmNvZGVkU2lnbmF0dXJlKTtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaShhcywgb3B0aW9ucywgaGVhZGVyKTtcbiAgICBhd2FpdCB2YWxpZGF0ZUp3c1NpZ25hdHVyZShwcm90ZWN0ZWRIZWFkZXIsIHBheWxvYWQsIGtleSwgc2lnbmF0dXJlKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY2xhaW1zKSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBrZXkgIT09ICdhdWQnKSB7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZUF1dGhSZXNwb25zZShhcywgY2xpZW50LCByZXN1bHQsIGV4cGVjdGVkU3RhdGUpO1xufVxuYXN5bmMgZnVuY3Rpb24gaWRUb2tlbkhhc2goZGF0YSwgaGVhZGVyLCBjbGFpbU5hbWUpIHtcbiAgICBsZXQgYWxnb3JpdGhtO1xuICAgIHN3aXRjaCAoaGVhZGVyLmFsZykge1xuICAgICAgICBjYXNlICdSUzI1Nic6XG4gICAgICAgIGNhc2UgJ1BTMjU2JzpcbiAgICAgICAgY2FzZSAnRVMyNTYnOlxuICAgICAgICAgICAgYWxnb3JpdGhtID0gJ1NIQS0yNTYnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1JTMzg0JzpcbiAgICAgICAgY2FzZSAnUFMzODQnOlxuICAgICAgICBjYXNlICdFUzM4NCc6XG4gICAgICAgICAgICBhbGdvcml0aG0gPSAnU0hBLTM4NCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUlM1MTInOlxuICAgICAgICBjYXNlICdQUzUxMic6XG4gICAgICAgIGNhc2UgJ0VTNTEyJzpcbiAgICAgICAgY2FzZSAnRWQyNTUxOSc6XG4gICAgICAgIGNhc2UgJ0VkRFNBJzpcbiAgICAgICAgICAgIGFsZ29yaXRobSA9ICdTSEEtNTEyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNTC1EU0EtNDQnOlxuICAgICAgICBjYXNlICdNTC1EU0EtNjUnOlxuICAgICAgICBjYXNlICdNTC1EU0EtODcnOlxuICAgICAgICAgICAgYWxnb3JpdGhtID0geyBuYW1lOiAnY1NIQUtFMjU2JywgbGVuZ3RoOiA1MTIgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoYHVuc3VwcG9ydGVkIEpXUyBhbGdvcml0aG0gZm9yICR7Y2xhaW1OYW1lfSBjYWxjdWxhdGlvbmAsIHsgY2F1c2U6IHsgYWxnOiBoZWFkZXIuYWxnIH0gfSk7XG4gICAgfVxuICAgIGNvbnN0IGRpZ2VzdCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KGFsZ29yaXRobSwgYnVmKGRhdGEpKTtcbiAgICByZXR1cm4gYjY0dShkaWdlc3Quc2xpY2UoMCwgZGlnZXN0LmJ5dGVMZW5ndGggLyAyKSk7XG59XG5hc3luYyBmdW5jdGlvbiBpZFRva2VuSGFzaE1hdGNoZXMoZGF0YSwgYWN0dWFsLCBoZWFkZXIsIGNsYWltTmFtZSkge1xuICAgIGNvbnN0IGV4cGVjdGVkID0gYXdhaXQgaWRUb2tlbkhhc2goZGF0YSwgaGVhZGVyLCBjbGFpbU5hbWUpO1xuICAgIHJldHVybiBhY3R1YWwgPT09IGV4cGVjdGVkO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlRGV0YWNoZWRTaWduYXR1cmVSZXNwb25zZShhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZE5vbmNlLCBleHBlY3RlZFN0YXRlLCBtYXhBZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVIeWJyaWRSZXNwb25zZShhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZE5vbmNlLCBleHBlY3RlZFN0YXRlLCBtYXhBZ2UsIG9wdGlvbnMsIHRydWUpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlQ29kZUlkVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZE5vbmNlLCBleHBlY3RlZFN0YXRlLCBtYXhBZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVIeWJyaWRSZXNwb25zZShhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZE5vbmNlLCBleHBlY3RlZFN0YXRlLCBtYXhBZ2UsIG9wdGlvbnMsIGZhbHNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVTdHJlYW0ocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdmb3JtX3Bvc3QgUmVxdWVzdCBpbnN0YW5jZXMgbXVzdCBjb250YWluIGEgcmVhZGFibGUgYm9keScsIEVSUl9JTlZBTElEX0FSR19WQUxVRSwgeyBjYXVzZTogcmVxdWVzdCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3QudGV4dCgpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZvcm1Qb3N0UmVzcG9uc2UocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ1BPU1QnKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdmb3JtX3Bvc3QgcmVzcG9uc2VzIGFyZSBleHBlY3RlZCB0byB1c2UgdGhlIFBPU1QgbWV0aG9kJywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFLCB7IGNhdXNlOiByZXF1ZXN0IH0pO1xuICAgIH1cbiAgICBpZiAoZ2V0Q29udGVudFR5cGUocmVxdWVzdCkgIT09ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdmb3JtX3Bvc3QgcmVzcG9uc2VzIGFyZSBleHBlY3RlZCB0byB1c2UgdGhlIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBjb250ZW50LXR5cGUnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUsIHsgY2F1c2U6IHJlcXVlc3QgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb25zdW1lU3RyZWFtKHJlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVIeWJyaWRSZXNwb25zZShhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZE5vbmNlLCBleHBlY3RlZFN0YXRlLCBtYXhBZ2UsIG9wdGlvbnMsIGZhcGkpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKHBhcmFtZXRlcnMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgaWYgKCFwYXJhbWV0ZXJzLmhhc2gubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJwYXJhbWV0ZXJzXCIgYXMgYW4gaW5zdGFuY2Ugb2YgVVJMIG11c3QgY29udGFpbiBhIGhhc2ggKGZyYWdtZW50KSB3aXRoIHRoZSBBdXRob3JpemF0aW9uIFJlc3BvbnNlIHBhcmFtZXRlcnMnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMuaGFzaC5zbGljZSgxKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvb3NlSW5zdGFuY2VPZihwYXJhbWV0ZXJzLCBSZXF1ZXN0KSkge1xuICAgICAgICBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhhd2FpdCBmb3JtUG9zdFJlc3BvbnNlKHBhcmFtZXRlcnMpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgICAgICBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcInBhcmFtZXRlcnNcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTFNlYXJjaFBhcmFtcywgVVJMLCBvciBSZXNwb25zZScsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgY29uc3QgaWRfdG9rZW4gPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2lkX3Rva2VuJyk7XG4gICAgcGFyYW1ldGVycy5kZWxldGUoJ2lkX3Rva2VuJyk7XG4gICAgc3dpdGNoIChleHBlY3RlZFN0YXRlKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlIGV4cGVjdE5vU3RhdGU6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGFzc2VydFN0cmluZyhleHBlY3RlZFN0YXRlLCAnXCJleHBlY3RlZFN0YXRlXCIgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGVBdXRoUmVzcG9uc2Uoe1xuICAgICAgICAuLi5hcyxcbiAgICAgICAgYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZDogZmFsc2UsXG4gICAgfSwgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZFN0YXRlKTtcbiAgICBpZiAoIWlkX3Rva2VuKSB7XG4gICAgICAgIHRocm93IE9QRSgnXCJwYXJhbWV0ZXJzXCIgZG9lcyBub3QgY29udGFpbiBhbiBJRCBUb2tlbicsIElOVkFMSURfUkVTUE9OU0UpO1xuICAgIH1cbiAgICBjb25zdCBjb2RlID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdjb2RlJyk7XG4gICAgaWYgKCFjb2RlKSB7XG4gICAgICAgIHRocm93IE9QRSgnXCJwYXJhbWV0ZXJzXCIgZG9lcyBub3QgY29udGFpbiBhbiBBdXRob3JpemF0aW9uIENvZGUnLCBJTlZBTElEX1JFU1BPTlNFKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWlyZWRDbGFpbXMgPSBbXG4gICAgICAgICdhdWQnLFxuICAgICAgICAnZXhwJyxcbiAgICAgICAgJ2lhdCcsXG4gICAgICAgICdpc3MnLFxuICAgICAgICAnc3ViJyxcbiAgICAgICAgJ25vbmNlJyxcbiAgICAgICAgJ2NfaGFzaCcsXG4gICAgXTtcbiAgICBjb25zdCBzdGF0ZSA9IHBhcmFtZXRlcnMuZ2V0KCdzdGF0ZScpO1xuICAgIGlmIChmYXBpICYmICh0eXBlb2YgZXhwZWN0ZWRTdGF0ZSA9PT0gJ3N0cmluZycgfHwgc3RhdGUgIT09IG51bGwpKSB7XG4gICAgICAgIHJlcXVpcmVkQ2xhaW1zLnB1c2goJ3NfaGFzaCcpO1xuICAgIH1cbiAgICBpZiAobWF4QWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKG1heEFnZSwgdHJ1ZSwgJ1wibWF4QWdlXCIgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2xpZW50LmRlZmF1bHRfbWF4X2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydE51bWJlcihjbGllbnQuZGVmYXVsdF9tYXhfYWdlLCB0cnVlLCAnXCJjbGllbnQuZGVmYXVsdF9tYXhfYWdlXCInKTtcbiAgICB9XG4gICAgbWF4QWdlID8/PSBjbGllbnQuZGVmYXVsdF9tYXhfYWdlID8/IHNraXBBdXRoVGltZUNoZWNrO1xuICAgIGlmIChjbGllbnQucmVxdWlyZV9hdXRoX3RpbWUgfHwgbWF4QWdlICE9PSBza2lwQXV0aFRpbWVDaGVjaykge1xuICAgICAgICByZXF1aXJlZENsYWltcy5wdXNoKCdhdXRoX3RpbWUnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjbGFpbXMsIGhlYWRlciwgand0IH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChpZF90b2tlbiwgY2hlY2tTaWduaW5nQWxnb3JpdGhtLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuaWRfdG9rZW5fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMuaWRfdG9rZW5fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCwgJ1JTMjU2JyksIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpLCBvcHRpb25zPy5bandlRGVjcnlwdF0pXG4gICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIHJlcXVpcmVkQ2xhaW1zKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVJc3N1ZXIuYmluZCh1bmRlZmluZWQsIGFzKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmNsaWVudF9pZCkpO1xuICAgIGNvbnN0IGNsb2NrU2tldyA9IGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgY2xvY2tTa2V3O1xuICAgIGlmIChjbGFpbXMuaWF0IDwgbm93IC0gMzYwMCkge1xuICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiaWF0XCIgKGlzc3VlZCBhdCkgY2xhaW0gdmFsdWUsIGl0IGlzIHRvbyBmYXIgaW4gdGhlIHBhc3QnLCBKV1RfVElNRVNUQU1QX0NIRUNLLCB7IG5vdywgY2xhaW1zLCBjbGFpbTogJ2lhdCcgfSk7XG4gICAgfVxuICAgIGFzc2VydFN0cmluZyhjbGFpbXMuY19oYXNoLCAnSUQgVG9rZW4gXCJjX2hhc2hcIiAoY29kZSBoYXNoKSBjbGFpbSB2YWx1ZScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgY2xhaW1zLFxuICAgIH0pO1xuICAgIGlmIChjbGFpbXMuYXV0aF90aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGNsYWltcy5hdXRoX3RpbWUsIHRydWUsICdJRCBUb2tlbiBcImF1dGhfdGltZVwiIChhdXRoZW50aWNhdGlvbiB0aW1lKScsIElOVkFMSURfUkVTUE9OU0UsIHsgY2xhaW1zIH0pO1xuICAgIH1cbiAgICBpZiAobWF4QWdlICE9PSBza2lwQXV0aFRpbWVDaGVjaykge1xuICAgICAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgICAgICBjb25zdCB0b2xlcmFuY2UgPSBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpO1xuICAgICAgICBpZiAoY2xhaW1zLmF1dGhfdGltZSArIG1heEFnZSA8IG5vdyAtIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCd0b28gbXVjaCB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IEVuZC1Vc2VyIGF1dGhlbnRpY2F0aW9uJywgSldUX1RJTUVTVEFNUF9DSEVDSywgeyBjbGFpbXMsIG5vdywgdG9sZXJhbmNlLCBjbGFpbTogJ2F1dGhfdGltZScgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0U3RyaW5nKGV4cGVjdGVkTm9uY2UsICdcImV4cGVjdGVkTm9uY2VcIiBhcmd1bWVudCcpO1xuICAgIGlmIChjbGFpbXMubm9uY2UgIT09IGV4cGVjdGVkTm9uY2UpIHtcbiAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwibm9uY2VcIiBjbGFpbSB2YWx1ZScsIEpXVF9DTEFJTV9DT01QQVJJU09OLCB7XG4gICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWROb25jZSxcbiAgICAgICAgICAgIGNsYWltcyxcbiAgICAgICAgICAgIGNsYWltOiAnbm9uY2UnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2xhaW1zLmF1ZCkgJiYgY2xhaW1zLmF1ZC5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgaWYgKGNsYWltcy5henAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCdJRCBUb2tlbiBcImF1ZFwiIChhdWRpZW5jZSkgY2xhaW0gaW5jbHVkZXMgYWRkaXRpb25hbCB1bnRydXN0ZWQgYXVkaWVuY2VzJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHsgY2xhaW1zLCBjbGFpbTogJ2F1ZCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYWltcy5henAgIT09IGNsaWVudC5jbGllbnRfaWQpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBJRCBUb2tlbiBcImF6cFwiIChhdXRob3JpemVkIHBhcnR5KSBjbGFpbSB2YWx1ZScsIEpXVF9DTEFJTV9DT01QQVJJU09OLCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGNsaWVudC5jbGllbnRfaWQsXG4gICAgICAgICAgICAgICAgY2xhaW1zLFxuICAgICAgICAgICAgICAgIGNsYWltOiAnYXpwJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgMDogcHJvdGVjdGVkSGVhZGVyLCAxOiBwYXlsb2FkLCAyOiBlbmNvZGVkU2lnbmF0dXJlIH0gPSBqd3Quc3BsaXQoJy4nKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBiNjR1KGVuY29kZWRTaWduYXR1cmUpO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpKGFzLCBvcHRpb25zLCBoZWFkZXIpO1xuICAgIGF3YWl0IHZhbGlkYXRlSndzU2lnbmF0dXJlKHByb3RlY3RlZEhlYWRlciwgcGF5bG9hZCwga2V5LCBzaWduYXR1cmUpO1xuICAgIGlmICgoYXdhaXQgaWRUb2tlbkhhc2hNYXRjaGVzKGNvZGUsIGNsYWltcy5jX2hhc2gsIGhlYWRlciwgJ2NfaGFzaCcpKSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBPUEUoJ2ludmFsaWQgSUQgVG9rZW4gXCJjX2hhc2hcIiAoY29kZSBoYXNoKSBjbGFpbSB2YWx1ZScsIEpXVF9DTEFJTV9DT01QQVJJU09OLCB7XG4gICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgYWxnOiBoZWFkZXIuYWxnLFxuICAgICAgICAgICAgY2xhaW06ICdjX2hhc2gnLFxuICAgICAgICAgICAgY2xhaW1zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKChmYXBpICYmIHN0YXRlICE9PSBudWxsKSB8fCBjbGFpbXMuc19oYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXNzZXJ0U3RyaW5nKGNsYWltcy5zX2hhc2gsICdJRCBUb2tlbiBcInNfaGFzaFwiIChzdGF0ZSBoYXNoKSBjbGFpbSB2YWx1ZScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgICAgIGNsYWltcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGFzc2VydFN0cmluZyhzdGF0ZSwgJ1wic3RhdGVcIiByZXNwb25zZSBwYXJhbWV0ZXInLCBJTlZBTElEX1JFU1BPTlNFLCB7IHBhcmFtZXRlcnMgfSk7XG4gICAgICAgIGlmICgoYXdhaXQgaWRUb2tlbkhhc2hNYXRjaGVzKHN0YXRlLCBjbGFpbXMuc19oYXNoLCBoZWFkZXIsICdzX2hhc2gnKSkgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgnaW52YWxpZCBJRCBUb2tlbiBcInNfaGFzaFwiIChzdGF0ZSBoYXNoKSBjbGFpbSB2YWx1ZScsIEpXVF9DTEFJTV9DT01QQVJJU09OLCB7XG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgYWxnOiBoZWFkZXIuYWxnLFxuICAgICAgICAgICAgICAgIGNsYWltOiAnc19oYXNoJyxcbiAgICAgICAgICAgICAgICBjbGFpbXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2hlY2tTaWduaW5nQWxnb3JpdGhtKGNsaWVudCwgaXNzdWVyLCBmYWxsYmFjaywgaGVhZGVyKSB7XG4gICAgaWYgKGNsaWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xpZW50ID09PSAnc3RyaW5nJyA/IGhlYWRlci5hbGcgIT09IGNsaWVudCA6ICFjbGllbnQuaW5jbHVkZXMoaGVhZGVyLmFsZykpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhbGdcIiBoZWFkZXIgcGFyYW1ldGVyJywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogY2xpZW50LFxuICAgICAgICAgICAgICAgIHJlYXNvbjogJ2NsaWVudCBjb25maWd1cmF0aW9uJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXNzdWVyKSkge1xuICAgICAgICBpZiAoIWlzc3Vlci5pbmNsdWRlcyhoZWFkZXIuYWxnKSkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImFsZ1wiIGhlYWRlciBwYXJhbWV0ZXInLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBpc3N1ZXIsXG4gICAgICAgICAgICAgICAgcmVhc29uOiAnYXV0aG9yaXphdGlvbiBzZXJ2ZXIgbWV0YWRhdGEnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZmFsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGZhbGxiYWNrID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBoZWFkZXIuYWxnICE9PSBmYWxsYmFja1xuICAgICAgICAgICAgOiB0eXBlb2YgZmFsbGJhY2sgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/ICFmYWxsYmFjayhoZWFkZXIuYWxnKVxuICAgICAgICAgICAgICAgIDogIWZhbGxiYWNrLmluY2x1ZGVzKGhlYWRlci5hbGcpKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiYWxnXCIgaGVhZGVyIHBhcmFtZXRlcicsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogJ2RlZmF1bHQgdmFsdWUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBPUEUoJ21pc3NpbmcgY2xpZW50IG9yIHNlcnZlciBjb25maWd1cmF0aW9uIHRvIHZlcmlmeSB1c2VkIEpXVCBcImFsZ1wiIGhlYWRlciBwYXJhbWV0ZXInLCB1bmRlZmluZWQsIHsgY2xpZW50LCBpc3N1ZXIsIGZhbGxiYWNrIH0pO1xufVxuZnVuY3Rpb24gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsIG5hbWUpIHtcbiAgICBjb25zdCB7IDA6IHZhbHVlLCBsZW5ndGggfSA9IHBhcmFtZXRlcnMuZ2V0QWxsKG5hbWUpO1xuICAgIGlmIChsZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IE9QRShgXCIke25hbWV9XCIgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWQgb25seSBvbmNlYCwgSU5WQUxJRF9SRVNQT05TRSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBjb25zdCBza2lwU3RhdGVDaGVjayA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGV4cGVjdE5vU3RhdGUgPSBTeW1ib2woKTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUF1dGhSZXNwb25zZShhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZFN0YXRlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmIChwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzLnNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgaWYgKCEocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicGFyYW1ldGVyc1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMU2VhcmNoUGFyYW1zLCBvciBVUkwnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGlmIChnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ3Jlc3BvbnNlJykpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInBhcmFtZXRlcnNcIiBjb250YWlucyBhIEpBUk0gcmVzcG9uc2UsIHVzZSB2YWxpZGF0ZUp3dEF1dGhSZXNwb25zZSgpIGluc3RlYWQgb2YgdmFsaWRhdGVBdXRoUmVzcG9uc2UoKScsIElOVkFMSURfUkVTUE9OU0UsIHsgcGFyYW1ldGVycyB9KTtcbiAgICB9XG4gICAgY29uc3QgaXNzID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdpc3MnKTtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnc3RhdGUnKTtcbiAgICBpZiAoIWlzcyAmJiBhcy5hdXRob3JpemF0aW9uX3Jlc3BvbnNlX2lzc19wYXJhbWV0ZXJfc3VwcG9ydGVkKSB7XG4gICAgICAgIHRocm93IE9QRSgncmVzcG9uc2UgcGFyYW1ldGVyIFwiaXNzXCIgKGlzc3VlcikgbWlzc2luZycsIElOVkFMSURfUkVTUE9OU0UsIHsgcGFyYW1ldGVycyB9KTtcbiAgICB9XG4gICAgaWYgKGlzcyAmJiBpc3MgIT09IGFzLmlzc3Vlcikge1xuICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgXCJpc3NcIiAoaXNzdWVyKSByZXNwb25zZSBwYXJhbWV0ZXIgdmFsdWUnLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgICAgICBleHBlY3RlZDogYXMuaXNzdWVyLFxuICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN3aXRjaCAoZXhwZWN0ZWRTdGF0ZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSBleHBlY3ROb1N0YXRlOlxuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgXCJzdGF0ZVwiIHJlc3BvbnNlIHBhcmFtZXRlciBlbmNvdW50ZXJlZCcsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHNraXBTdGF0ZUNoZWNrOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhc3NlcnRTdHJpbmcoZXhwZWN0ZWRTdGF0ZSwgJ1wiZXhwZWN0ZWRTdGF0ZVwiIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09IGV4cGVjdGVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBPUEUoc3RhdGUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/ICdyZXNwb25zZSBwYXJhbWV0ZXIgXCJzdGF0ZVwiIG1pc3NpbmcnXG4gICAgICAgICAgICAgICAgICAgIDogJ3VuZXhwZWN0ZWQgXCJzdGF0ZVwiIHJlc3BvbnNlIHBhcmFtZXRlciB2YWx1ZScsIElOVkFMSURfUkVTUE9OU0UsIHsgZXhwZWN0ZWQ6IGV4cGVjdGVkU3RhdGUsIHBhcmFtZXRlcnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdlcnJvcicpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aG9yaXphdGlvblJlc3BvbnNlRXJyb3IoJ2F1dGhvcml6YXRpb24gcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyIGlzIGFuIGVycm9yJywge1xuICAgICAgICAgICAgY2F1c2U6IHBhcmFtZXRlcnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBpZF90b2tlbiA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnaWRfdG9rZW4nKTtcbiAgICBjb25zdCB0b2tlbiA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAndG9rZW4nKTtcbiAgICBpZiAoaWRfdG9rZW4gIT09IHVuZGVmaW5lZCB8fCB0b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCdpbXBsaWNpdCBhbmQgaHlicmlkIGZsb3dzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBicmFuZChuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpKTtcbn1cbmZ1bmN0aW9uIGFsZ1RvU3VidGxlKGFsZykge1xuICAgIHN3aXRjaCAoYWxnKSB7XG4gICAgICAgIGNhc2UgJ1BTMjU2JzpcbiAgICAgICAgY2FzZSAnUFMzODQnOlxuICAgICAgICBjYXNlICdQUzUxMic6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiAnUlNBLVBTUycsIGhhc2g6IGBTSEEtJHthbGcuc2xpY2UoLTMpfWAgfTtcbiAgICAgICAgY2FzZSAnUlMyNTYnOlxuICAgICAgICBjYXNlICdSUzM4NCc6XG4gICAgICAgIGNhc2UgJ1JTNTEyJzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsIGhhc2g6IGBTSEEtJHthbGcuc2xpY2UoLTMpfWAgfTtcbiAgICAgICAgY2FzZSAnRVMyNTYnOlxuICAgICAgICBjYXNlICdFUzM4NCc6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiAnRUNEU0EnLCBuYW1lZEN1cnZlOiBgUC0ke2FsZy5zbGljZSgtMyl9YCB9O1xuICAgICAgICBjYXNlICdFUzUxMic6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiAnRUNEU0EnLCBuYW1lZEN1cnZlOiAnUC01MjEnIH07XG4gICAgICAgIGNhc2UgJ0VkRFNBJzpcbiAgICAgICAgICAgIHJldHVybiAnRWQyNTUxOSc7XG4gICAgICAgIGNhc2UgJ0VkMjU1MTknOlxuICAgICAgICBjYXNlICdNTC1EU0EtNDQnOlxuICAgICAgICBjYXNlICdNTC1EU0EtNjUnOlxuICAgICAgICBjYXNlICdNTC1EU0EtODcnOlxuICAgICAgICAgICAgcmV0dXJuIGFsZztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBKV1MgYWxnb3JpdGhtJywgeyBjYXVzZTogeyBhbGcgfSB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpbXBvcnRKd2soYWxnLCBqd2spIHtcbiAgICBjb25zdCB7IGV4dCwga2V5X29wcywgdXNlLCAuLi5rZXkgfSA9IGp3aztcbiAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ2p3aycsIGtleSwgYWxnVG9TdWJ0bGUoYWxnKSwgdHJ1ZSwgWyd2ZXJpZnknXSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV2aWNlQXV0aG9yaXphdGlvblJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZUVuZHBvaW50KGFzLCAnZGV2aWNlX2F1dGhvcml6YXRpb25fZW5kcG9pbnQnLCBjbGllbnQudXNlX210bHNfZW5kcG9pbnRfYWxpYXNlcywgb3B0aW9ucz8uW2FsbG93SW5zZWN1cmVSZXF1ZXN0c10gIT09IHRydWUpO1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCB1cmwsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NEZXZpY2VBdXRob3JpemF0aW9uUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGF3YWl0IGNoZWNrT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UsIDIwMCwgJ0RldmljZSBBdXRob3JpemF0aW9uIEVuZHBvaW50Jyk7XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGdldFJlc3BvbnNlSnNvbkJvZHkocmVzcG9uc2UpO1xuICAgIGFzc2VydFN0cmluZyhqc29uLmRldmljZV9jb2RlLCAnXCJyZXNwb25zZVwiIGJvZHkgXCJkZXZpY2VfY29kZVwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICBib2R5OiBqc29uLFxuICAgIH0pO1xuICAgIGFzc2VydFN0cmluZyhqc29uLnVzZXJfY29kZSwgJ1wicmVzcG9uc2VcIiBib2R5IFwidXNlcl9jb2RlXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgIGJvZHk6IGpzb24sXG4gICAgfSk7XG4gICAgYXNzZXJ0U3RyaW5nKGpzb24udmVyaWZpY2F0aW9uX3VyaSwgJ1wicmVzcG9uc2VcIiBib2R5IFwidmVyaWZpY2F0aW9uX3VyaVwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwgeyBib2R5OiBqc29uIH0pO1xuICAgIGxldCBleHBpcmVzSW4gPSB0eXBlb2YganNvbi5leHBpcmVzX2luICE9PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQoanNvbi5leHBpcmVzX2luKSA6IGpzb24uZXhwaXJlc19pbjtcbiAgICBhc3NlcnROdW1iZXIoZXhwaXJlc0luLCB0cnVlLCAnXCJyZXNwb25zZVwiIGJvZHkgXCJleHBpcmVzX2luXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgIGJvZHk6IGpzb24sXG4gICAgfSk7XG4gICAganNvbi5leHBpcmVzX2luID0gZXhwaXJlc0luO1xuICAgIGlmIChqc29uLnZlcmlmaWNhdGlvbl91cmlfY29tcGxldGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnRTdHJpbmcoanNvbi52ZXJpZmljYXRpb25fdXJpX2NvbXBsZXRlLCAnXCJyZXNwb25zZVwiIGJvZHkgXCJ2ZXJpZmljYXRpb25fdXJpX2NvbXBsZXRlXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7IGJvZHk6IGpzb24gfSk7XG4gICAgfVxuICAgIGlmIChqc29uLmludGVydmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGpzb24uaW50ZXJ2YWwsIGZhbHNlLCAnXCJyZXNwb25zZVwiIGJvZHkgXCJpbnRlcnZhbFwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICAgICAgYm9keToganNvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldmljZUNvZGVHcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIGRldmljZUNvZGUsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgYXNzZXJ0U3RyaW5nKGRldmljZUNvZGUsICdcImRldmljZUNvZGVcIicpO1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgnZGV2aWNlX2NvZGUnLCBkZXZpY2VDb2RlKTtcbiAgICByZXR1cm4gdG9rZW5FbmRwb2ludFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Z3JhbnQtdHlwZTpkZXZpY2VfY29kZScsIHBhcmFtZXRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NEZXZpY2VDb2RlUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCB1bmRlZmluZWQsIG9wdGlvbnM/Lltqd2VEZWNyeXB0XSwgb3B0aW9ucz8ucmVjb2duaXplZFRva2VuVHlwZXMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlS2V5UGFpcihhbGcsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRTdHJpbmcoYWxnLCAnXCJhbGdcIicpO1xuICAgIGNvbnN0IGFsZ29yaXRobSA9IGFsZ1RvU3VidGxlKGFsZyk7XG4gICAgaWYgKGFsZy5zdGFydHNXaXRoKCdQUycpIHx8IGFsZy5zdGFydHNXaXRoKCdSUycpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWxnb3JpdGhtLCB7XG4gICAgICAgICAgICBtb2R1bHVzTGVuZ3RoOiBvcHRpb25zPy5tb2R1bHVzTGVuZ3RoID8/IDIwNDgsXG4gICAgICAgICAgICBwdWJsaWNFeHBvbmVudDogbmV3IFVpbnQ4QXJyYXkoWzB4MDEsIDB4MDAsIDB4MDFdKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KGFsZ29yaXRobSwgb3B0aW9ucz8uZXh0cmFjdGFibGUgPz8gZmFsc2UsIFtcbiAgICAgICAgJ3NpZ24nLFxuICAgICAgICAndmVyaWZ5JyxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUh0dShodHUpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGh0dSk7XG4gICAgdXJsLnNlYXJjaCA9ICcnO1xuICAgIHVybC5oYXNoID0gJyc7XG4gICAgcmV0dXJuIHVybC5ocmVmO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVEUG9QKHJlcXVlc3QsIGFjY2Vzc1Rva2VuLCBhY2Nlc3NUb2tlbkNsYWltcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGhlYWRlclZhbHVlID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnZHBvcCcpO1xuICAgIGlmIChoZWFkZXJWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBPUEUoJ29wZXJhdGlvbiBpbmRpY2F0ZWQgRFBvUCB1c2UgYnV0IHRoZSByZXF1ZXN0IGhhcyBubyBEUG9QIEhUVFAgSGVhZGVyJywgSU5WQUxJRF9SRVFVRVNULCB7IGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyB9KTtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3QuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKT8udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdkcG9wICcpID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBPUEUoYG9wZXJhdGlvbiBpbmRpY2F0ZWQgRFBvUCB1c2UgYnV0IHRoZSByZXF1ZXN0J3MgQXV0aG9yaXphdGlvbiBIVFRQIEhlYWRlciBzY2hlbWUgaXMgbm90IERQb1BgLCBJTlZBTElEX1JFUVVFU1QsIHsgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjY2Vzc1Rva2VuQ2xhaW1zLmNuZj8uamt0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBPUEUoJ29wZXJhdGlvbiBpbmRpY2F0ZWQgRFBvUCB1c2UgYnV0IHRoZSBKV1QgQWNjZXNzIFRva2VuIGhhcyBubyBqa3QgY29uZmlybWF0aW9uIGNsYWltJywgSU5WQUxJRF9SRVFVRVNULCB7IGNsYWltczogYWNjZXNzVG9rZW5DbGFpbXMgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNsb2NrU2tldyA9IGdldENsb2NrU2tldyhvcHRpb25zKTtcbiAgICBjb25zdCBwcm9vZiA9IGF3YWl0IHZhbGlkYXRlSnd0KGhlYWRlclZhbHVlLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIG9wdGlvbnM/LnNpZ25pbmdBbGdvcml0aG1zLCB1bmRlZmluZWQsIHN1cHBvcnRlZCksIGNsb2NrU2tldywgZ2V0Q2xvY2tUb2xlcmFuY2Uob3B0aW9ucyksIHVuZGVmaW5lZClcbiAgICAgICAgLnRoZW4oY2hlY2tKd3RUeXBlLmJpbmQodW5kZWZpbmVkLCAnZHBvcCtqd3QnKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgWydpYXQnLCAnanRpJywgJ2F0aCcsICdodG0nLCAnaHR1J10pKTtcbiAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGNsb2NrU2tldztcbiAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMobm93IC0gcHJvb2YuY2xhaW1zLmlhdCk7XG4gICAgaWYgKGRpZmYgPiAzMDApIHtcbiAgICAgICAgdGhyb3cgT1BFKCdEUG9QIFByb29mIGlhdCBpcyBub3QgcmVjZW50IGVub3VnaCcsIEpXVF9USU1FU1RBTVBfQ0hFQ0ssIHtcbiAgICAgICAgICAgIG5vdyxcbiAgICAgICAgICAgIGNsYWltczogcHJvb2YuY2xhaW1zLFxuICAgICAgICAgICAgY2xhaW06ICdpYXQnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHByb29mLmNsYWltcy5odG0gIT09IHJlcXVlc3QubWV0aG9kKSB7XG4gICAgICAgIHRocm93IE9QRSgnRFBvUCBQcm9vZiBodG0gbWlzbWF0Y2gnLCBKV1RfQ0xBSU1fQ09NUEFSSVNPTiwge1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgY2xhaW1zOiBwcm9vZi5jbGFpbXMsXG4gICAgICAgICAgICBjbGFpbTogJ2h0bScsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb29mLmNsYWltcy5odHUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgIG5vcm1hbGl6ZUh0dShwcm9vZi5jbGFpbXMuaHR1KSAhPT0gbm9ybWFsaXplSHR1KHJlcXVlc3QudXJsKSkge1xuICAgICAgICB0aHJvdyBPUEUoJ0RQb1AgUHJvb2YgaHR1IG1pc21hdGNoJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBub3JtYWxpemVIdHUocmVxdWVzdC51cmwpLFxuICAgICAgICAgICAgY2xhaW1zOiBwcm9vZi5jbGFpbXMsXG4gICAgICAgICAgICBjbGFpbTogJ2h0dScsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkID0gYjY0dShhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGJ1ZihhY2Nlc3NUb2tlbikpKTtcbiAgICAgICAgaWYgKHByb29mLmNsYWltcy5hdGggIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoJ0RQb1AgUHJvb2YgYXRoIG1pc21hdGNoJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICBjbGFpbXM6IHByb29mLmNsYWltcyxcbiAgICAgICAgICAgICAgICBjbGFpbTogJ2F0aCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkID0gYXdhaXQgY2FsY3VsYXRlSndrVGh1bWJwcmludChwcm9vZi5oZWFkZXIuandrKTtcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuQ2xhaW1zLmNuZi5qa3QgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoJ0pXVCBBY2Nlc3MgVG9rZW4gY29uZmlybWF0aW9uIG1pc21hdGNoJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICBjbGFpbXM6IGFjY2Vzc1Rva2VuQ2xhaW1zLFxuICAgICAgICAgICAgICAgIGNsYWltOiAnY25mLmprdCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IDA6IHByb3RlY3RlZEhlYWRlciwgMTogcGF5bG9hZCwgMjogZW5jb2RlZFNpZ25hdHVyZSB9ID0gaGVhZGVyVmFsdWUuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBiNjR1KGVuY29kZWRTaWduYXR1cmUpO1xuICAgIGNvbnN0IHsgandrLCBhbGcgfSA9IHByb29mLmhlYWRlcjtcbiAgICBpZiAoIWp3aykge1xuICAgICAgICB0aHJvdyBPUEUoJ0RQb1AgUHJvb2YgaXMgbWlzc2luZyB0aGUgandrIGhlYWRlciBwYXJhbWV0ZXInLCBJTlZBTElEX1JFUVVFU1QsIHtcbiAgICAgICAgICAgIGhlYWRlcjogcHJvb2YuaGVhZGVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgaW1wb3J0SndrKGFsZywgandrKTtcbiAgICBpZiAoa2V5LnR5cGUgIT09ICdwdWJsaWMnKSB7XG4gICAgICAgIHRocm93IE9QRSgnRFBvUCBQcm9vZiBqd2sgaGVhZGVyIHBhcmFtZXRlciBtdXN0IGNvbnRhaW4gYSBwdWJsaWMga2V5JywgSU5WQUxJRF9SRVFVRVNULCB7XG4gICAgICAgICAgICBoZWFkZXI6IHByb29mLmhlYWRlcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF3YWl0IHZhbGlkYXRlSndzU2lnbmF0dXJlKHByb3RlY3RlZEhlYWRlciwgcGF5bG9hZCwga2V5LCBzaWduYXR1cmUpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlSnd0QWNjZXNzVG9rZW4oYXMsIHJlcXVlc3QsIGV4cGVjdGVkQXVkaWVuY2UsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVxdWVzdCwgUmVxdWVzdCkpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicmVxdWVzdFwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVxdWVzdCcsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgYXNzZXJ0U3RyaW5nKGV4cGVjdGVkQXVkaWVuY2UsICdcImV4cGVjdGVkQXVkaWVuY2VcIicpO1xuICAgIGNvbnN0IGF1dGhvcml6YXRpb24gPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdhdXRob3JpemF0aW9uJyk7XG4gICAgaWYgKGF1dGhvcml6YXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInJlcXVlc3RcIiBpcyBtaXNzaW5nIGFuIEF1dGhvcml6YXRpb24gSFRUUCBIZWFkZXInLCBJTlZBTElEX1JFUVVFU1QsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCB7IDA6IHNjaGVtZSwgMTogYWNjZXNzVG9rZW4sIGxlbmd0aCB9ID0gYXV0aG9yaXphdGlvbi5zcGxpdCgnICcpO1xuICAgIHNjaGVtZSA9IHNjaGVtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgICAgIGNhc2UgJ2Rwb3AnOlxuICAgICAgICBjYXNlICdiZWFyZXInOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgQXV0aG9yaXphdGlvbiBIVFRQIEhlYWRlciBzY2hlbWUnLCB7XG4gICAgICAgICAgICAgICAgY2F1c2U6IHsgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzIH0sXG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBPUEUoJ2ludmFsaWQgQXV0aG9yaXphdGlvbiBIVFRQIEhlYWRlciBmb3JtYXQnLCBJTlZBTElEX1JFUVVFU1QsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVpcmVkQ2xhaW1zID0gW1xuICAgICAgICAnaXNzJyxcbiAgICAgICAgJ2V4cCcsXG4gICAgICAgICdhdWQnLFxuICAgICAgICAnc3ViJyxcbiAgICAgICAgJ2lhdCcsXG4gICAgICAgICdqdGknLFxuICAgICAgICAnY2xpZW50X2lkJyxcbiAgICBdO1xuICAgIGlmIChvcHRpb25zPy5yZXF1aXJlRFBvUCB8fCBzY2hlbWUgPT09ICdkcG9wJyB8fCByZXF1ZXN0LmhlYWRlcnMuaGFzKCdkcG9wJykpIHtcbiAgICAgICAgcmVxdWlyZWRDbGFpbXMucHVzaCgnY25mJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2xhaW1zLCBoZWFkZXIgfSA9IGF3YWl0IHZhbGlkYXRlSnd0KGFjY2Vzc1Rva2VuLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIG9wdGlvbnM/LnNpZ25pbmdBbGdvcml0aG1zLCB1bmRlZmluZWQsIHN1cHBvcnRlZCksIGdldENsb2NrU2tldyhvcHRpb25zKSwgZ2V0Q2xvY2tUb2xlcmFuY2Uob3B0aW9ucyksIHVuZGVmaW5lZClcbiAgICAgICAgLnRoZW4oY2hlY2tKd3RUeXBlLmJpbmQodW5kZWZpbmVkLCAnYXQrand0JykpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIHJlcXVpcmVkQ2xhaW1zKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVJc3N1ZXIuYmluZCh1bmRlZmluZWQsIGFzKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgZXhwZWN0ZWRBdWRpZW5jZSkpXG4gICAgICAgIC5jYXRjaChyZWFzc2lnblJTQ29kZSk7XG4gICAgZm9yIChjb25zdCBjbGFpbSBvZiBbJ2NsaWVudF9pZCcsICdqdGknLCAnc3ViJ10pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXNbY2xhaW1dICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgT1BFKGB1bmV4cGVjdGVkIEpXVCBcIiR7Y2xhaW19XCIgY2xhaW0gdHlwZWAsIElOVkFMSURfUkVRVUVTVCwgeyBjbGFpbXMgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdjbmYnIGluIGNsYWltcykge1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChjbGFpbXMuY25mKSkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImNuZlwiIChjb25maXJtYXRpb24pIGNsYWltIHZhbHVlJywgSU5WQUxJRF9SRVFVRVNULCB7IGNsYWltcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IDA6IGNuZiwgbGVuZ3RoIH0gPSBPYmplY3Qua2V5cyhjbGFpbXMuY25mKTtcbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCdtdWx0aXBsZSBjb25maXJtYXRpb24gY2xhaW1zIGFyZSBub3Qgc3VwcG9ydGVkJywge1xuICAgICAgICAgICAgICAgICAgICBjYXVzZTogeyBjbGFpbXMgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbmYgIT09ICdqa3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIEpXVCBDb25maXJtYXRpb24gbWV0aG9kJywge1xuICAgICAgICAgICAgICAgICAgICBjYXVzZTogeyBjbGFpbXMgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IDA6IHByb3RlY3RlZEhlYWRlciwgMTogcGF5bG9hZCwgMjogZW5jb2RlZFNpZ25hdHVyZSB9ID0gYWNjZXNzVG9rZW4uc3BsaXQoJy4nKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBiNjR1KGVuY29kZWRTaWduYXR1cmUpO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpKGFzLCBvcHRpb25zLCBoZWFkZXIpO1xuICAgIGF3YWl0IHZhbGlkYXRlSndzU2lnbmF0dXJlKHByb3RlY3RlZEhlYWRlciwgcGF5bG9hZCwga2V5LCBzaWduYXR1cmUpO1xuICAgIGlmIChvcHRpb25zPy5yZXF1aXJlRFBvUCB8fFxuICAgICAgICBzY2hlbWUgPT09ICdkcG9wJyB8fFxuICAgICAgICBjbGFpbXMuY25mPy5qa3QgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuaGFzKCdkcG9wJykpIHtcbiAgICAgICAgYXdhaXQgdmFsaWRhdGVEUG9QKHJlcXVlc3QsIGFjY2Vzc1Rva2VuLCBjbGFpbXMsIG9wdGlvbnMpLmNhdGNoKHJlYXNzaWduUlNDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYWltcztcbn1cbmZ1bmN0aW9uIHJlYXNzaWduUlNDb2RlKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBPcGVyYXRpb25Qcm9jZXNzaW5nRXJyb3IgJiYgZXJyPy5jb2RlID09PSBJTlZBTElEX1JFUVVFU1QpIHtcbiAgICAgICAgZXJyLmNvZGUgPSBJTlZBTElEX1JFU1BPTlNFO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYmFja2NoYW5uZWxBdXRoZW50aWNhdGlvblJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZUVuZHBvaW50KGFzLCAnYmFja2NoYW5uZWxfYXV0aGVudGljYXRpb25fZW5kcG9pbnQnLCBjbGllbnQudXNlX210bHNfZW5kcG9pbnRfYWxpYXNlcywgb3B0aW9ucz8uW2FsbG93SW5zZWN1cmVSZXF1ZXN0c10gIT09IHRydWUpO1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCB1cmwsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NCYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGF3YWl0IGNoZWNrT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UsIDIwMCwgJ0JhY2tjaGFubmVsIEF1dGhlbnRpY2F0aW9uIEVuZHBvaW50Jyk7XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGdldFJlc3BvbnNlSnNvbkJvZHkocmVzcG9uc2UpO1xuICAgIGFzc2VydFN0cmluZyhqc29uLmF1dGhfcmVxX2lkLCAnXCJyZXNwb25zZVwiIGJvZHkgXCJhdXRoX3JlcV9pZFwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICBib2R5OiBqc29uLFxuICAgIH0pO1xuICAgIGxldCBleHBpcmVzSW4gPSB0eXBlb2YganNvbi5leHBpcmVzX2luICE9PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQoanNvbi5leHBpcmVzX2luKSA6IGpzb24uZXhwaXJlc19pbjtcbiAgICBhc3NlcnROdW1iZXIoZXhwaXJlc0luLCB0cnVlLCAnXCJyZXNwb25zZVwiIGJvZHkgXCJleHBpcmVzX2luXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgIGJvZHk6IGpzb24sXG4gICAgfSk7XG4gICAganNvbi5leHBpcmVzX2luID0gZXhwaXJlc0luO1xuICAgIGlmIChqc29uLmludGVydmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGpzb24uaW50ZXJ2YWwsIGZhbHNlLCAnXCJyZXNwb25zZVwiIGJvZHkgXCJpbnRlcnZhbFwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICAgICAgYm9keToganNvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJhY2tjaGFubmVsQXV0aGVudGljYXRpb25HcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIGF1dGhSZXFJZCwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBhc3NlcnRTdHJpbmcoYXV0aFJlcUlkLCAnXCJhdXRoUmVxSWRcIicpO1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgnYXV0aF9yZXFfaWQnLCBhdXRoUmVxSWQpO1xuICAgIHJldHVybiB0b2tlbkVuZHBvaW50UmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgJ3VybjpvcGVuaWQ6cGFyYW1zOmdyYW50LXR5cGU6Y2liYScsIHBhcmFtZXRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NCYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uR3JhbnRSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIHVuZGVmaW5lZCwgb3B0aW9ucz8uW2p3ZURlY3J5cHRdLCBvcHRpb25zPy5yZWNvZ25pemVkVG9rZW5UeXBlcyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZHluYW1pY0NsaWVudFJlZ2lzdHJhdGlvblJlcXVlc3QoYXMsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGNvbnN0IHVybCA9IHJlc29sdmVFbmRwb2ludChhcywgJ3JlZ2lzdHJhdGlvbl9lbmRwb2ludCcsIG1ldGFkYXRhLnVzZV9tdGxzX2VuZHBvaW50X2FsaWFzZXMsIG9wdGlvbnM/LlthbGxvd0luc2VjdXJlUmVxdWVzdHNdICE9PSB0cnVlKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgIGlmIChvcHRpb25zPy5EUG9QKSB7XG4gICAgICAgIGFzc2VydERQb1Aob3B0aW9ucy5EUG9QKTtcbiAgICAgICAgYXdhaXQgb3B0aW9ucy5EUG9QLmFkZFByb29mKHVybCwgaGVhZGVycywgbWV0aG9kLCBvcHRpb25zLmluaXRpYWxBY2Nlc3NUb2tlbik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5pbml0aWFsQWNjZXNzVG9rZW4pIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2F1dGhvcml6YXRpb24nLCBgJHtoZWFkZXJzLmhhcygnZHBvcCcpID8gJ0RQb1AnIDogJ0JlYXJlcid9ICR7b3B0aW9ucy5pbml0aWFsQWNjZXNzVG9rZW59YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKG9wdGlvbnM/LltjdXN0b21GZXRjaF0gfHwgZmV0Y2gpKHVybC5ocmVmLCB7XG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSxcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKGhlYWRlcnMuZW50cmllcygpKSxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHVybCwgb3B0aW9ucz8uc2lnbmFsKSxcbiAgICB9KTtcbiAgICBvcHRpb25zPy5EUG9QPy5jYWNoZU5vbmNlKHJlc3BvbnNlLCB1cmwpO1xuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRHluYW1pY0NsaWVudFJlZ2lzdHJhdGlvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGF3YWl0IGNoZWNrT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UsIDIwMSwgJ0R5bmFtaWMgQ2xpZW50IFJlZ2lzdHJhdGlvbiBFbmRwb2ludCcpO1xuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCBnZXRSZXNwb25zZUpzb25Cb2R5KHJlc3BvbnNlKTtcbiAgICBhc3NlcnRTdHJpbmcoanNvbi5jbGllbnRfaWQsICdcInJlc3BvbnNlXCIgYm9keSBcImNsaWVudF9pZFwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICBib2R5OiBqc29uLFxuICAgIH0pO1xuICAgIGlmIChqc29uLmNsaWVudF9zZWNyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnRTdHJpbmcoanNvbi5jbGllbnRfc2VjcmV0LCAnXCJyZXNwb25zZVwiIGJvZHkgXCJjbGllbnRfc2VjcmV0XCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgICAgICBib2R5OiBqc29uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGpzb24uY2xpZW50X3NlY3JldCkge1xuICAgICAgICBhc3NlcnROdW1iZXIoanNvbi5jbGllbnRfc2VjcmV0X2V4cGlyZXNfYXQsIHRydWUsICdcInJlc3BvbnNlXCIgYm9keSBcImNsaWVudF9zZWNyZXRfZXhwaXJlc19hdFwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICAgICAgYm9keToganNvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc291cmNlRGlzY292ZXJ5UmVxdWVzdChyZXNvdXJjZUlkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcGVyZm9ybURpc2NvdmVyeShyZXNvdXJjZUlkZW50aWZpZXIsICdyZXNvdXJjZUlkZW50aWZpZXInLCAodXJsKSA9PiB7XG4gICAgICAgIHByZXBlbmRXZWxsS25vd24odXJsLCAnLndlbGwta25vd24vb2F1dGgtcHJvdGVjdGVkLXJlc291cmNlJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfSwgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1Jlc291cmNlRGlzY292ZXJ5UmVzcG9uc2UoZXhwZWN0ZWRSZXNvdXJjZUlkZW50aWZpZXIsIHJlc3BvbnNlKSB7XG4gICAgY29uc3QgZXhwZWN0ZWQgPSBleHBlY3RlZFJlc291cmNlSWRlbnRpZmllcjtcbiAgICBpZiAoIShleHBlY3RlZCBpbnN0YW5jZW9mIFVSTCkgJiYgZXhwZWN0ZWQgIT09IF9ub2Rpc2NvdmVyeWNoZWNrKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcImV4cGVjdGVkUmVzb3VyY2VJZGVudGlmaWVyXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkwnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBSZXNvdXJjZSBTZXJ2ZXIgTWV0YWRhdGEgcmVzcG9uc2UgKHVuZXhwZWN0ZWQgSFRUUCBzdGF0dXMgY29kZSknLCBSRVNQT05TRV9JU19OT1RfQ09ORk9STSwgcmVzcG9uc2UpO1xuICAgIH1cbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgZ2V0UmVzcG9uc2VKc29uQm9keShyZXNwb25zZSk7XG4gICAgYXNzZXJ0U3RyaW5nKGpzb24ucmVzb3VyY2UsICdcInJlc3BvbnNlXCIgYm9keSBcInJlc291cmNlXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgIGJvZHk6IGpzb24sXG4gICAgfSk7XG4gICAgaWYgKGV4cGVjdGVkICE9PSBfbm9kaXNjb3ZlcnljaGVjayAmJiBuZXcgVVJMKGpzb24ucmVzb3VyY2UpLmhyZWYgIT09IGV4cGVjdGVkLmhyZWYpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInJlc291cmNlXCIgcHJvcGVydHkgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIHZhbHVlJywgSlNPTl9BVFRSSUJVVEVfQ09NUEFSSVNPTiwgeyBleHBlY3RlZDogZXhwZWN0ZWQuaHJlZiwgYm9keToganNvbiwgYXR0cmlidXRlOiAncmVzb3VyY2UnIH0pO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlSnNvbkJvZHkocmVzcG9uc2UsIGNoZWNrID0gYXNzZXJ0QXBwbGljYXRpb25Kc29uKSB7XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIGNoZWNrKHJlc3BvbnNlKTtcbiAgICAgICAgdGhyb3cgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIFBBUlNFX0VSUk9SLCBjYXVzZSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgIHRocm93IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnLCBJTlZBTElEX1JFU1BPTlNFLCB7IGJvZHk6IGpzb24gfSk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZXhwb3J0IGNvbnN0IF9ub3BrY2UgPSBub3BrY2U7XG5leHBvcnQgY29uc3QgX25vZGlzY292ZXJ5Y2hlY2sgPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBfZXhwZWN0ZWRJc3N1ZXIgPSBTeW1ib2woKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJVU0VSX0FHRU5UIiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwic3RhcnRzV2l0aCIsIk5BTUUiLCJWRVJTSU9OIiwibG9vc2VJbnN0YW5jZU9mIiwiaW5wdXQiLCJleHBlY3RlZCIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJwcm90b3R5cGUiLCJFUlJfSU5WQUxJRF9BUkdfVkFMVUUiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIkNvZGVkVHlwZUVycm9yIiwibWVzc2FnZSIsImNvZGUiLCJjYXVzZSIsImVyciIsIlR5cGVFcnJvciIsImFzc2lnbiIsImFsbG93SW5zZWN1cmVSZXF1ZXN0cyIsImNsb2NrU2tldyIsImNsb2NrVG9sZXJhbmNlIiwiY3VzdG9tRmV0Y2giLCJtb2RpZnlBc3NlcnRpb24iLCJqd2VEZWNyeXB0Iiwiandrc0NhY2hlIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiYnVmIiwiZW5jb2RlIiwiZGVjb2RlIiwiZW5jb2RlQmFzZTY0VXJsIiwiVWludDhBcnJheSIsInRvQmFzZTY0IiwiQXJyYXlCdWZmZXIiLCJhbHBoYWJldCIsIm9taXRQYWRkaW5nIiwiQ0hVTktfU0laRSIsImFyciIsImkiLCJieXRlTGVuZ3RoIiwicHVzaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5Iiwic3ViYXJyYXkiLCJidG9hIiwiam9pbiIsInJlcGxhY2UiLCJkZWNvZGVCYXNlNjRVcmwiLCJmcm9tQmFzZTY0IiwiYmluYXJ5IiwiYXRvYiIsImJ5dGVzIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImI2NHUiLCJVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJuYW1lIiwiVU5TVVBQT1JURURfT1BFUkFUSU9OIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJPcGVyYXRpb25Qcm9jZXNzaW5nRXJyb3IiLCJPUEUiLCJjYWxjdWxhdGVKd2tUaHVtYnByaW50IiwiandrIiwiY29tcG9uZW50cyIsImt0eSIsImNydiIsIngiLCJ5IiwiYWxnIiwicHViIiwiZSIsIm4iLCJjcnlwdG8iLCJzdWJ0bGUiLCJkaWdlc3QiLCJKU09OIiwic3RyaW5naWZ5IiwiYXNzZXJ0Q3J5cHRvS2V5Iiwia2V5IiwiaXQiLCJDcnlwdG9LZXkiLCJhc3NlcnRQcml2YXRlS2V5IiwidHlwZSIsImFzc2VydFB1YmxpY0tleSIsIm5vcm1hbGl6ZVR5cCIsInZhbHVlIiwidG9Mb3dlckNhc2UiLCJpc0pzb25PYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJwcmVwYXJlSGVhZGVycyIsIkhlYWRlcnMiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJoZWFkZXJzIiwiaGFzIiwic2V0Iiwic2lnbmFsIiwidXJsIiwidW5kZWZpbmVkIiwiaHJlZiIsIkFib3J0U2lnbmFsIiwicmVwbGFjZURvdWJsZVNsYXNoIiwicGF0aG5hbWUiLCJpbmNsdWRlcyIsInByZXBlbmRXZWxsS25vd24iLCJ3ZWxsS25vd24iLCJhbGxvd1Rlcm1pbmF0aW5nU2xhc2giLCJhcHBlbmRXZWxsS25vd24iLCJwZXJmb3JtRGlzY292ZXJ5IiwidXJsTmFtZSIsInRyYW5zZm9ybSIsIlVSTCIsImNoZWNrUHJvdG9jb2wiLCJmZXRjaCIsImJvZHkiLCJtZXRob2QiLCJyZWRpcmVjdCIsImRpc2NvdmVyeVJlcXVlc3QiLCJpc3N1ZXJJZGVudGlmaWVyIiwiYWxnb3JpdGhtIiwiYXNzZXJ0TnVtYmVyIiwiYWxsb3cwIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJhc3NlcnRTdHJpbmciLCJwcm9jZXNzRGlzY292ZXJ5UmVzcG9uc2UiLCJleHBlY3RlZElzc3VlcklkZW50aWZpZXIiLCJyZXNwb25zZSIsIl9ub2Rpc2NvdmVyeWNoZWNrIiwiUmVzcG9uc2UiLCJzdGF0dXMiLCJSRVNQT05TRV9JU19OT1RfQ09ORk9STSIsImFzc2VydFJlYWRhYmxlUmVzcG9uc2UiLCJqc29uIiwiZ2V0UmVzcG9uc2VKc29uQm9keSIsImlzc3VlciIsIklOVkFMSURfUkVTUE9OU0UiLCJKU09OX0FUVFJJQlVURV9DT01QQVJJU09OIiwiYXR0cmlidXRlIiwiYXNzZXJ0QXBwbGljYXRpb25Kc29uIiwiYXNzZXJ0Q29udGVudFR5cGUiLCJub3RKc29uIiwidHlwZXMiLCJtc2ciLCJsYXN0IiwicG9wIiwiUkVTUE9OU0VfSVNfTk9UX0pTT04iLCJhc3NlcnRDb250ZW50VHlwZXMiLCJnZXRDb250ZW50VHlwZSIsImNvbnRlbnRUeXBlIiwicmFuZG9tQnl0ZXMiLCJnZXRSYW5kb21WYWx1ZXMiLCJnZW5lcmF0ZVJhbmRvbUNvZGVWZXJpZmllciIsImdlbmVyYXRlUmFuZG9tU3RhdGUiLCJnZW5lcmF0ZVJhbmRvbU5vbmNlIiwiY2FsY3VsYXRlUEtDRUNvZGVDaGFsbGVuZ2UiLCJjb2RlVmVyaWZpZXIiLCJnZXRLZXlBbmRLaWQiLCJraWQiLCJwc0FsZyIsImhhc2giLCJyc0FsZyIsImVzQWxnIiwibmFtZWRDdXJ2ZSIsImtleVRvSndzIiwiZ2V0Q2xvY2tTa2V3IiwiY2xpZW50Iiwic2tldyIsImdldENsb2NrVG9sZXJhbmNlIiwidG9sZXJhbmNlIiwiTWF0aCIsInNpZ24iLCJlcG9jaFRpbWUiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJhc3NlcnRBcyIsImFzIiwiYXNzZXJ0Q2xpZW50IiwiY2xpZW50X2lkIiwiZm9ybVVybEVuY29kZSIsInRva2VuIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic3Vic3RyaW5nIiwidG9TdHJpbmciLCJ0b1VwcGVyQ2FzZSIsIkNsaWVudFNlY3JldFBvc3QiLCJjbGllbnRTZWNyZXQiLCJfYXMiLCJfaGVhZGVycyIsIkNsaWVudFNlY3JldEJhc2ljIiwiX2JvZHkiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiY3JlZGVudGlhbHMiLCJjbGllbnRBc3NlcnRpb25QYXlsb2FkIiwianRpIiwiYXVkIiwiZXhwIiwiaWF0IiwibmJmIiwiaXNzIiwic3ViIiwiUHJpdmF0ZUtleUp3dCIsImNsaWVudFByaXZhdGVLZXkiLCJoZWFkZXIiLCJwYXlsb2FkIiwic2lnbkp3dCIsIkNsaWVudFNlY3JldEp3dCIsIm1vZGlmeSIsImltcG9ydEtleSIsImRhdGEiLCJobWFjIiwiTm9uZSIsIlRsc0NsaWVudEF1dGgiLCJ1c2FnZXMiLCJzaWduYXR1cmUiLCJrZXlUb1N1YnRsZSIsImlzc3VlUmVxdWVzdE9iamVjdCIsInBhcmFtZXRlcnMiLCJwcml2YXRlS2V5IiwiVVJMU2VhcmNoUGFyYW1zIiwiY2xhaW1zIiwicmVzb3VyY2UiLCJnZXRBbGwiLCJnZXQiLCJtYXhfYWdlIiwicGFyc2VJbnQiLCJwYXJzZSIsIlBBUlNFX0VSUk9SIiwiYXV0aG9yaXphdGlvbl9kZXRhaWxzIiwidHlwIiwiandrQ2FjaGUiLCJnZXRTZXRQdWJsaWNKd2tDYWNoZSIsImV4cG9ydEtleSIsInB1YmxpY0p3ayIsIldlYWtNYXAiLCJVUkxQYXJzZSIsImJhc2UiLCJlbmZvcmNlSHR0cHMiLCJwcm90b2NvbCIsIkhUVFBfUkVRVUVTVF9GT1JCSURERU4iLCJSRVFVRVNUX1BST1RPQ09MX0ZPUkJJRERFTiIsInZhbGlkYXRlRW5kcG9pbnQiLCJlbmRwb2ludCIsInVzZU10bHNBbGlhcyIsIk1JU1NJTkdfU0VSVkVSX01FVEFEQVRBIiwiSU5WQUxJRF9TRVJWRVJfTUVUQURBVEEiLCJyZXNvbHZlRW5kcG9pbnQiLCJtdGxzX2VuZHBvaW50X2FsaWFzZXMiLCJwdXNoZWRBdXRob3JpemF0aW9uUmVxdWVzdCIsImNsaWVudEF1dGhlbnRpY2F0aW9uIiwidXNlX210bHNfZW5kcG9pbnRfYWxpYXNlcyIsIkRQb1AiLCJhc3NlcnREUG9QIiwiYWRkUHJvb2YiLCJhdXRoZW50aWNhdGVkUmVxdWVzdCIsImNhY2hlTm9uY2UiLCJEUG9QSGFuZGxlciIsInB1YmxpY0tleSIsIm1hcCIsImprdCIsImtleVBhaXIiLCJleHRyYWN0YWJsZSIsImJyYW5kZWQiLCJhZGQiLCJNYXAiLCJpdGVtIiwiZGVsZXRlIiwidmFsIiwic2l6ZSIsImtleXMiLCJuZXh0IiwiY2FsY3VsYXRlVGh1bWJwcmludCIsImh0bSIsImFjY2Vzc1Rva2VuIiwibm9uY2UiLCJvcmlnaW4iLCJodHUiLCJhdGgiLCJpc0RQb1BOb25jZUVycm9yIiwiV1dXQXV0aGVudGljYXRlQ2hhbGxlbmdlRXJyb3IiLCJjaGFsbGVuZ2UiLCJzY2hlbWUiLCJlcnJvciIsIlJlc3BvbnNlQm9keUVycm9yIiwiUkVTUE9OU0VfQk9EWV9FUlJPUiIsImVycm9yX2Rlc2NyaXB0aW9uIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiQXV0aG9yaXphdGlvblJlc3BvbnNlRXJyb3IiLCJBVVRIT1JJWkFUSU9OX1JFU1BPTlNFX0VSUk9SIiwiV1dXX0FVVEhFTlRJQ0FURV9DSEFMTEVOR0UiLCJ0b2tlbk1hdGNoIiwidG9rZW42OE1hdGNoIiwicXVvdGVkTWF0Y2giLCJxdW90ZWRQYXJhbU1hdGNoZXIiLCJwYXJhbU1hdGNoZXIiLCJzY2hlbWVSRSIsIlJlZ0V4cCIsInF1b3RlZFBhcmFtUkUiLCJ1bnF1b3RlZFBhcmFtUkUiLCJ0b2tlbjY4UGFyYW1SRSIsInBhcnNlV3d3QXV0aGVudGljYXRlQ2hhbGxlbmdlcyIsImNoYWxsZW5nZXMiLCJyZXN0IiwibWF0Y2giLCJ0b2tlbjY4IiwicHJvY2Vzc1B1c2hlZEF1dGhvcml6YXRpb25SZXNwb25zZSIsImNoZWNrT0F1dGhCb2R5RXJyb3IiLCJyZXF1ZXN0X3VyaSIsImV4cGlyZXNJbiIsImV4cGlyZXNfaW4iLCJwYXJzZUZsb2F0IiwicGFyc2VPQXV0aFJlc3BvbnNlRXJyb3JCb2R5IiwiY2xvbmUiLCJsYWJlbCIsImNoZWNrQXV0aGVudGljYXRpb25DaGFsbGVuZ2VzIiwiY2FuY2VsIiwib3B0aW9uIiwicmVzb3VyY2VSZXF1ZXN0IiwicHJvdGVjdGVkUmVzb3VyY2VSZXF1ZXN0IiwidXNlckluZm9SZXF1ZXN0IiwidXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsImFwcGVuZCIsImp3a3NNYXAiLCJzZXRKd2tzQ2FjaGUiLCJqd2tzIiwidWF0IiwiY2FjaGUiLCJhZ2UiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJpc0ZyZXNoSndrc0NhY2hlIiwiZXZlcnkiLCJjYWxsIiwiY2xlYXJKd2tzQ2FjaGUiLCJnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaSIsImNoZWNrU3VwcG9ydGVkSndzQWxnIiwiandrc1JlcXVlc3QiLCJ0aGVuIiwicHJvY2Vzc0p3a3NSZXNwb25zZSIsInNsaWNlIiwiY2FuZGlkYXRlcyIsImZpbHRlciIsInVzZSIsImtleV9vcHMiLCJLRVlfU0VMRUNUSU9OIiwiandrc191cmkiLCJpbXBvcnRKd2siLCJza2lwU3ViamVjdENoZWNrIiwic3BsaXQiLCJwcm9jZXNzVXNlckluZm9SZXNwb25zZSIsImV4cGVjdGVkU3ViamVjdCIsImp3dCIsInZhbGlkYXRlSnd0IiwidGV4dCIsImNoZWNrU2lnbmluZ0FsZ29yaXRobSIsImJpbmQiLCJ1c2VyaW5mb19zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwidmFsaWRhdGVPcHRpb25hbEF1ZGllbmNlIiwidmFsaWRhdGVPcHRpb25hbElzc3VlciIsImp3dFJlZnMiLCJKV1RfVVNFUklORk9fRVhQRUNURUQiLCJ0b2tlbkVuZHBvaW50UmVxdWVzdCIsImdyYW50VHlwZSIsInJlZnJlc2hUb2tlbkdyYW50UmVxdWVzdCIsInJlZnJlc2hUb2tlbiIsImFkZGl0aW9uYWxQYXJhbWV0ZXJzIiwiaWRUb2tlbkNsYWltcyIsImdldFZhbGlkYXRlZElkVG9rZW5DbGFpbXMiLCJyZWYiLCJpZF90b2tlbiIsInZhbGlkYXRlQXBwbGljYXRpb25MZXZlbFNpZ25hdHVyZSIsInByb3RlY3RlZEhlYWRlciIsImVuY29kZWRTaWduYXR1cmUiLCJ2YWxpZGF0ZUp3c1NpZ25hdHVyZSIsInByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZSIsImFkZGl0aW9uYWxSZXF1aXJlZElkVG9rZW5DbGFpbXMiLCJkZWNyeXB0Rm4iLCJyZWNvZ25pemVkVG9rZW5UeXBlcyIsImFjY2Vzc190b2tlbiIsInRva2VuX3R5cGUiLCJyZWZyZXNoX3Rva2VuIiwic2NvcGUiLCJyZXF1aXJlZENsYWltcyIsInJlcXVpcmVfYXV0aF90aW1lIiwiZGVmYXVsdF9tYXhfYWdlIiwiaWRfdG9rZW5fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsImlkX3Rva2VuX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJ2YWxpZGF0ZVByZXNlbmNlIiwidmFsaWRhdGVJc3N1ZXIiLCJ2YWxpZGF0ZUF1ZGllbmNlIiwiYXpwIiwiSldUX0NMQUlNX0NPTVBBUklTT04iLCJjbGFpbSIsImF1dGhfdGltZSIsInByb2Nlc3NSZWZyZXNoVG9rZW5SZXNwb25zZSIsInJlc3VsdCIsIl9leHBlY3RlZElzc3VlciIsIldlYWtTZXQiLCJicmFuZCIsInNlYXJjaFBhcmFtcyIsIm5vcGtjZSIsImF1dGhvcml6YXRpb25Db2RlR3JhbnRSZXF1ZXN0IiwiY2FsbGJhY2tQYXJhbWV0ZXJzIiwicmVkaXJlY3RVcmkiLCJnZXRVUkxTZWFyY2hQYXJhbWV0ZXIiLCJqd3RDbGFpbU5hbWVzIiwiY19oYXNoIiwic19oYXNoIiwiY25mIiwicmVxdWlyZWQiLCJleHBlY3ROb05vbmNlIiwic2tpcEF1dGhUaW1lQ2hlY2siLCJwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVSZXNwb25zZSIsImV4cGVjdGVkTm9uY2UiLCJtYXhBZ2UiLCJyZXF1aXJlSWRUb2tlbiIsInByb2Nlc3NBdXRob3JpemF0aW9uQ29kZU9wZW5JRFJlc3BvbnNlIiwicHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT0F1dGgyUmVzcG9uc2UiLCJhZGRpdGlvbmFsUmVxdWlyZWRDbGFpbXMiLCJKV1RfVElNRVNUQU1QX0NIRUNLIiwiSU5WQUxJRF9SRVFVRVNUIiwiY2hlY2tKd3RUeXBlIiwiY2xpZW50Q3JlZGVudGlhbHNHcmFudFJlcXVlc3QiLCJnZW5lcmljVG9rZW5FbmRwb2ludFJlcXVlc3QiLCJwcm9jZXNzR2VuZXJpY1Rva2VuRW5kcG9pbnRSZXNwb25zZSIsInByb2Nlc3NDbGllbnRDcmVkZW50aWFsc1Jlc3BvbnNlIiwicmV2b2NhdGlvblJlcXVlc3QiLCJwcm9jZXNzUmV2b2NhdGlvblJlc3BvbnNlIiwiYm9keVVzZWQiLCJpbnRyb3NwZWN0aW9uUmVxdWVzdCIsInJlcXVlc3RKd3RSZXNwb25zZSIsImludHJvc3BlY3Rpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsInByb2Nlc3NJbnRyb3NwZWN0aW9uUmVzcG9uc2UiLCJpbnRyb3NwZWN0aW9uX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJ0b2tlbl9pbnRyb3NwZWN0aW9uIiwiYWN0aXZlIiwic3VwcG9ydGVkIiwiY2hlY2tSc2FLZXlBbGdvcml0aG0iLCJtb2R1bHVzTGVuZ3RoIiwiZWNkc2FIYXNoTmFtZSIsInNhbHRMZW5ndGgiLCJ2ZXJpZmllZCIsInZlcmlmeSIsImp3cyIsImNoZWNrQWxnIiwiZGVjcnlwdEp3dCIsImNyaXQiLCJ2YWxpZGF0ZUp3dEF1dGhSZXNwb25zZSIsImV4cGVjdGVkU3RhdGUiLCJhdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGciLCJhdXRob3JpemF0aW9uX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJ2YWxpZGF0ZUF1dGhSZXNwb25zZSIsImlkVG9rZW5IYXNoIiwiY2xhaW1OYW1lIiwiaWRUb2tlbkhhc2hNYXRjaGVzIiwiYWN0dWFsIiwidmFsaWRhdGVEZXRhY2hlZFNpZ25hdHVyZVJlc3BvbnNlIiwidmFsaWRhdGVIeWJyaWRSZXNwb25zZSIsInZhbGlkYXRlQ29kZUlkVG9rZW5SZXNwb25zZSIsImNvbnN1bWVTdHJlYW0iLCJyZXF1ZXN0IiwiZm9ybVBvc3RSZXNwb25zZSIsImZhcGkiLCJSZXF1ZXN0IiwiZXhwZWN0Tm9TdGF0ZSIsImF1dGhvcml6YXRpb25fcmVzcG9uc2VfaXNzX3BhcmFtZXRlcl9zdXBwb3J0ZWQiLCJzdGF0ZSIsImZhbGxiYWNrIiwicmVhc29uIiwic2tpcFN0YXRlQ2hlY2siLCJhbGdUb1N1YnRsZSIsImV4dCIsImRldmljZUF1dGhvcml6YXRpb25SZXF1ZXN0IiwicHJvY2Vzc0RldmljZUF1dGhvcml6YXRpb25SZXNwb25zZSIsImRldmljZV9jb2RlIiwidXNlcl9jb2RlIiwidmVyaWZpY2F0aW9uX3VyaSIsInZlcmlmaWNhdGlvbl91cmlfY29tcGxldGUiLCJpbnRlcnZhbCIsImRldmljZUNvZGVHcmFudFJlcXVlc3QiLCJkZXZpY2VDb2RlIiwicHJvY2Vzc0RldmljZUNvZGVSZXNwb25zZSIsImdlbmVyYXRlS2V5UGFpciIsInB1YmxpY0V4cG9uZW50IiwiZ2VuZXJhdGVLZXkiLCJub3JtYWxpemVIdHUiLCJzZWFyY2giLCJ2YWxpZGF0ZURQb1AiLCJhY2Nlc3NUb2tlbkNsYWltcyIsImhlYWRlclZhbHVlIiwicHJvb2YiLCJzaWduaW5nQWxnb3JpdGhtcyIsImRpZmYiLCJhYnMiLCJ2YWxpZGF0ZUp3dEFjY2Vzc1Rva2VuIiwiZXhwZWN0ZWRBdWRpZW5jZSIsImF1dGhvcml6YXRpb24iLCJyZXF1aXJlRFBvUCIsImNhdGNoIiwicmVhc3NpZ25SU0NvZGUiLCJiYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uUmVxdWVzdCIsInByb2Nlc3NCYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UiLCJhdXRoX3JlcV9pZCIsImJhY2tjaGFubmVsQXV0aGVudGljYXRpb25HcmFudFJlcXVlc3QiLCJhdXRoUmVxSWQiLCJwcm9jZXNzQmFja2NoYW5uZWxBdXRoZW50aWNhdGlvbkdyYW50UmVzcG9uc2UiLCJkeW5hbWljQ2xpZW50UmVnaXN0cmF0aW9uUmVxdWVzdCIsIm1ldGFkYXRhIiwiaW5pdGlhbEFjY2Vzc1Rva2VuIiwicHJvY2Vzc0R5bmFtaWNDbGllbnRSZWdpc3RyYXRpb25SZXNwb25zZSIsImNsaWVudF9zZWNyZXQiLCJjbGllbnRfc2VjcmV0X2V4cGlyZXNfYXQiLCJyZXNvdXJjZURpc2NvdmVyeVJlcXVlc3QiLCJyZXNvdXJjZUlkZW50aWZpZXIiLCJwcm9jZXNzUmVzb3VyY2VEaXNjb3ZlcnlSZXNwb25zZSIsImV4cGVjdGVkUmVzb3VyY2VJZGVudGlmaWVyIiwiY2hlY2siLCJfbm9wa2NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/oauth4webapi/build/index.js\n");

/***/ })

};
;