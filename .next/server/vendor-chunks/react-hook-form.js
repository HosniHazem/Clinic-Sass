"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-hook-form";
exports.ids = ["vendor-chunks/react-hook-form"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-hook-form/dist/index.esm.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/react-hook-form/dist/index.esm.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Controller: () => (/* binding */ Controller),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   FormProvider: () => (/* binding */ FormProvider),\n/* harmony export */   Watch: () => (/* binding */ Watch),\n/* harmony export */   appendErrors: () => (/* binding */ appendErrors),\n/* harmony export */   createFormControl: () => (/* binding */ createFormControl),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   useController: () => (/* binding */ useController),\n/* harmony export */   useFieldArray: () => (/* binding */ useFieldArray),\n/* harmony export */   useForm: () => (/* binding */ useForm),\n/* harmony export */   useFormContext: () => (/* binding */ useFormContext),\n/* harmony export */   useFormState: () => (/* binding */ useFormState),\n/* harmony export */   useWatch: () => (/* binding */ useWatch)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nvar isCheckBoxInput = (element)=>element.type === \"checkbox\";\nvar isDateObject = (value1)=>value1 instanceof Date;\nvar isNullOrUndefined = (value1)=>value1 == null;\nconst isObjectType = (value1)=>typeof value1 === \"object\";\nvar isObject = (value1)=>!isNullOrUndefined(value1) && !Array.isArray(value1) && isObjectType(value1) && !isDateObject(value1);\nvar getEventValue = (event)=>isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;\nvar getNodeParentName = (name)=>name.substring(0, name.search(/\\.\\d+(\\.|$)/)) || name;\nvar isNameInFieldArray = (names, name)=>names.has(getNodeParentName(name));\nvar isPlainObject = (tempObject)=>{\n    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;\n    return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty(\"isPrototypeOf\");\n};\nvar isWeb =  false && 0;\nfunction cloneObject(data) {\n    let copy;\n    const isArray = Array.isArray(data);\n    const isFileListInstance = typeof FileList !== \"undefined\" ? data instanceof FileList : false;\n    if (data instanceof Date) {\n        copy = new Date(data);\n    } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray || isObject(data))) {\n        copy = isArray ? [] : Object.create(Object.getPrototypeOf(data));\n        if (!isArray && !isPlainObject(data)) {\n            copy = data;\n        } else {\n            for(const key in data){\n                if (data.hasOwnProperty(key)) {\n                    copy[key] = cloneObject(data[key]);\n                }\n            }\n        }\n    } else {\n        return data;\n    }\n    return copy;\n}\nvar isKey = (value1)=>/^\\w*$/.test(value1);\nvar isUndefined = (val)=>val === undefined;\nvar compact = (value1)=>Array.isArray(value1) ? value1.filter(Boolean) : [];\nvar stringToPath = (input)=>compact(input.replace(/[\"|']|\\]/g, \"\").split(/\\.|\\[/));\nvar get = (object, path, defaultValue)=>{\n    if (!path || !isObject(object)) {\n        return defaultValue;\n    }\n    const result = (isKey(path) ? [\n        path\n    ] : stringToPath(path)).reduce((result, key)=>isNullOrUndefined(result) ? result : result[key], object);\n    return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;\n};\nvar isBoolean = (value1)=>typeof value1 === \"boolean\";\nvar set = (object, path, value1)=>{\n    let index = -1;\n    const tempPath = isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const length = tempPath.length;\n    const lastIndex = length - 1;\n    while(++index < length){\n        const key = tempPath[index];\n        let newValue = value1;\n        if (index !== lastIndex) {\n            const objValue = object[key];\n            newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n        }\n        if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n            return;\n        }\n        object[key] = newValue;\n        object = object[key];\n    }\n};\nconst EVENTS = {\n    BLUR: \"blur\",\n    FOCUS_OUT: \"focusout\",\n    CHANGE: \"change\"\n};\nconst VALIDATION_MODE = {\n    onBlur: \"onBlur\",\n    onChange: \"onChange\",\n    onSubmit: \"onSubmit\",\n    onTouched: \"onTouched\",\n    all: \"all\"\n};\nconst INPUT_VALIDATION_RULES = {\n    max: \"max\",\n    min: \"min\",\n    maxLength: \"maxLength\",\n    minLength: \"minLength\",\n    pattern: \"pattern\",\n    required: \"required\",\n    validate: \"validate\"\n};\nconst HookFormContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nHookFormContext.displayName = \"HookFormContext\";\n/**\n * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @returns return all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const useFormContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(HookFormContext);\n/**\n * A provider component that propagates the `useForm` methods to all children components via [React Context](https://react.dev/reference/react/useContext) API. To be used with {@link useFormContext}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @param props - all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const FormProvider = (props)=>{\n    const { children, ...data } = props;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(HookFormContext.Provider, {\n        value: data\n    }, children);\n};\nvar getProxyFormState = (formState, control, localProxyFormState, isRoot = true)=>{\n    const result = {\n        defaultValues: control._defaultValues\n    };\n    for(const key in formState){\n        Object.defineProperty(result, key, {\n            get: ()=>{\n                const _key = key;\n                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {\n                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;\n                }\n                localProxyFormState && (localProxyFormState[_key] = true);\n                return formState[_key];\n            }\n        });\n    }\n    return result;\n};\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n/**\n * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformstate) • [Demo](https://codesandbox.io/s/useformstate-75xly)\n *\n * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, control } = useForm({\n *     defaultValues: {\n *     firstName: \"firstName\"\n *   }});\n *   const { dirtyFields } = useFormState({\n *     control\n *   });\n *   const onSubmit = (data) => console.log(data);\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input {...register(\"firstName\")} placeholder=\"First Name\" />\n *       {dirtyFields.firstName && <p>Field is dirty.</p>}\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFormState(props) {\n    const methods = useFormContext();\n    const { control = methods.control, disabled, name, exact } = props || {};\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._formState);\n    const _localProxyFormState = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n        isDirty: false,\n        isLoading: false,\n        dirtyFields: false,\n        touchedFields: false,\n        validatingFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    });\n    useIsomorphicLayoutEffect(()=>control._subscribe({\n            name,\n            formState: _localProxyFormState.current,\n            exact,\n            callback: (formState)=>{\n                !disabled && updateFormState({\n                    ...control._formState,\n                    ...formState\n                });\n            }\n        }), [\n        name,\n        disabled,\n        exact\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        _localProxyFormState.current.isValid && control._setValid(true);\n    }, [\n        control\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>getProxyFormState(formState, control, _localProxyFormState.current, false), [\n        formState,\n        control\n    ]);\n}\nvar isString = (value1)=>typeof value1 === \"string\";\nvar generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue)=>{\n    if (isString(names)) {\n        isGlobal && _names.watch.add(names);\n        return get(formValues, names, defaultValue);\n    }\n    if (Array.isArray(names)) {\n        return names.map((fieldName)=>(isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));\n    }\n    isGlobal && (_names.watchAll = true);\n    return formValues;\n};\nvar isPrimitive = (value1)=>isNullOrUndefined(value1) || !isObjectType(value1);\nfunction deepEqual(object1, object2, _internal_visited = new WeakSet()) {\n    if (isPrimitive(object1) || isPrimitive(object2)) {\n        return object1 === object2;\n    }\n    if (isDateObject(object1) && isDateObject(object2)) {\n        return object1.getTime() === object2.getTime();\n    }\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    if (_internal_visited.has(object1) || _internal_visited.has(object2)) {\n        return true;\n    }\n    _internal_visited.add(object1);\n    _internal_visited.add(object2);\n    for (const key of keys1){\n        const val1 = object1[key];\n        if (!keys2.includes(key)) {\n            return false;\n        }\n        if (key !== \"ref\") {\n            const val2 = object2[key];\n            if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2, _internal_visited) : val1 !== val2) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\n * Custom hook to subscribe to field change and isolate re-rendering at the component level.\n *\n * @remarks\n *\n * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)\n *\n * @example\n * ```tsx\n * const { control } = useForm();\n * const values = useWatch({\n *   name: \"fieldName\"\n *   control,\n * })\n * ```\n */ function useWatch(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, defaultValue, disabled, exact, compute } = props || {};\n    const _defaultValue = react__WEBPACK_IMPORTED_MODULE_0__.useRef(defaultValue);\n    const _compute = react__WEBPACK_IMPORTED_MODULE_0__.useRef(compute);\n    const _computeFormValues = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const _prevControl = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control);\n    const _prevName = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\n    _compute.current = compute;\n    const [value1, updateValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        const defaultValue = control._getWatch(name, _defaultValue.current);\n        return _compute.current ? _compute.current(defaultValue) : defaultValue;\n    });\n    const getCurrentOutput = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((values)=>{\n        const formValues = generateWatchOutput(name, control._names, values || control._formValues, false, _defaultValue.current);\n        return _compute.current ? _compute.current(formValues) : formValues;\n    }, [\n        control._formValues,\n        control._names,\n        name\n    ]);\n    const refreshValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((values)=>{\n        if (!disabled) {\n            const formValues = generateWatchOutput(name, control._names, values || control._formValues, false, _defaultValue.current);\n            if (_compute.current) {\n                const computedFormValues = _compute.current(formValues);\n                if (!deepEqual(computedFormValues, _computeFormValues.current)) {\n                    updateValue(computedFormValues);\n                    _computeFormValues.current = computedFormValues;\n                }\n            } else {\n                updateValue(formValues);\n            }\n        }\n    }, [\n        control._formValues,\n        control._names,\n        disabled,\n        name\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        if (_prevControl.current !== control || !deepEqual(_prevName.current, name)) {\n            _prevControl.current = control;\n            _prevName.current = name;\n            refreshValue();\n        }\n        return control._subscribe({\n            name,\n            formState: {\n                values: true\n            },\n            exact,\n            callback: (formState)=>{\n                refreshValue(formState.values);\n            }\n        });\n    }, [\n        control,\n        exact,\n        name,\n        refreshValue\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._removeUnmounted());\n    // If name or control changed for this render, synchronously reflect the\n    // latest value so callers (like useController) see the correct value\n    // immediately on the same render.\n    // Optimize: Check control reference first before expensive deepEqual\n    const controlChanged = _prevControl.current !== control;\n    const prevName = _prevName.current;\n    // Cache the computed output to avoid duplicate calls within the same render\n    // We include shouldReturnImmediate in deps to ensure proper recomputation\n    const computedOutput = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (disabled) {\n            return null;\n        }\n        const nameChanged = !controlChanged && !deepEqual(prevName, name);\n        const shouldReturnImmediate = controlChanged || nameChanged;\n        return shouldReturnImmediate ? getCurrentOutput() : null;\n    }, [\n        disabled,\n        controlChanged,\n        name,\n        prevName,\n        getCurrentOutput\n    ]);\n    return computedOutput !== null ? computedOutput : value1;\n}\n/**\n * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller) • [Demo](https://codesandbox.io/s/usecontroller-0o8px)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns field properties, field and form state. {@link UseControllerReturn}\n *\n * @example\n * ```tsx\n * function Input(props) {\n *   const { field, fieldState, formState } = useController(props);\n *   return (\n *     <div>\n *       <input {...field} placeholder={props.name} />\n *       <p>{fieldState.isTouched && \"Touched\"}</p>\n *       <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *     </div>\n *   );\n * }\n * ```\n */ function useController(props) {\n    const methods = useFormContext();\n    const { name, disabled, control = methods.control, shouldUnregister, defaultValue } = props;\n    const isArrayField = isNameInFieldArray(control._names.array, name);\n    const defaultValueMemo = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>get(control._formValues, name, get(control._defaultValues, name, defaultValue)), [\n        control,\n        name,\n        defaultValue\n    ]);\n    const value1 = useWatch({\n        control,\n        name,\n        defaultValue: defaultValueMemo,\n        exact: true\n    });\n    const formState = useFormState({\n        control,\n        name,\n        exact: true\n    });\n    const _props = react__WEBPACK_IMPORTED_MODULE_0__.useRef(props);\n    const _previousNameRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const _registerProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control.register(name, {\n        ...props.rules,\n        value: value1,\n        ...isBoolean(props.disabled) ? {\n            disabled: props.disabled\n        } : {}\n    }));\n    _props.current = props;\n    const fieldState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.defineProperties({}, {\n            invalid: {\n                enumerable: true,\n                get: ()=>!!get(formState.errors, name)\n            },\n            isDirty: {\n                enumerable: true,\n                get: ()=>!!get(formState.dirtyFields, name)\n            },\n            isTouched: {\n                enumerable: true,\n                get: ()=>!!get(formState.touchedFields, name)\n            },\n            isValidating: {\n                enumerable: true,\n                get: ()=>!!get(formState.validatingFields, name)\n            },\n            error: {\n                enumerable: true,\n                get: ()=>get(formState.errors, name)\n            }\n        }), [\n        formState,\n        name\n    ]);\n    const onChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>_registerProps.current.onChange({\n            target: {\n                value: getEventValue(event),\n                name: name\n            },\n            type: EVENTS.CHANGE\n        }), [\n        name\n    ]);\n    const onBlur = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>_registerProps.current.onBlur({\n            target: {\n                value: get(control._formValues, name),\n                name: name\n            },\n            type: EVENTS.BLUR\n        }), [\n        name,\n        control._formValues\n    ]);\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((elm)=>{\n        const field = get(control._fields, name);\n        if (field && elm) {\n            field._f.ref = {\n                focus: ()=>elm.focus && elm.focus(),\n                select: ()=>elm.select && elm.select(),\n                setCustomValidity: (message)=>elm.setCustomValidity(message),\n                reportValidity: ()=>elm.reportValidity()\n            };\n        }\n    }, [\n        control._fields,\n        name\n    ]);\n    const field = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            name,\n            value: value1,\n            ...isBoolean(disabled) || formState.disabled ? {\n                disabled: formState.disabled || disabled\n            } : {},\n            onChange,\n            onBlur,\n            ref\n        }), [\n        name,\n        disabled,\n        formState.disabled,\n        onChange,\n        onBlur,\n        ref,\n        value1\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;\n        const previousName = _previousNameRef.current;\n        if (previousName && previousName !== name && !isArrayField) {\n            control.unregister(previousName);\n        }\n        control.register(name, {\n            ..._props.current.rules,\n            ...isBoolean(_props.current.disabled) ? {\n                disabled: _props.current.disabled\n            } : {}\n        });\n        const updateMounted = (name, value1)=>{\n            const field = get(control._fields, name);\n            if (field && field._f) {\n                field._f.mount = value1;\n            }\n        };\n        updateMounted(name, true);\n        if (_shouldUnregisterField) {\n            const value1 = cloneObject(get(control._options.defaultValues, name, _props.current.defaultValue));\n            set(control._defaultValues, name, value1);\n            if (isUndefined(get(control._formValues, name))) {\n                set(control._formValues, name, value1);\n            }\n        }\n        !isArrayField && control.register(name);\n        _previousNameRef.current = name;\n        return ()=>{\n            (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);\n        };\n    }, [\n        name,\n        control,\n        isArrayField,\n        shouldUnregister\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        control._setDisabledField({\n            disabled,\n            name\n        });\n    }, [\n        disabled,\n        name,\n        control\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            field,\n            formState,\n            fieldState\n        }), [\n        field,\n        formState,\n        fieldState\n    ]);\n}\n/**\n * Component based on `useController` hook to work with controlled component.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller/controller) • [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) • [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns provide field handler functions, field and form state.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control } = useForm<FormValues>({\n *     defaultValues: {\n *       test: \"\"\n *     }\n *   });\n *\n *   return (\n *     <form>\n *       <Controller\n *         control={control}\n *         name=\"test\"\n *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (\n *           <>\n *             <input\n *               onChange={onChange} // send value to hook form\n *               onBlur={onBlur} // notify when input is touched\n *               value={value} // return updated value\n *               ref={ref} // set ref for focus management\n *             />\n *             <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *             <p>{fieldState.isTouched ? \"touched\" : \"\"}</p>\n *           </>\n *         )}\n *       />\n *     </form>\n *   );\n * }\n * ```\n */ const Controller = (props)=>props.render(useController(props));\nconst flatten = (obj)=>{\n    const output = {};\n    for (const key of Object.keys(obj)){\n        if (isObjectType(obj[key]) && obj[key] !== null) {\n            const nested = flatten(obj[key]);\n            for (const nestedKey of Object.keys(nested)){\n                output[`${key}.${nestedKey}`] = nested[nestedKey];\n            }\n        } else {\n            output[key] = obj[key];\n        }\n    }\n    return output;\n};\nconst POST_REQUEST = \"post\";\n/**\n * Form component to manage submission.\n *\n * @param props - to setup submission detail. {@link FormProps}\n *\n * @returns form component or headless render prop.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control, formState: { errors } } = useForm();\n *\n *   return (\n *     <Form action=\"/api\" control={control}>\n *       <input {...register(\"name\")} />\n *       <p>{errors?.root?.server && 'Server error'}</p>\n *       <button>Submit</button>\n *     </Form>\n *   );\n * }\n * ```\n */ function Form(props) {\n    const methods = useFormContext();\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const { control = methods.control, onSubmit, children, action, method = POST_REQUEST, headers, encType, onError, render, onSuccess, validateStatus, ...rest } = props;\n    const submit = async (event)=>{\n        let hasError = false;\n        let type = \"\";\n        await control.handleSubmit(async (data)=>{\n            const formData = new FormData();\n            let formDataJson = \"\";\n            try {\n                formDataJson = JSON.stringify(data);\n            } catch (_a) {}\n            const flattenFormValues = flatten(control._formValues);\n            for(const key in flattenFormValues){\n                formData.append(key, flattenFormValues[key]);\n            }\n            if (onSubmit) {\n                await onSubmit({\n                    data,\n                    event,\n                    method,\n                    formData,\n                    formDataJson\n                });\n            }\n            if (action) {\n                try {\n                    const shouldStringifySubmissionData = [\n                        headers && headers[\"Content-Type\"],\n                        encType\n                    ].some((value1)=>value1 && value1.includes(\"json\"));\n                    const response = await fetch(String(action), {\n                        method,\n                        headers: {\n                            ...headers,\n                            ...encType && encType !== \"multipart/form-data\" ? {\n                                \"Content-Type\": encType\n                            } : {}\n                        },\n                        body: shouldStringifySubmissionData ? formDataJson : formData\n                    });\n                    if (response && (validateStatus ? !validateStatus(response.status) : response.status < 200 || response.status >= 300)) {\n                        hasError = true;\n                        onError && onError({\n                            response\n                        });\n                        type = String(response.status);\n                    } else {\n                        onSuccess && onSuccess({\n                            response\n                        });\n                    }\n                } catch (error) {\n                    hasError = true;\n                    onError && onError({\n                        error\n                    });\n                }\n            }\n        })(event);\n        if (hasError && props.control) {\n            props.control._subjects.state.next({\n                isSubmitSuccessful: false\n            });\n            props.control.setError(\"root.server\", {\n                type\n            });\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return render ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, render({\n        submit\n    })) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", {\n        noValidate: mounted,\n        action: action,\n        method: method,\n        encType: encType,\n        onSubmit: submit,\n        ...rest\n    }, children);\n}\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message)=>validateAllFieldCriteria ? {\n        ...errors[name],\n        types: {\n            ...errors[name] && errors[name].types ? errors[name].types : {},\n            [type]: message || true\n        }\n    } : {};\nvar convertToArrayPayload = (value1)=>Array.isArray(value1) ? value1 : [\n        value1\n    ];\nvar createSubject = ()=>{\n    let _observers = [];\n    const next = (value1)=>{\n        for (const observer of _observers){\n            observer.next && observer.next(value1);\n        }\n    };\n    const subscribe = (observer)=>{\n        _observers.push(observer);\n        return {\n            unsubscribe: ()=>{\n                _observers = _observers.filter((o)=>o !== observer);\n            }\n        };\n    };\n    const unsubscribe = ()=>{\n        _observers = [];\n    };\n    return {\n        get observers () {\n            return _observers;\n        },\n        next,\n        subscribe,\n        unsubscribe\n    };\n};\nfunction extractFormValues(fieldsState, formValues) {\n    const values = {};\n    for(const key in fieldsState){\n        if (fieldsState.hasOwnProperty(key)) {\n            const fieldState = fieldsState[key];\n            const fieldValue = formValues[key];\n            if (fieldState && isObject(fieldState) && fieldValue) {\n                const nestedFieldsState = extractFormValues(fieldState, fieldValue);\n                if (isObject(nestedFieldsState)) {\n                    values[key] = nestedFieldsState;\n                }\n            } else if (fieldsState[key]) {\n                values[key] = fieldValue;\n            }\n        }\n    }\n    return values;\n}\nvar isEmptyObject = (value1)=>isObject(value1) && !Object.keys(value1).length;\nvar isFileInput = (element)=>element.type === \"file\";\nvar isFunction = (value1)=>typeof value1 === \"function\";\nvar isHTMLElement = (value1)=>{\n    if (!isWeb) {\n        return false;\n    }\n    const owner = value1 ? value1.ownerDocument : 0;\n    return value1 instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);\n};\nvar isMultipleSelect = (element)=>element.type === `select-multiple`;\nvar isRadioInput = (element)=>element.type === \"radio\";\nvar isRadioOrCheckbox = (ref)=>isRadioInput(ref) || isCheckBoxInput(ref);\nvar live = (ref)=>isHTMLElement(ref) && ref.isConnected;\nfunction baseGet(object, updatePath) {\n    const length = updatePath.slice(0, -1).length;\n    let index = 0;\n    while(index < length){\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\n    }\n    return object;\n}\nfunction isEmptyArray(obj) {\n    for(const key in obj){\n        if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction unset(object, path) {\n    const paths = Array.isArray(path) ? path : isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const childObject = paths.length === 1 ? object : baseGet(object, paths);\n    const index = paths.length - 1;\n    const key = paths[index];\n    if (childObject) {\n        delete childObject[key];\n    }\n    if (index !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {\n        unset(object, paths.slice(0, -1));\n    }\n    return object;\n}\nvar objectHasFunction = (data)=>{\n    for(const key in data){\n        if (isFunction(data[key])) {\n            return true;\n        }\n    }\n    return false;\n};\nfunction isTraversable(value1) {\n    return Array.isArray(value1) || isObject(value1) && !objectHasFunction(value1);\n}\nfunction markFieldsDirty(data, fields = {}) {\n    for(const key in data){\n        if (isTraversable(data[key])) {\n            fields[key] = Array.isArray(data[key]) ? [] : {};\n            markFieldsDirty(data[key], fields[key]);\n        } else if (!isUndefined(data[key])) {\n            fields[key] = true;\n        }\n    }\n    return fields;\n}\nfunction getDirtyFields(data, formValues, dirtyFieldsFromValues) {\n    if (!dirtyFieldsFromValues) {\n        dirtyFieldsFromValues = markFieldsDirty(formValues);\n    }\n    for(const key in data){\n        if (isTraversable(data[key])) {\n            if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {\n                dirtyFieldsFromValues[key] = markFieldsDirty(data[key], Array.isArray(data[key]) ? [] : {});\n            } else {\n                getDirtyFields(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);\n            }\n        } else {\n            dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);\n        }\n    }\n    return dirtyFieldsFromValues;\n}\nconst defaultResult = {\n    value: false,\n    isValid: false\n};\nconst validResult = {\n    value: true,\n    isValid: true\n};\nvar getCheckboxValue = (options)=>{\n    if (Array.isArray(options)) {\n        if (options.length > 1) {\n            const values = options.filter((option)=>option && option.checked && !option.disabled).map((option)=>option.value);\n            return {\n                value: values,\n                isValid: !!values.length\n            };\n        }\n        return options[0].checked && !options[0].disabled ? options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === \"\" ? validResult : {\n            value: options[0].value,\n            isValid: true\n        } : validResult : defaultResult;\n    }\n    return defaultResult;\n};\nvar getFieldValueAs = (value1, { valueAsNumber, valueAsDate, setValueAs })=>isUndefined(value1) ? value1 : valueAsNumber ? value1 === \"\" ? NaN : value1 ? +value1 : value1 : valueAsDate && isString(value1) ? new Date(value1) : setValueAs ? setValueAs(value1) : value1;\nconst defaultReturn = {\n    isValid: false,\n    value: null\n};\nvar getRadioValue = (options)=>Array.isArray(options) ? options.reduce((previous, option)=>option && option.checked && !option.disabled ? {\n            isValid: true,\n            value: option.value\n        } : previous, defaultReturn) : defaultReturn;\nfunction getFieldValue(_f) {\n    const ref = _f.ref;\n    if (isFileInput(ref)) {\n        return ref.files;\n    }\n    if (isRadioInput(ref)) {\n        return getRadioValue(_f.refs).value;\n    }\n    if (isMultipleSelect(ref)) {\n        return [\n            ...ref.selectedOptions\n        ].map(({ value: value1 })=>value1);\n    }\n    if (isCheckBoxInput(ref)) {\n        return getCheckboxValue(_f.refs).value;\n    }\n    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);\n}\nvar getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation)=>{\n    const fields = {};\n    for (const name of fieldsNames){\n        const field = get(_fields, name);\n        field && set(fields, name, field._f);\n    }\n    return {\n        criteriaMode,\n        names: [\n            ...fieldsNames\n        ],\n        fields,\n        shouldUseNativeValidation\n    };\n};\nvar isRegex = (value1)=>value1 instanceof RegExp;\nvar getRuleValue = (rule)=>isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;\nvar getValidationModes = (mode)=>({\n        isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n        isOnBlur: mode === VALIDATION_MODE.onBlur,\n        isOnChange: mode === VALIDATION_MODE.onChange,\n        isOnAll: mode === VALIDATION_MODE.all,\n        isOnTouch: mode === VALIDATION_MODE.onTouched\n    });\nconst ASYNC_FUNCTION = \"AsyncFunction\";\nvar hasPromiseValidation = (fieldReference)=>!!fieldReference && !!fieldReference.validate && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction)=>validateFunction.constructor.name === ASYNC_FUNCTION));\nvar hasValidation = (options)=>options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);\nvar isWatched = (name, _names, isBlurEvent)=>!isBlurEvent && (_names.watchAll || _names.watch.has(name) || [\n        ..._names.watch\n    ].some((watchName)=>name.startsWith(watchName) && /^\\.\\w+/.test(name.slice(watchName.length))));\nconst iterateFieldsByAction = (fields, action, fieldsNames, abortEarly)=>{\n    for (const key of fieldsNames || Object.keys(fields)){\n        const field = get(fields, key);\n        if (field) {\n            const { _f, ...currentField } = field;\n            if (_f) {\n                if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {\n                    return true;\n                } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {\n                    return true;\n                } else {\n                    if (iterateFieldsByAction(currentField, action)) {\n                        break;\n                    }\n                }\n            } else if (isObject(currentField)) {\n                if (iterateFieldsByAction(currentField, action)) {\n                    break;\n                }\n            }\n        }\n    }\n    return;\n};\nfunction schemaErrorLookup(errors, _fields, name) {\n    const error = get(errors, name);\n    if (error || isKey(name)) {\n        return {\n            error,\n            name\n        };\n    }\n    const names = name.split(\".\");\n    while(names.length){\n        const fieldName = names.join(\".\");\n        const field = get(_fields, fieldName);\n        const foundError = get(errors, fieldName);\n        if (field && !Array.isArray(field) && name !== fieldName) {\n            return {\n                name\n            };\n        }\n        if (foundError && foundError.type) {\n            return {\n                name: fieldName,\n                error: foundError\n            };\n        }\n        if (foundError && foundError.root && foundError.root.type) {\n            return {\n                name: `${fieldName}.root`,\n                error: foundError.root\n            };\n        }\n        names.pop();\n    }\n    return {\n        name\n    };\n}\nvar shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot)=>{\n    updateFormState(formStateData);\n    const { name, ...formState } = formStateData;\n    return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key)=>_proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));\n};\nvar shouldSubscribeByName = (name, signalName, exact)=>!name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName)=>currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));\nvar skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode)=>{\n    if (mode.isOnAll) {\n        return false;\n    } else if (!isSubmitted && mode.isOnTouch) {\n        return !(isTouched || isBlurEvent);\n    } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {\n        return !isBlurEvent;\n    } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {\n        return isBlurEvent;\n    }\n    return true;\n};\nvar unsetEmptyArray = (ref, name)=>!compact(get(ref, name)).length && unset(ref, name);\nvar updateFieldArrayRootError = (errors, error, name)=>{\n    const fieldArrayErrors = convertToArrayPayload(get(errors, name));\n    set(fieldArrayErrors, \"root\", error[name]);\n    set(errors, name, fieldArrayErrors);\n    return errors;\n};\nfunction getValidateError(result, ref, type = \"validate\") {\n    if (isString(result) || Array.isArray(result) && result.every(isString) || isBoolean(result) && !result) {\n        return {\n            type,\n            message: isString(result) ? result : \"\",\n            ref\n        };\n    }\n}\nvar getValueAndMessage = (validationData)=>isObject(validationData) && !isRegex(validationData) ? validationData : {\n        value: validationData,\n        message: \"\"\n    };\nvar validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray)=>{\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount } = field._f;\n    const inputValue = get(formValues, name);\n    if (!mount || disabledFieldNames.has(name)) {\n        return {};\n    }\n    const inputRef = refs ? refs[0] : ref;\n    const setCustomValidity = (message)=>{\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\n            inputRef.setCustomValidity(isBoolean(message) ? \"\" : message || \"\");\n            inputRef.reportValidity();\n        }\n    };\n    const error = {};\n    const isRadio = isRadioInput(ref);\n    const isCheckBox = isCheckBoxInput(ref);\n    const isRadioOrCheckbox = isRadio || isCheckBox;\n    const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === \"\" || inputValue === \"\" || Array.isArray(inputValue) && !inputValue.length;\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength)=>{\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\n        error[name] = {\n            type: exceedMax ? maxType : minType,\n            message,\n            ref,\n            ...appendErrorsCurry(exceedMax ? maxType : minType, message)\n        };\n    };\n    if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {\n        const { value: value1, message } = isString(required) ? {\n            value: !!required,\n            message: required\n        } : getValueAndMessage(required);\n        if (value1) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.required,\n                message,\n                ref: inputRef,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n        let exceedMax;\n        let exceedMin;\n        const maxOutput = getValueAndMessage(max);\n        const minOutput = getValueAndMessage(min);\n        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {\n            const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);\n            if (!isNullOrUndefined(maxOutput.value)) {\n                exceedMax = valueNumber > maxOutput.value;\n            }\n            if (!isNullOrUndefined(minOutput.value)) {\n                exceedMin = valueNumber < minOutput.value;\n            }\n        } else {\n            const valueDate = ref.valueAsDate || new Date(inputValue);\n            const convertTimeToDate = (time)=>new Date(new Date().toDateString() + \" \" + time);\n            const isTime = ref.type == \"time\";\n            const isWeek = ref.type == \"week\";\n            if (isString(maxOutput.value) && inputValue) {\n                exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);\n            }\n            if (isString(minOutput.value) && inputValue) {\n                exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);\n            }\n        }\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {\n        const maxLengthOutput = getValueAndMessage(maxLength);\n        const minLengthOutput = getValueAndMessage(minLength);\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if (pattern && !isEmpty && isString(inputValue)) {\n        const { value: patternValue, message } = getValueAndMessage(pattern);\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.pattern,\n                message,\n                ref,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (validate) {\n        if (isFunction(validate)) {\n            const result = await validate(inputValue, formValues);\n            const validateError = getValidateError(result, inputRef);\n            if (validateError) {\n                error[name] = {\n                    ...validateError,\n                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)\n                };\n                if (!validateAllFieldCriteria) {\n                    setCustomValidity(validateError.message);\n                    return error;\n                }\n            }\n        } else if (isObject(validate)) {\n            let validationResult = {};\n            for(const key in validate){\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n                    break;\n                }\n                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);\n                if (validateError) {\n                    validationResult = {\n                        ...validateError,\n                        ...appendErrorsCurry(key, validateError.message)\n                    };\n                    setCustomValidity(validateError.message);\n                    if (validateAllFieldCriteria) {\n                        error[name] = validationResult;\n                    }\n                }\n            }\n            if (!isEmptyObject(validationResult)) {\n                error[name] = {\n                    ref: inputRef,\n                    ...validationResult\n                };\n                if (!validateAllFieldCriteria) {\n                    return error;\n                }\n            }\n        }\n    }\n    setCustomValidity(true);\n    return error;\n};\nconst defaultOptions = {\n    mode: VALIDATION_MODE.onSubmit,\n    reValidateMode: VALIDATION_MODE.onChange,\n    shouldFocusError: true\n};\nfunction createFormControl(props = {}) {\n    let _options = {\n        ...defaultOptions,\n        ...props\n    };\n    let _formState = {\n        submitCount: 0,\n        isDirty: false,\n        isReady: false,\n        isLoading: isFunction(_options.defaultValues),\n        isValidating: false,\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        touchedFields: {},\n        dirtyFields: {},\n        validatingFields: {},\n        errors: _options.errors || {},\n        disabled: _options.disabled || false\n    };\n    let _fields = {};\n    let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};\n    let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);\n    let _state = {\n        action: false,\n        mount: false,\n        watch: false\n    };\n    let _names = {\n        mount: new Set(),\n        disabled: new Set(),\n        unMount: new Set(),\n        array: new Set(),\n        watch: new Set()\n    };\n    let delayErrorCallback;\n    let timer = 0;\n    const _proxyFormState = {\n        isDirty: false,\n        dirtyFields: false,\n        validatingFields: false,\n        touchedFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    };\n    let _proxySubscribeFormState = {\n        ..._proxyFormState\n    };\n    const _subjects = {\n        array: createSubject(),\n        state: createSubject()\n    };\n    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;\n    const debounce = (callback)=>(wait)=>{\n            clearTimeout(timer);\n            timer = setTimeout(callback, wait);\n        };\n    const _setValid = async (shouldUpdateValid)=>{\n        if (!_options.disabled && (_proxyFormState.isValid || _proxySubscribeFormState.isValid || shouldUpdateValid)) {\n            const isValid = _options.resolver ? isEmptyObject((await _runSchema()).errors) : await executeBuiltInValidation(_fields, true);\n            if (isValid !== _formState.isValid) {\n                _subjects.state.next({\n                    isValid\n                });\n            }\n        }\n    };\n    const _updateIsValidating = (names, isValidating)=>{\n        if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields || _proxySubscribeFormState.isValidating || _proxySubscribeFormState.validatingFields)) {\n            (names || Array.from(_names.mount)).forEach((name)=>{\n                if (name) {\n                    isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);\n                }\n            });\n            _subjects.state.next({\n                validatingFields: _formState.validatingFields,\n                isValidating: !isEmptyObject(_formState.validatingFields)\n            });\n        }\n    };\n    const _setFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true)=>{\n        if (args && method && !_options.disabled) {\n            _state.action = true;\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {\n                const fieldValues = method(get(_fields, name), args.argA, args.argB);\n                shouldSetValues && set(_fields, name, fieldValues);\n            }\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {\n                const errors = method(get(_formState.errors, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.errors, name, errors);\n                unsetEmptyArray(_formState.errors, name);\n            }\n            if ((_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {\n                const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.touchedFields, name, touchedFields);\n            }\n            if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {\n                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);\n            }\n            _subjects.state.next({\n                name,\n                isDirty: _getDirty(name, values),\n                dirtyFields: _formState.dirtyFields,\n                errors: _formState.errors,\n                isValid: _formState.isValid\n            });\n        } else {\n            set(_formValues, name, values);\n        }\n    };\n    const updateErrors = (name, error)=>{\n        set(_formState.errors, name, error);\n        _subjects.state.next({\n            errors: _formState.errors\n        });\n    };\n    const _setErrors = (errors)=>{\n        _formState.errors = errors;\n        _subjects.state.next({\n            errors: _formState.errors,\n            isValid: false\n        });\n    };\n    const updateValidAndValue = (name, shouldSkipSetValueAs, value1, ref)=>{\n        const field = get(_fields, name);\n        if (field) {\n            const defaultValue = get(_formValues, name, isUndefined(value1) ? get(_defaultValues, name) : value1);\n            isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);\n            _state.mount && _setValid();\n        }\n    };\n    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender)=>{\n        let shouldUpdateField = false;\n        let isPreviousDirty = false;\n        const output = {\n            name\n        };\n        if (!_options.disabled) {\n            if (!isBlurEvent || shouldDirty) {\n                if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {\n                    isPreviousDirty = _formState.isDirty;\n                    _formState.isDirty = output.isDirty = _getDirty();\n                    shouldUpdateField = isPreviousDirty !== output.isDirty;\n                }\n                const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);\n                isPreviousDirty = !!get(_formState.dirtyFields, name);\n                isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);\n                output.dirtyFields = _formState.dirtyFields;\n                shouldUpdateField = shouldUpdateField || (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) && isPreviousDirty !== !isCurrentFieldPristine;\n            }\n            if (isBlurEvent) {\n                const isPreviousFieldTouched = get(_formState.touchedFields, name);\n                if (!isPreviousFieldTouched) {\n                    set(_formState.touchedFields, name, isBlurEvent);\n                    output.touchedFields = _formState.touchedFields;\n                    shouldUpdateField = shouldUpdateField || (_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && isPreviousFieldTouched !== isBlurEvent;\n                }\n            }\n            shouldUpdateField && shouldRender && _subjects.state.next(output);\n        }\n        return shouldUpdateField ? output : {};\n    };\n    const shouldRenderByError = (name, isValid, error, fieldState)=>{\n        const previousFieldError = get(_formState.errors, name);\n        const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isBoolean(isValid) && _formState.isValid !== isValid;\n        if (_options.delayError && error) {\n            delayErrorCallback = debounce(()=>updateErrors(name, error));\n            delayErrorCallback(_options.delayError);\n        } else {\n            clearTimeout(timer);\n            delayErrorCallback = null;\n            error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n        }\n        if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {\n            const updatedFormState = {\n                ...fieldState,\n                ...shouldUpdateValid && isBoolean(isValid) ? {\n                    isValid\n                } : {},\n                errors: _formState.errors,\n                name\n            };\n            _formState = {\n                ..._formState,\n                ...updatedFormState\n            };\n            _subjects.state.next(updatedFormState);\n        }\n    };\n    const _runSchema = async (name)=>{\n        _updateIsValidating(name, true);\n        const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));\n        _updateIsValidating(name);\n        return result;\n    };\n    const executeSchemaAndUpdateState = async (names)=>{\n        const { errors } = await _runSchema(names);\n        if (names) {\n            for (const name of names){\n                const error = get(errors, name);\n                error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n            }\n        } else {\n            _formState.errors = errors;\n        }\n        return errors;\n    };\n    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {\n        valid: true\n    })=>{\n        for(const name in fields){\n            const field = fields[name];\n            if (field) {\n                const { _f, ...fieldValue } = field;\n                if (_f) {\n                    const isFieldArrayRoot = _names.array.has(_f.name);\n                    const isPromiseFunction = field._f && hasPromiseValidation(field._f);\n                    if (isPromiseFunction && _proxyFormState.validatingFields) {\n                        _updateIsValidating([\n                            _f.name\n                        ], true);\n                    }\n                    const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);\n                    if (isPromiseFunction && _proxyFormState.validatingFields) {\n                        _updateIsValidating([\n                            _f.name\n                        ]);\n                    }\n                    if (fieldError[_f.name]) {\n                        context.valid = false;\n                        if (shouldOnlyCheckValid) {\n                            break;\n                        }\n                    }\n                    !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));\n                }\n                !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);\n            }\n        }\n        return context.valid;\n    };\n    const _removeUnmounted = ()=>{\n        for (const name of _names.unMount){\n            const field = get(_fields, name);\n            field && (field._f.refs ? field._f.refs.every((ref)=>!live(ref)) : !live(field._f.ref)) && unregister(name);\n        }\n        _names.unMount = new Set();\n    };\n    const _getDirty = (name, data)=>!_options.disabled && (name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));\n    const _getWatch = (names, defaultValue, isGlobal)=>generateWatchOutput(names, _names, {\n            ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? {\n                [names]: defaultValue\n            } : defaultValue\n        }, isGlobal, defaultValue);\n    const _getFieldArray = (name)=>compact(get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get(_defaultValues, name, []) : []));\n    const setFieldValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        let fieldValue = value1;\n        if (field) {\n            const fieldReference = field._f;\n            if (fieldReference) {\n                !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value1, fieldReference));\n                fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value1) ? \"\" : value1;\n                if (isMultipleSelect(fieldReference.ref)) {\n                    [\n                        ...fieldReference.ref.options\n                    ].forEach((optionRef)=>optionRef.selected = fieldValue.includes(optionRef.value));\n                } else if (fieldReference.refs) {\n                    if (isCheckBoxInput(fieldReference.ref)) {\n                        fieldReference.refs.forEach((checkboxRef)=>{\n                            if (!checkboxRef.defaultChecked || !checkboxRef.disabled) {\n                                if (Array.isArray(fieldValue)) {\n                                    checkboxRef.checked = !!fieldValue.find((data)=>data === checkboxRef.value);\n                                } else {\n                                    checkboxRef.checked = fieldValue === checkboxRef.value || !!fieldValue;\n                                }\n                            }\n                        });\n                    } else {\n                        fieldReference.refs.forEach((radioRef)=>radioRef.checked = radioRef.value === fieldValue);\n                    }\n                } else if (isFileInput(fieldReference.ref)) {\n                    fieldReference.ref.value = \"\";\n                } else {\n                    fieldReference.ref.value = fieldValue;\n                    if (!fieldReference.ref.type) {\n                        _subjects.state.next({\n                            name,\n                            values: cloneObject(_formValues)\n                        });\n                    }\n                }\n            }\n        }\n        (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);\n        options.shouldValidate && trigger(name);\n    };\n    const setValues = (name, value1, options)=>{\n        for(const fieldKey in value1){\n            if (!value1.hasOwnProperty(fieldKey)) {\n                return;\n            }\n            const fieldValue = value1[fieldKey];\n            const fieldName = name + \".\" + fieldKey;\n            const field = get(_fields, fieldName);\n            (_names.array.has(name) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);\n        }\n    };\n    const setValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        const isFieldArray = _names.array.has(name);\n        const cloneValue = cloneObject(value1);\n        set(_formValues, name, cloneValue);\n        if (isFieldArray) {\n            _subjects.array.next({\n                name,\n                values: cloneObject(_formValues)\n            });\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields || _proxySubscribeFormState.isDirty || _proxySubscribeFormState.dirtyFields) && options.shouldDirty) {\n                _subjects.state.next({\n                    name,\n                    dirtyFields: getDirtyFields(_defaultValues, _formValues),\n                    isDirty: _getDirty(name, cloneValue)\n                });\n            }\n        } else {\n            field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);\n        }\n        isWatched(name, _names) && _subjects.state.next({\n            ..._formState,\n            name\n        });\n        _subjects.state.next({\n            name: _state.mount ? name : undefined,\n            values: cloneObject(_formValues)\n        });\n    };\n    const onChange = async (event)=>{\n        _state.mount = true;\n        const target = event.target;\n        let name = target.name;\n        let isFieldValueUpdated = true;\n        const field = get(_fields, name);\n        const _updateIsFieldValueUpdated = (fieldValue)=>{\n            isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual(fieldValue, get(_formValues, name, fieldValue));\n        };\n        const validationModeBeforeSubmit = getValidationModes(_options.mode);\n        const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);\n        if (field) {\n            let error;\n            let isValid;\n            const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);\n            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;\n            const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);\n            const watched = isWatched(name, _names, isBlurEvent);\n            set(_formValues, name, fieldValue);\n            if (isBlurEvent) {\n                if (!target || !target.readOnly) {\n                    field._f.onBlur && field._f.onBlur(event);\n                    delayErrorCallback && delayErrorCallback(0);\n                }\n            } else if (field._f.onChange) {\n                field._f.onChange(event);\n            }\n            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);\n            const shouldRender = !isEmptyObject(fieldState) || watched;\n            !isBlurEvent && _subjects.state.next({\n                name,\n                type: event.type,\n                values: cloneObject(_formValues)\n            });\n            if (shouldSkipValidation) {\n                if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {\n                    if (_options.mode === \"onBlur\") {\n                        if (isBlurEvent) {\n                            _setValid();\n                        }\n                    } else if (!isBlurEvent) {\n                        _setValid();\n                    }\n                }\n                return shouldRender && _subjects.state.next({\n                    name,\n                    ...watched ? {} : fieldState\n                });\n            }\n            !isBlurEvent && watched && _subjects.state.next({\n                ..._formState\n            });\n            if (_options.resolver) {\n                const { errors } = await _runSchema([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);\n                    const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);\n                    error = errorLookupResult.error;\n                    name = errorLookupResult.name;\n                    isValid = isEmptyObject(errors);\n                }\n            } else {\n                _updateIsValidating([\n                    name\n                ], true);\n                error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];\n                _updateIsValidating([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    if (error) {\n                        isValid = false;\n                    } else if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {\n                        isValid = await executeBuiltInValidation(_fields, true);\n                    }\n                }\n            }\n            if (isFieldValueUpdated) {\n                field._f.deps && (!Array.isArray(field._f.deps) || field._f.deps.length > 0) && trigger(field._f.deps);\n                shouldRenderByError(name, isValid, error, fieldState);\n            }\n        }\n    };\n    const _focusInput = (ref, key)=>{\n        if (get(_formState.errors, key) && ref.focus) {\n            ref.focus();\n            return 1;\n        }\n        return;\n    };\n    const trigger = async (name, options = {})=>{\n        let isValid;\n        let validationResult;\n        const fieldNames = convertToArrayPayload(name);\n        if (_options.resolver) {\n            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);\n            isValid = isEmptyObject(errors);\n            validationResult = name ? !fieldNames.some((name)=>get(errors, name)) : isValid;\n        } else if (name) {\n            validationResult = (await Promise.all(fieldNames.map(async (fieldName)=>{\n                const field = get(_fields, fieldName);\n                return await executeBuiltInValidation(field && field._f ? {\n                    [fieldName]: field\n                } : field);\n            }))).every(Boolean);\n            !(!validationResult && !_formState.isValid) && _setValid();\n        } else {\n            validationResult = isValid = await executeBuiltInValidation(_fields);\n        }\n        _subjects.state.next({\n            ...!isString(name) || (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isValid !== _formState.isValid ? {} : {\n                name\n            },\n            ..._options.resolver || !name ? {\n                isValid\n            } : {},\n            errors: _formState.errors\n        });\n        options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);\n        return validationResult;\n    };\n    const getValues = (fieldNames, config)=>{\n        let values = {\n            ..._state.mount ? _formValues : _defaultValues\n        };\n        if (config) {\n            values = extractFormValues(config.dirtyFields ? _formState.dirtyFields : _formState.touchedFields, values);\n        }\n        return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name)=>get(values, name));\n    };\n    const getFieldState = (name, formState)=>({\n            invalid: !!get((formState || _formState).errors, name),\n            isDirty: !!get((formState || _formState).dirtyFields, name),\n            error: get((formState || _formState).errors, name),\n            isValidating: !!get(_formState.validatingFields, name),\n            isTouched: !!get((formState || _formState).touchedFields, name)\n        });\n    const clearErrors = (name)=>{\n        name && convertToArrayPayload(name).forEach((inputName)=>unset(_formState.errors, inputName));\n        _subjects.state.next({\n            errors: name ? _formState.errors : {}\n        });\n    };\n    const setError = (name, error, options)=>{\n        const ref = (get(_fields, name, {\n            _f: {}\n        })._f || {}).ref;\n        const currentError = get(_formState.errors, name) || {};\n        // Don't override existing error messages elsewhere in the object tree.\n        const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;\n        set(_formState.errors, name, {\n            ...restOfErrorTree,\n            ...error,\n            ref\n        });\n        _subjects.state.next({\n            name,\n            errors: _formState.errors,\n            isValid: false\n        });\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\n    };\n    const watch = (name, defaultValue)=>isFunction(name) ? _subjects.state.subscribe({\n            next: (payload)=>\"values\" in payload && name(_getWatch(undefined, defaultValue), payload)\n        }) : _getWatch(name, defaultValue, true);\n    const _subscribe = (props)=>_subjects.state.subscribe({\n            next: (formState)=>{\n                if (shouldSubscribeByName(props.name, formState.name, props.exact) && shouldRenderFormState(formState, props.formState || _proxyFormState, _setFormState, props.reRenderRoot)) {\n                    props.callback({\n                        values: {\n                            ..._formValues\n                        },\n                        ..._formState,\n                        ...formState,\n                        defaultValues: _defaultValues\n                    });\n                }\n            }\n        }).unsubscribe;\n    const subscribe = (props)=>{\n        _state.mount = true;\n        _proxySubscribeFormState = {\n            ..._proxySubscribeFormState,\n            ...props.formState\n        };\n        return _subscribe({\n            ...props,\n            formState: _proxySubscribeFormState\n        });\n    };\n    const unregister = (name, options = {})=>{\n        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount){\n            _names.mount.delete(fieldName);\n            _names.array.delete(fieldName);\n            if (!options.keepValue) {\n                unset(_fields, fieldName);\n                unset(_formValues, fieldName);\n            }\n            !options.keepError && unset(_formState.errors, fieldName);\n            !options.keepDirty && unset(_formState.dirtyFields, fieldName);\n            !options.keepTouched && unset(_formState.touchedFields, fieldName);\n            !options.keepIsValidating && unset(_formState.validatingFields, fieldName);\n            !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);\n        }\n        _subjects.state.next({\n            values: cloneObject(_formValues)\n        });\n        _subjects.state.next({\n            ..._formState,\n            ...!options.keepDirty ? {} : {\n                isDirty: _getDirty()\n            }\n        });\n        !options.keepIsValid && _setValid();\n    };\n    const _setDisabledField = ({ disabled, name })=>{\n        if (isBoolean(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {\n            disabled ? _names.disabled.add(name) : _names.disabled.delete(name);\n        }\n    };\n    const register = (name, options = {})=>{\n        let field = get(_fields, name);\n        const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);\n        set(_fields, name, {\n            ...field || {},\n            _f: {\n                ...field && field._f ? field._f : {\n                    ref: {\n                        name\n                    }\n                },\n                name,\n                mount: true,\n                ...options\n            }\n        });\n        _names.mount.add(name);\n        if (field) {\n            _setDisabledField({\n                disabled: isBoolean(options.disabled) ? options.disabled : _options.disabled,\n                name\n            });\n        } else {\n            updateValidAndValue(name, true, options.value);\n        }\n        return {\n            ...disabledIsDefined ? {\n                disabled: options.disabled || _options.disabled\n            } : {},\n            ..._options.progressive ? {\n                required: !!options.required,\n                min: getRuleValue(options.min),\n                max: getRuleValue(options.max),\n                minLength: getRuleValue(options.minLength),\n                maxLength: getRuleValue(options.maxLength),\n                pattern: getRuleValue(options.pattern)\n            } : {},\n            name,\n            onChange,\n            onBlur: onChange,\n            ref: (ref)=>{\n                if (ref) {\n                    register(name, options);\n                    field = get(_fields, name);\n                    const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll(\"input,select,textarea\")[0] || ref : ref : ref;\n                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);\n                    const refs = field._f.refs || [];\n                    if (radioOrCheckbox ? refs.find((option)=>option === fieldRef) : fieldRef === field._f.ref) {\n                        return;\n                    }\n                    set(_fields, name, {\n                        _f: {\n                            ...field._f,\n                            ...radioOrCheckbox ? {\n                                refs: [\n                                    ...refs.filter(live),\n                                    fieldRef,\n                                    ...Array.isArray(get(_defaultValues, name)) ? [\n                                        {}\n                                    ] : []\n                                ],\n                                ref: {\n                                    type: fieldRef.type,\n                                    name\n                                }\n                            } : {\n                                ref: fieldRef\n                            }\n                        }\n                    });\n                    updateValidAndValue(name, false, undefined, fieldRef);\n                } else {\n                    field = get(_fields, name, {});\n                    if (field._f) {\n                        field._f.mount = false;\n                    }\n                    (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);\n                }\n            }\n        };\n    };\n    const _focusError = ()=>_options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);\n    const _disableForm = (disabled)=>{\n        if (isBoolean(disabled)) {\n            _subjects.state.next({\n                disabled\n            });\n            iterateFieldsByAction(_fields, (ref, name)=>{\n                const currentField = get(_fields, name);\n                if (currentField) {\n                    ref.disabled = currentField._f.disabled || disabled;\n                    if (Array.isArray(currentField._f.refs)) {\n                        currentField._f.refs.forEach((inputRef)=>{\n                            inputRef.disabled = currentField._f.disabled || disabled;\n                        });\n                    }\n                }\n            }, 0, false);\n        }\n    };\n    const handleSubmit = (onValid, onInvalid)=>async (e)=>{\n            let onValidError = undefined;\n            if (e) {\n                e.preventDefault && e.preventDefault();\n                e.persist && e.persist();\n            }\n            let fieldValues = cloneObject(_formValues);\n            _subjects.state.next({\n                isSubmitting: true\n            });\n            if (_options.resolver) {\n                const { errors, values } = await _runSchema();\n                _formState.errors = errors;\n                fieldValues = cloneObject(values);\n            } else {\n                await executeBuiltInValidation(_fields);\n            }\n            if (_names.disabled.size) {\n                for (const name of _names.disabled){\n                    unset(fieldValues, name);\n                }\n            }\n            unset(_formState.errors, \"root\");\n            if (isEmptyObject(_formState.errors)) {\n                _subjects.state.next({\n                    errors: {}\n                });\n                try {\n                    await onValid(fieldValues, e);\n                } catch (error) {\n                    onValidError = error;\n                }\n            } else {\n                if (onInvalid) {\n                    await onInvalid({\n                        ..._formState.errors\n                    }, e);\n                }\n                _focusError();\n                setTimeout(_focusError);\n            }\n            _subjects.state.next({\n                isSubmitted: true,\n                isSubmitting: false,\n                isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,\n                submitCount: _formState.submitCount + 1,\n                errors: _formState.errors\n            });\n            if (onValidError) {\n                throw onValidError;\n            }\n        };\n    const resetField = (name, options = {})=>{\n        if (get(_fields, name)) {\n            if (isUndefined(options.defaultValue)) {\n                setValue(name, cloneObject(get(_defaultValues, name)));\n            } else {\n                setValue(name, options.defaultValue);\n                set(_defaultValues, name, cloneObject(options.defaultValue));\n            }\n            if (!options.keepTouched) {\n                unset(_formState.touchedFields, name);\n            }\n            if (!options.keepDirty) {\n                unset(_formState.dirtyFields, name);\n                _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();\n            }\n            if (!options.keepError) {\n                unset(_formState.errors, name);\n                _proxyFormState.isValid && _setValid();\n            }\n            _subjects.state.next({\n                ..._formState\n            });\n        }\n    };\n    const _reset = (formValues, keepStateOptions = {})=>{\n        const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;\n        const cloneUpdatedValues = cloneObject(updatedValues);\n        const isEmptyResetValues = isEmptyObject(formValues);\n        const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;\n        if (!keepStateOptions.keepDefaultValues) {\n            _defaultValues = updatedValues;\n        }\n        if (!keepStateOptions.keepValues) {\n            if (keepStateOptions.keepDirtyValues) {\n                const fieldsToCheck = new Set([\n                    ..._names.mount,\n                    ...Object.keys(getDirtyFields(_defaultValues, _formValues))\n                ]);\n                for (const fieldName of Array.from(fieldsToCheck)){\n                    get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));\n                }\n            } else {\n                if (isWeb && isUndefined(formValues)) {\n                    for (const name of _names.mount){\n                        const field = get(_fields, name);\n                        if (field && field._f) {\n                            const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;\n                            if (isHTMLElement(fieldReference)) {\n                                const form = fieldReference.closest(\"form\");\n                                if (form) {\n                                    form.reset();\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (keepStateOptions.keepFieldsRef) {\n                    for (const fieldName of _names.mount){\n                        setValue(fieldName, get(values, fieldName));\n                    }\n                } else {\n                    _fields = {};\n                }\n            }\n            _formValues = _options.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);\n            _subjects.array.next({\n                values: {\n                    ...values\n                }\n            });\n            _subjects.state.next({\n                values: {\n                    ...values\n                }\n            });\n        }\n        _names = {\n            mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),\n            unMount: new Set(),\n            array: new Set(),\n            disabled: new Set(),\n            watch: new Set(),\n            watchAll: false,\n            focus: \"\"\n        };\n        _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues || !_options.shouldUnregister && !isEmptyObject(values);\n        _state.watch = !!_options.shouldUnregister;\n        _subjects.state.next({\n            submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,\n            isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),\n            isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,\n            dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},\n            touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\n            isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,\n            isSubmitting: false,\n            defaultValues: _defaultValues\n        });\n    };\n    const reset = (formValues, keepStateOptions)=>_reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);\n    const setFocus = (name, options = {})=>{\n        const field = get(_fields, name);\n        const fieldReference = field && field._f;\n        if (fieldReference) {\n            const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;\n            if (fieldRef.focus) {\n                fieldRef.focus();\n                options.shouldSelect && isFunction(fieldRef.select) && fieldRef.select();\n            }\n        }\n    };\n    const _setFormState = (updatedFormState)=>{\n        _formState = {\n            ..._formState,\n            ...updatedFormState\n        };\n    };\n    const _resetDefaultValues = ()=>isFunction(_options.defaultValues) && _options.defaultValues().then((values)=>{\n            reset(values, _options.resetOptions);\n            _subjects.state.next({\n                isLoading: false\n            });\n        });\n    const methods = {\n        control: {\n            register,\n            unregister,\n            getFieldState,\n            handleSubmit,\n            setError,\n            _subscribe,\n            _runSchema,\n            _focusError,\n            _getWatch,\n            _getDirty,\n            _setValid,\n            _setFieldArray,\n            _setDisabledField,\n            _setErrors,\n            _getFieldArray,\n            _reset,\n            _resetDefaultValues,\n            _removeUnmounted,\n            _disableForm,\n            _subjects,\n            _proxyFormState,\n            get _fields () {\n                return _fields;\n            },\n            get _formValues () {\n                return _formValues;\n            },\n            get _state () {\n                return _state;\n            },\n            set _state (value){\n                _state = value;\n            },\n            get _defaultValues () {\n                return _defaultValues;\n            },\n            get _names () {\n                return _names;\n            },\n            set _names (value){\n                _names = value;\n            },\n            get _formState () {\n                return _formState;\n            },\n            get _options () {\n                return _options;\n            },\n            set _options (value){\n                _options = {\n                    ..._options,\n                    ...value\n                };\n            }\n        },\n        subscribe,\n        trigger,\n        register,\n        handleSubmit,\n        watch,\n        setValue,\n        getValues,\n        reset,\n        resetField,\n        clearErrors,\n        unregister,\n        setError,\n        setFocus,\n        getFieldState\n    };\n    return {\n        ...methods,\n        formControl: methods\n    };\n}\nvar generateId = ()=>{\n    if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    const d = typeof performance === \"undefined\" ? Date.now() : performance.now() * 1000;\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = (Math.random() * 16 + d) % 16 | 0;\n        return (c == \"x\" ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\nvar getFocusFieldName = (name, index, options = {})=>options.shouldFocus || isUndefined(options.shouldFocus) ? options.focusName || `${name}.${isUndefined(options.focusIndex) ? index : options.focusIndex}.` : \"\";\nvar appendAt = (data, value1)=>[\n        ...data,\n        ...convertToArrayPayload(value1)\n    ];\nvar fillEmptyArray = (value1)=>Array.isArray(value1) ? value1.map(()=>undefined) : undefined;\nfunction insert(data, index, value1) {\n    return [\n        ...data.slice(0, index),\n        ...convertToArrayPayload(value1),\n        ...data.slice(index)\n    ];\n}\nvar moveArrayAt = (data, from, to)=>{\n    if (!Array.isArray(data)) {\n        return [];\n    }\n    if (isUndefined(data[to])) {\n        data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n};\nvar prependAt = (data, value1)=>[\n        ...convertToArrayPayload(value1),\n        ...convertToArrayPayload(data)\n    ];\nfunction removeAtIndexes(data, indexes) {\n    let i = 0;\n    const temp = [\n        ...data\n    ];\n    for (const index of indexes){\n        temp.splice(index - i, 1);\n        i++;\n    }\n    return compact(temp).length ? temp : [];\n}\nvar removeArrayAt = (data, index)=>isUndefined(index) ? [] : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b)=>a - b));\nvar swapArrayAt = (data, indexA, indexB)=>{\n    [data[indexA], data[indexB]] = [\n        data[indexB],\n        data[indexA]\n    ];\n};\nvar updateAt = (fieldValues, index, value1)=>{\n    fieldValues[index] = value1;\n    return fieldValues;\n};\n/**\n * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc. • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn) • [Video](https://youtu.be/4MrbfGSFY2A)\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)\n *\n * @param props - useFieldArray props\n *\n * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({\n *     defaultValues: {\n *       test: []\n *     }\n *   });\n *   const { fields, append } = useFieldArray({\n *     control,\n *     name: \"test\"\n *   });\n *\n *   return (\n *     <form onSubmit={handleSubmit(data => console.log(data))}>\n *       {fields.map((item, index) => (\n *          <input key={item.id} {...register(`test.${index}.firstName`)}  />\n *       ))}\n *       <button type=\"button\" onClick={() => append({ firstName: \"bill\" })}>\n *         append\n *       </button>\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFieldArray(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, keyName = \"id\", shouldUnregister, rules } = props;\n    const [fields, setFields] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._getFieldArray(name));\n    const ids = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control._getFieldArray(name).map(generateId));\n    const _actioned = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    control._names.array.add(name);\n    react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>rules && fields.length >= 0 && control.register(name, rules), [\n        control,\n        name,\n        fields.length,\n        rules\n    ]);\n    useIsomorphicLayoutEffect(()=>control._subjects.array.subscribe({\n            next: ({ values, name: fieldArrayName })=>{\n                if (fieldArrayName === name || !fieldArrayName) {\n                    const fieldValues = get(values, name);\n                    if (Array.isArray(fieldValues)) {\n                        setFields(fieldValues);\n                        ids.current = fieldValues.map(generateId);\n                    }\n                }\n            }\n        }).unsubscribe, [\n        control,\n        name\n    ]);\n    const updateValues = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((updatedFieldArrayValues)=>{\n        _actioned.current = true;\n        control._setFieldArray(name, updatedFieldArrayValues);\n    }, [\n        control,\n        name\n    ]);\n    const append = (value1, options)=>{\n        const appendValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = appendAt(control._getFieldArray(name), appendValue);\n        control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);\n        ids.current = appendAt(ids.current, appendValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, appendAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const prepend = (value1, options)=>{\n        const prependValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = prependAt(control._getFieldArray(name), prependValue);\n        control._names.focus = getFocusFieldName(name, 0, options);\n        ids.current = prependAt(ids.current, prependValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, prependAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const remove = (index)=>{\n        const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index);\n        ids.current = removeArrayAt(ids.current, index);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        !Array.isArray(get(control._fields, name)) && set(control._fields, name, undefined);\n        control._setFieldArray(name, updatedFieldArrayValues, removeArrayAt, {\n            argA: index\n        });\n    };\n    const insert$1 = (index, value1, options)=>{\n        const insertValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = insert(control._getFieldArray(name), index, insertValue);\n        control._names.focus = getFocusFieldName(name, index, options);\n        ids.current = insert(ids.current, index, insertValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, insert, {\n            argA: index,\n            argB: fillEmptyArray(value1)\n        });\n    };\n    const swap = (indexA, indexB)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        swapArrayAt(updatedFieldArrayValues, indexA, indexB);\n        swapArrayAt(ids.current, indexA, indexB);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, swapArrayAt, {\n            argA: indexA,\n            argB: indexB\n        }, false);\n    };\n    const move = (from, to)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        moveArrayAt(updatedFieldArrayValues, from, to);\n        moveArrayAt(ids.current, from, to);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, moveArrayAt, {\n            argA: from,\n            argB: to\n        }, false);\n    };\n    const update = (index, value1)=>{\n        const updateValue = cloneObject(value1);\n        const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index, updateValue);\n        ids.current = [\n            ...updatedFieldArrayValues\n        ].map((item, i)=>!item || i === index ? generateId() : ids.current[i]);\n        updateValues(updatedFieldArrayValues);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._setFieldArray(name, updatedFieldArrayValues, updateAt, {\n            argA: index,\n            argB: updateValue\n        }, true, false);\n    };\n    const replace = (value1)=>{\n        const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value1));\n        ids.current = updatedFieldArrayValues.map(generateId);\n        updateValues([\n            ...updatedFieldArrayValues\n        ]);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._setFieldArray(name, [\n            ...updatedFieldArrayValues\n        ], (data)=>data, {}, true, false);\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        control._state.action = false;\n        isWatched(name, control._names) && control._subjects.state.next({\n            ...control._formState\n        });\n        if (_actioned.current && (!getValidationModes(control._options.mode).isOnSubmit || control._formState.isSubmitted) && !getValidationModes(control._options.reValidateMode).isOnSubmit) {\n            if (control._options.resolver) {\n                control._runSchema([\n                    name\n                ]).then((result)=>{\n                    const error = get(result.errors, name);\n                    const existingError = get(control._formState.errors, name);\n                    if (existingError ? !error && existingError.type || error && (existingError.type !== error.type || existingError.message !== error.message) : error && error.type) {\n                        error ? set(control._formState.errors, name, error) : unset(control._formState.errors, name);\n                        control._subjects.state.next({\n                            errors: control._formState.errors\n                        });\n                    }\n                });\n            } else {\n                const field = get(control._fields, name);\n                if (field && field._f && !(getValidationModes(control._options.reValidateMode).isOnSubmit && getValidationModes(control._options.mode).isOnSubmit)) {\n                    validateField(field, control._names.disabled, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error)=>!isEmptyObject(error) && control._subjects.state.next({\n                            errors: updateFieldArrayRootError(control._formState.errors, error, name)\n                        }));\n                }\n            }\n        }\n        control._subjects.state.next({\n            name,\n            values: cloneObject(control._formValues)\n        });\n        control._names.focus && iterateFieldsByAction(control._fields, (ref, key)=>{\n            if (control._names.focus && key.startsWith(control._names.focus) && ref.focus) {\n                ref.focus();\n                return 1;\n            }\n            return;\n        });\n        control._names.focus = \"\";\n        control._setValid();\n        _actioned.current = false;\n    }, [\n        fields,\n        name,\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        !get(control._formValues, name) && control._setFieldArray(name);\n        return ()=>{\n            const updateMounted = (name, value1)=>{\n                const field = get(control._fields, name);\n                if (field && field._f) {\n                    field._f.mount = value1;\n                }\n            };\n            control._options.shouldUnregister || shouldUnregister ? control.unregister(name) : updateMounted(name, false);\n        };\n    }, [\n        name,\n        control,\n        keyName,\n        shouldUnregister\n    ]);\n    return {\n        swap: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(swap, [\n            updateValues,\n            name,\n            control\n        ]),\n        move: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(move, [\n            updateValues,\n            name,\n            control\n        ]),\n        prepend: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(prepend, [\n            updateValues,\n            name,\n            control\n        ]),\n        append: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(append, [\n            updateValues,\n            name,\n            control\n        ]),\n        remove: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(remove, [\n            updateValues,\n            name,\n            control\n        ]),\n        insert: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(insert$1, [\n            updateValues,\n            name,\n            control\n        ]),\n        update: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(update, [\n            updateValues,\n            name,\n            control\n        ]),\n        replace: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(replace, [\n            updateValues,\n            name,\n            control\n        ]),\n        fields: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>fields.map((field, index)=>({\n                    ...field,\n                    [keyName]: ids.current[index] || generateId()\n                })), [\n            fields,\n            keyName\n        ])\n    };\n}\n/**\n * Custom hook to manage the entire form.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform) • [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) • [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)\n *\n * @param props - form configuration and validation parameters.\n *\n * @returns methods - individual functions to manage the form state. {@link UseFormReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, watch, formState: { errors } } = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   console.log(watch(\"example\"));\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input defaultValue=\"test\" {...register(\"example\")} />\n *       <input {...register(\"exampleRequired\", { required: true })} />\n *       {errors.exampleRequired && <span>This field is required</span>}\n *       <button>Submit</button>\n *     </form>\n *   );\n * }\n * ```\n */ function useForm(props = {}) {\n    const _formControl = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const _values = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        isDirty: false,\n        isValidating: false,\n        isLoading: isFunction(props.defaultValues),\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        submitCount: 0,\n        dirtyFields: {},\n        touchedFields: {},\n        validatingFields: {},\n        errors: props.errors || {},\n        disabled: props.disabled || false,\n        isReady: false,\n        defaultValues: isFunction(props.defaultValues) ? undefined : props.defaultValues\n    });\n    if (!_formControl.current) {\n        if (props.formControl) {\n            _formControl.current = {\n                ...props.formControl,\n                formState\n            };\n            if (props.defaultValues && !isFunction(props.defaultValues)) {\n                props.formControl.reset(props.defaultValues, props.resetOptions);\n            }\n        } else {\n            const { formControl, ...rest } = createFormControl(props);\n            _formControl.current = {\n                ...rest,\n                formState\n            };\n        }\n    }\n    const control = _formControl.current.control;\n    control._options = props;\n    useIsomorphicLayoutEffect(()=>{\n        const sub = control._subscribe({\n            formState: control._proxyFormState,\n            callback: ()=>updateFormState({\n                    ...control._formState\n                }),\n            reRenderRoot: true\n        });\n        updateFormState((data)=>({\n                ...data,\n                isReady: true\n            }));\n        control._formState.isReady = true;\n        return sub;\n    }, [\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._disableForm(props.disabled), [\n        control,\n        props.disabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.mode) {\n            control._options.mode = props.mode;\n        }\n        if (props.reValidateMode) {\n            control._options.reValidateMode = props.reValidateMode;\n        }\n    }, [\n        control,\n        props.mode,\n        props.reValidateMode\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.errors) {\n            control._setErrors(props.errors);\n            control._focusError();\n        }\n    }, [\n        control,\n        props.errors\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        props.shouldUnregister && control._subjects.state.next({\n            values: control._getWatch()\n        });\n    }, [\n        control,\n        props.shouldUnregister\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (control._proxyFormState.isDirty) {\n            const isDirty = control._getDirty();\n            if (isDirty !== formState.isDirty) {\n                control._subjects.state.next({\n                    isDirty\n                });\n            }\n        }\n    }, [\n        control,\n        formState.isDirty\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.values && !deepEqual(props.values, _values.current)) {\n            control._reset(props.values, {\n                keepFieldsRef: true,\n                ...control._options.resetOptions\n            });\n            _values.current = props.values;\n            updateFormState((state)=>({\n                    ...state\n                }));\n        } else {\n            control._resetDefaultValues();\n        }\n    }, [\n        control,\n        props.values\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!control._state.mount) {\n            control._setValid();\n            control._state.mount = true;\n        }\n        if (control._state.watch) {\n            control._state.watch = false;\n            control._subjects.state.next({\n                ...control._formState\n            });\n        }\n        control._removeUnmounted();\n    });\n    _formControl.current.formState = getProxyFormState(formState, control);\n    return _formControl.current;\n}\n/**\n * Watch component that subscribes to form field changes and re-renders when watched fields update.\n *\n * @param control - The form control object from useForm\n * @param names - Array of field names to watch for changes\n * @param render - The function that receives watched values and returns ReactNode\n * @returns The result of calling render function with watched values\n *\n * @example\n * The `Watch` component only re-render when the values of `foo`, `bar`, and `baz.qux` change.\n * The types of `foo`, `bar`, and `baz.qux` are precisely inferred.\n *\n * ```tsx\n * const { control } = useForm();\n *\n * <Watch\n *   control={control}\n *   names={['foo', 'bar', 'baz.qux']}\n *   render={([foo, bar, baz_qux]) => <div>{foo}{bar}{baz_qux}</div>}\n * />\n * ```\n */ const Watch = ({ control, names, render })=>render(useWatch({\n        control,\n        name: names\n    }));\n //# sourceMappingURL=index.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaG9vay1mb3JtL2Rpc3QvaW5kZXguZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFFMUIsSUFBSUMsa0JBQWtCLENBQUNDLFVBQVlBLFFBQVFDLElBQUksS0FBSztBQUVwRCxJQUFJQyxlQUFlLENBQUNDLFNBQVVBLGtCQUFpQkM7QUFFL0MsSUFBSUMsb0JBQW9CLENBQUNGLFNBQVVBLFVBQVM7QUFFNUMsTUFBTUcsZUFBZSxDQUFDSCxTQUFVLE9BQU9BLFdBQVU7QUFDakQsSUFBSUksV0FBVyxDQUFDSixTQUFVLENBQUNFLGtCQUFrQkYsV0FDekMsQ0FBQ0ssTUFBTUMsT0FBTyxDQUFDTixXQUNmRyxhQUFhSCxXQUNiLENBQUNELGFBQWFDO0FBRWxCLElBQUlPLGdCQUFnQixDQUFDQyxRQUFVSixTQUFTSSxVQUFVQSxNQUFNQyxNQUFNLEdBQ3hEYixnQkFBZ0JZLE1BQU1DLE1BQU0sSUFDeEJELE1BQU1DLE1BQU0sQ0FBQ0MsT0FBTyxHQUNwQkYsTUFBTUMsTUFBTSxDQUFDVCxLQUFLLEdBQ3RCUTtBQUVOLElBQUlHLG9CQUFvQixDQUFDQyxPQUFTQSxLQUFLQyxTQUFTLENBQUMsR0FBR0QsS0FBS0UsTUFBTSxDQUFDLG1CQUFtQkY7QUFFbkYsSUFBSUcscUJBQXFCLENBQUNDLE9BQU9KLE9BQVNJLE1BQU1DLEdBQUcsQ0FBQ04sa0JBQWtCQztBQUV0RSxJQUFJTSxnQkFBZ0IsQ0FBQ0M7SUFDakIsTUFBTUMsZ0JBQWdCRCxXQUFXRSxXQUFXLElBQUlGLFdBQVdFLFdBQVcsQ0FBQ0MsU0FBUztJQUNoRixPQUFRbEIsU0FBU2dCLGtCQUFrQkEsY0FBY0csY0FBYyxDQUFDO0FBQ3BFO0FBRUEsSUFBSUMsUUFBUSxNQUNzQixJQUM5QixDQUFvQjtBQUV4QixTQUFTSSxZQUFZQyxJQUFJO0lBQ3JCLElBQUlDO0lBQ0osTUFBTXhCLFVBQVVELE1BQU1DLE9BQU8sQ0FBQ3VCO0lBQzlC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S0FBQztJQUMxQnZLLDRDQUFlLENBQUM7UUFDWixJQUFJLENBQUNvRyxRQUFRNkcsTUFBTSxDQUFDRCxLQUFLLEVBQUU7WUFDdkI1RyxRQUFRK0IsU0FBUztZQUNqQi9CLFFBQVE2RyxNQUFNLENBQUNELEtBQUssR0FBRztRQUMzQjtRQUNBLElBQUk1RyxRQUFRNkcsTUFBTSxDQUFDdkUsS0FBSyxFQUFFO1lBQ3RCdEMsUUFBUTZHLE1BQU0sQ0FBQ3ZFLEtBQUssR0FBRztZQUN2QnRDLFFBQVFvSixTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDO2dCQUFFLEdBQUd0SixRQUFRaUIsVUFBVTtZQUFDO1FBQ3pEO1FBQ0FqQixRQUFRdUUsZ0JBQWdCO0lBQzVCO0lBQ0FnYSxhQUFhMWMsT0FBTyxDQUFDOUIsU0FBUyxHQUFHRCxrQkFBa0JDLFdBQVdDO0lBQzlELE9BQU91ZSxhQUFhMWMsT0FBTztBQUMvQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FDRCxNQUFNNmMsUUFBUSxDQUFDLEVBQUUxZSxPQUFPLEVBQUUvRSxLQUFLLEVBQUVnTSxNQUFNLEVBQUcsR0FBS0EsT0FBT3pELFNBQVM7UUFBRXhEO1FBQVNuRixNQUFNSTtJQUFNO0FBRXFGLENBQzNLLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZGZsb3ctc2Fhcy8uL25vZGVfbW9kdWxlcy9yZWFjdC1ob29rLWZvcm0vZGlzdC9pbmRleC5lc20ubWpzPzlkYzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxudmFyIGlzQ2hlY2tCb3hJbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdjaGVja2JveCc7XG5cbnZhciBpc0RhdGVPYmplY3QgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcblxudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gKHZhbHVlKSA9PiB2YWx1ZSA9PSBudWxsO1xuXG5jb25zdCBpc09iamVjdFR5cGUgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG52YXIgaXNPYmplY3QgPSAodmFsdWUpID0+ICFpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgJiZcbiAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcbiAgICBpc09iamVjdFR5cGUodmFsdWUpICYmXG4gICAgIWlzRGF0ZU9iamVjdCh2YWx1ZSk7XG5cbnZhciBnZXRFdmVudFZhbHVlID0gKGV2ZW50KSA9PiBpc09iamVjdChldmVudCkgJiYgZXZlbnQudGFyZ2V0XG4gICAgPyBpc0NoZWNrQm94SW5wdXQoZXZlbnQudGFyZ2V0KVxuICAgICAgICA/IGV2ZW50LnRhcmdldC5jaGVja2VkXG4gICAgICAgIDogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgOiBldmVudDtcblxudmFyIGdldE5vZGVQYXJlbnROYW1lID0gKG5hbWUpID0+IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUuc2VhcmNoKC9cXC5cXGQrKFxcLnwkKS8pKSB8fCBuYW1lO1xuXG52YXIgaXNOYW1lSW5GaWVsZEFycmF5ID0gKG5hbWVzLCBuYW1lKSA9PiBuYW1lcy5oYXMoZ2V0Tm9kZVBhcmVudE5hbWUobmFtZSkpO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9ICh0ZW1wT2JqZWN0KSA9PiB7XG4gICAgY29uc3QgcHJvdG90eXBlQ29weSA9IHRlbXBPYmplY3QuY29uc3RydWN0b3IgJiYgdGVtcE9iamVjdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgcmV0dXJuIChpc09iamVjdChwcm90b3R5cGVDb3B5KSAmJiBwcm90b3R5cGVDb3B5Lmhhc093blByb3BlcnR5KCdpc1Byb3RvdHlwZU9mJykpO1xufTtcblxudmFyIGlzV2ViID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LkhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmZ1bmN0aW9uIGNsb25lT2JqZWN0KGRhdGEpIHtcbiAgICBsZXQgY29weTtcbiAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShkYXRhKTtcbiAgICBjb25zdCBpc0ZpbGVMaXN0SW5zdGFuY2UgPSB0eXBlb2YgRmlsZUxpc3QgIT09ICd1bmRlZmluZWQnID8gZGF0YSBpbnN0YW5jZW9mIEZpbGVMaXN0IDogZmFsc2U7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGNvcHkgPSBuZXcgRGF0ZShkYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIShpc1dlYiAmJiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IgfHwgaXNGaWxlTGlzdEluc3RhbmNlKSkgJiZcbiAgICAgICAgKGlzQXJyYXkgfHwgaXNPYmplY3QoZGF0YSkpKSB7XG4gICAgICAgIGNvcHkgPSBpc0FycmF5ID8gW10gOiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihkYXRhKSk7XG4gICAgICAgIGlmICghaXNBcnJheSAmJiAhaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgY29weSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBjbG9uZU9iamVjdChkYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuXG52YXIgaXNLZXkgPSAodmFsdWUpID0+IC9eXFx3KiQvLnRlc3QodmFsdWUpO1xuXG52YXIgaXNVbmRlZmluZWQgPSAodmFsKSA9PiB2YWwgPT09IHVuZGVmaW5lZDtcblxudmFyIGNvbXBhY3QgPSAodmFsdWUpID0+IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuZmlsdGVyKEJvb2xlYW4pIDogW107XG5cbnZhciBzdHJpbmdUb1BhdGggPSAoaW5wdXQpID0+IGNvbXBhY3QoaW5wdXQucmVwbGFjZSgvW1wifCddfFxcXS9nLCAnJykuc3BsaXQoL1xcLnxcXFsvKSk7XG5cbnZhciBnZXQgPSAob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICBpZiAoIXBhdGggfHwgIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gKGlzS2V5KHBhdGgpID8gW3BhdGhdIDogc3RyaW5nVG9QYXRoKHBhdGgpKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiBpc051bGxPclVuZGVmaW5lZChyZXN1bHQpID8gcmVzdWx0IDogcmVzdWx0W2tleV0sIG9iamVjdCk7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHJlc3VsdCkgfHwgcmVzdWx0ID09PSBvYmplY3RcbiAgICAgICAgPyBpc1VuZGVmaW5lZChvYmplY3RbcGF0aF0pXG4gICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgOiBvYmplY3RbcGF0aF1cbiAgICAgICAgOiByZXN1bHQ7XG59O1xuXG52YXIgaXNCb29sZWFuID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcblxudmFyIHNldCA9IChvYmplY3QsIHBhdGgsIHZhbHVlKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgY29uc3QgdGVtcFBhdGggPSBpc0tleShwYXRoKSA/IFtwYXRoXSA6IHN0cmluZ1RvUGF0aChwYXRoKTtcbiAgICBjb25zdCBsZW5ndGggPSB0ZW1wUGF0aC5sZW5ndGg7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBjb25zdCBrZXkgPSB0ZW1wUGF0aFtpbmRleF07XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoaW5kZXggIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgY29uc3Qgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID1cbiAgICAgICAgICAgICAgICBpc09iamVjdChvYmpWYWx1ZSkgfHwgQXJyYXkuaXNBcnJheShvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgICAgICAgICA6ICFpc05hTigrdGVtcFBhdGhbaW5kZXggKyAxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgICB9XG59O1xuXG5jb25zdCBFVkVOVFMgPSB7XG4gICAgQkxVUjogJ2JsdXInLFxuICAgIEZPQ1VTX09VVDogJ2ZvY3Vzb3V0JyxcbiAgICBDSEFOR0U6ICdjaGFuZ2UnLFxufTtcbmNvbnN0IFZBTElEQVRJT05fTU9ERSA9IHtcbiAgICBvbkJsdXI6ICdvbkJsdXInLFxuICAgIG9uQ2hhbmdlOiAnb25DaGFuZ2UnLFxuICAgIG9uU3VibWl0OiAnb25TdWJtaXQnLFxuICAgIG9uVG91Y2hlZDogJ29uVG91Y2hlZCcsXG4gICAgYWxsOiAnYWxsJyxcbn07XG5jb25zdCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTID0ge1xuICAgIG1heDogJ21heCcsXG4gICAgbWluOiAnbWluJyxcbiAgICBtYXhMZW5ndGg6ICdtYXhMZW5ndGgnLFxuICAgIG1pbkxlbmd0aDogJ21pbkxlbmd0aCcsXG4gICAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICAgIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICAgIHZhbGlkYXRlOiAndmFsaWRhdGUnLFxufTtcblxuY29uc3QgSG9va0Zvcm1Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkhvb2tGb3JtQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdIb29rRm9ybUNvbnRleHQnO1xuLyoqXG4gKiBUaGlzIGN1c3RvbSBob29rIGFsbG93cyB5b3UgdG8gYWNjZXNzIHRoZSBmb3JtIGNvbnRleHQuIHVzZUZvcm1Db250ZXh0IGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW4gZGVlcGx5IG5lc3RlZCBzdHJ1Y3R1cmVzLCB3aGVyZSBpdCB3b3VsZCBiZWNvbWUgaW5jb252ZW5pZW50IHRvIHBhc3MgdGhlIGNvbnRleHQgYXMgYSBwcm9wLiBUbyBiZSB1c2VkIHdpdGgge0BsaW5rIEZvcm1Qcm92aWRlcn0uXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZvcm1jb250ZXh0KSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjctZm9ybS1jb250ZXh0LXl0dWRpKVxuICpcbiAqIEByZXR1cm5zIHJldHVybiBhbGwgdXNlRm9ybSBtZXRob2RzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCBtZXRob2RzID0gdXNlRm9ybSgpO1xuICogICBjb25zdCBvblN1Ym1pdCA9IGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxGb3JtUHJvdmlkZXIgey4uLm1ldGhvZHN9ID5cbiAqICAgICAgIDxmb3JtIG9uU3VibWl0PXttZXRob2RzLmhhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgICA8TmVzdGVkSW5wdXQgLz5cbiAqICAgICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgICAgPC9mb3JtPlxuICogICAgIDwvRm9ybVByb3ZpZGVyPlxuICogICApO1xuICogfVxuICpcbiAqICBmdW5jdGlvbiBOZXN0ZWRJbnB1dCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciB9ID0gdXNlRm9ybUNvbnRleHQoKTsgLy8gcmV0cmlldmUgYWxsIGhvb2sgbWV0aG9kc1xuICogICByZXR1cm4gPGlucHV0IHsuLi5yZWdpc3RlcihcInRlc3RcIil9IC8+O1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IHVzZUZvcm1Db250ZXh0ID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChIb29rRm9ybUNvbnRleHQpO1xuLyoqXG4gKiBBIHByb3ZpZGVyIGNvbXBvbmVudCB0aGF0IHByb3BhZ2F0ZXMgdGhlIGB1c2VGb3JtYCBtZXRob2RzIHRvIGFsbCBjaGlsZHJlbiBjb21wb25lbnRzIHZpYSBbUmVhY3QgQ29udGV4dF0oaHR0cHM6Ly9yZWFjdC5kZXYvcmVmZXJlbmNlL3JlYWN0L3VzZUNvbnRleHQpIEFQSS4gVG8gYmUgdXNlZCB3aXRoIHtAbGluayB1c2VGb3JtQ29udGV4dH0uXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZvcm1jb250ZXh0KSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjctZm9ybS1jb250ZXh0LXl0dWRpKVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIGFsbCB1c2VGb3JtIG1ldGhvZHNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtKCk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEZvcm1Qcm92aWRlciB7Li4ubWV0aG9kc30gPlxuICogICAgICAgPGZvcm0gb25TdWJtaXQ9e21ldGhvZHMuaGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICAgIDxOZXN0ZWRJbnB1dCAvPlxuICogICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgICA8L2Zvcm0+XG4gKiAgICAgPC9Gb3JtUHJvdmlkZXI+XG4gKiAgICk7XG4gKiB9XG4gKlxuICogIGZ1bmN0aW9uIE5lc3RlZElucHV0KCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyIH0gPSB1c2VGb3JtQ29udGV4dCgpOyAvLyByZXRyaWV2ZSBhbGwgaG9vayBtZXRob2RzXG4gKiAgIHJldHVybiA8aW5wdXQgey4uLnJlZ2lzdGVyKFwidGVzdFwiKX0gLz47XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgRm9ybVByb3ZpZGVyID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgLi4uZGF0YSB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEhvb2tGb3JtQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZGF0YSB9LCBjaGlsZHJlbikpO1xufTtcblxudmFyIGdldFByb3h5Rm9ybVN0YXRlID0gKGZvcm1TdGF0ZSwgY29udHJvbCwgbG9jYWxQcm94eUZvcm1TdGF0ZSwgaXNSb290ID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgZGVmYXVsdFZhbHVlczogY29udHJvbC5fZGVmYXVsdFZhbHVlcyxcbiAgICB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZvcm1TdGF0ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIHtcbiAgICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9rZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlW19rZXldICE9PSBWQUxJREFUSU9OX01PREUuYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlW19rZXldID0gIWlzUm9vdCB8fCBWQUxJREFUSU9OX01PREUuYWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbFByb3h5Rm9ybVN0YXRlICYmIChsb2NhbFByb3h5Rm9ybVN0YXRlW19rZXldID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1TdGF0ZVtfa2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuXG4vKipcbiAqIFRoaXMgY3VzdG9tIGhvb2sgYWxsb3dzIHlvdSB0byBzdWJzY3JpYmUgdG8gZWFjaCBmb3JtIHN0YXRlLCBhbmQgaXNvbGF0ZSB0aGUgcmUtcmVuZGVyIGF0IHRoZSBjdXN0b20gaG9vayBsZXZlbC4gSXQgaGFzIGl0cyBzY29wZSBpbiB0ZXJtcyBvZiBmb3JtIHN0YXRlIHN1YnNjcmlwdGlvbiwgc28gaXQgd291bGQgbm90IGFmZmVjdCBvdGhlciB1c2VGb3JtU3RhdGUgYW5kIHVzZUZvcm0uIFVzaW5nIHRoaXMgaG9vayBjYW4gcmVkdWNlIHRoZSByZS1yZW5kZXIgaW1wYWN0IG9uIGxhcmdlIGFuZCBjb21wbGV4IGZvcm0gYXBwbGljYXRpb24uXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZvcm1zdGF0ZSkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdXNlZm9ybXN0YXRlLTc1eGx5KVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIGluY2x1ZGUgb3B0aW9ucyBvbiBzcGVjaWZ5IGZpZWxkcyB0byBzdWJzY3JpYmUuIHtAbGluayBVc2VGb3JtU3RhdGVSZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyLCBoYW5kbGVTdWJtaXQsIGNvbnRyb2wgfSA9IHVzZUZvcm0oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICBmaXJzdE5hbWU6IFwiZmlyc3ROYW1lXCJcbiAqICAgfX0pO1xuICogICBjb25zdCB7IGRpcnR5RmllbGRzIH0gPSB1c2VGb3JtU3RhdGUoe1xuICogICAgIGNvbnRyb2xcbiAqICAgfSk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gKGRhdGEpID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICA8aW5wdXQgey4uLnJlZ2lzdGVyKFwiZmlyc3ROYW1lXCIpfSBwbGFjZWhvbGRlcj1cIkZpcnN0IE5hbWVcIiAvPlxuICogICAgICAge2RpcnR5RmllbGRzLmZpcnN0TmFtZSAmJiA8cD5GaWVsZCBpcyBkaXJ0eS48L3A+fVxuICogICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGb3JtU3RhdGUocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCB7IGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIGRpc2FibGVkLCBuYW1lLCBleGFjdCB9ID0gcHJvcHMgfHwge307XG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGNvbnRyb2wuX2Zvcm1TdGF0ZSk7XG4gICAgY29uc3QgX2xvY2FsUHJveHlGb3JtU3RhdGUgPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxuICAgICAgICB0b3VjaGVkRmllbGRzOiBmYWxzZSxcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcnM6IGZhbHNlLFxuICAgIH0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gY29udHJvbC5fc3Vic2NyaWJlKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZm9ybVN0YXRlOiBfbG9jYWxQcm94eUZvcm1TdGF0ZS5jdXJyZW50LFxuICAgICAgICBleGFjdCxcbiAgICAgICAgY2FsbGJhY2s6IChmb3JtU3RhdGUpID0+IHtcbiAgICAgICAgICAgICFkaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgIHVwZGF0ZUZvcm1TdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgLi4uZm9ybVN0YXRlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pLCBbbmFtZSwgZGlzYWJsZWQsIGV4YWN0XSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudC5pc1ZhbGlkICYmIGNvbnRyb2wuX3NldFZhbGlkKHRydWUpO1xuICAgIH0sIFtjb250cm9sXSk7XG4gICAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gZ2V0UHJveHlGb3JtU3RhdGUoZm9ybVN0YXRlLCBjb250cm9sLCBfbG9jYWxQcm94eUZvcm1TdGF0ZS5jdXJyZW50LCBmYWxzZSksIFtmb3JtU3RhdGUsIGNvbnRyb2xdKTtcbn1cblxudmFyIGlzU3RyaW5nID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuXG52YXIgZ2VuZXJhdGVXYXRjaE91dHB1dCA9IChuYW1lcywgX25hbWVzLCBmb3JtVmFsdWVzLCBpc0dsb2JhbCwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgaWYgKGlzU3RyaW5nKG5hbWVzKSkge1xuICAgICAgICBpc0dsb2JhbCAmJiBfbmFtZXMud2F0Y2guYWRkKG5hbWVzKTtcbiAgICAgICAgcmV0dXJuIGdldChmb3JtVmFsdWVzLCBuYW1lcywgZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZXMpKSB7XG4gICAgICAgIHJldHVybiBuYW1lcy5tYXAoKGZpZWxkTmFtZSkgPT4gKGlzR2xvYmFsICYmIF9uYW1lcy53YXRjaC5hZGQoZmllbGROYW1lKSxcbiAgICAgICAgICAgIGdldChmb3JtVmFsdWVzLCBmaWVsZE5hbWUpKSk7XG4gICAgfVxuICAgIGlzR2xvYmFsICYmIChfbmFtZXMud2F0Y2hBbGwgPSB0cnVlKTtcbiAgICByZXR1cm4gZm9ybVZhbHVlcztcbn07XG5cbnZhciBpc1ByaW1pdGl2ZSA9ICh2YWx1ZSkgPT4gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8ICFpc09iamVjdFR5cGUodmFsdWUpO1xuXG5mdW5jdGlvbiBkZWVwRXF1YWwob2JqZWN0MSwgb2JqZWN0MiwgX2ludGVybmFsX3Zpc2l0ZWQgPSBuZXcgV2Vha1NldCgpKSB7XG4gICAgaWYgKGlzUHJpbWl0aXZlKG9iamVjdDEpIHx8IGlzUHJpbWl0aXZlKG9iamVjdDIpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QxID09PSBvYmplY3QyO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlT2JqZWN0KG9iamVjdDEpICYmIGlzRGF0ZU9iamVjdChvYmplY3QyKSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0MS5nZXRUaW1lKCkgPT09IG9iamVjdDIuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iamVjdDEpO1xuICAgIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob2JqZWN0Mik7XG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKF9pbnRlcm5hbF92aXNpdGVkLmhhcyhvYmplY3QxKSB8fCBfaW50ZXJuYWxfdmlzaXRlZC5oYXMob2JqZWN0MikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF92aXNpdGVkLmFkZChvYmplY3QxKTtcbiAgICBfaW50ZXJuYWxfdmlzaXRlZC5hZGQob2JqZWN0Mik7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5czEpIHtcbiAgICAgICAgY29uc3QgdmFsMSA9IG9iamVjdDFba2V5XTtcbiAgICAgICAgaWYgKCFrZXlzMi5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSAhPT0gJ3JlZicpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbDIgPSBvYmplY3QyW2tleV07XG4gICAgICAgICAgICBpZiAoKGlzRGF0ZU9iamVjdCh2YWwxKSAmJiBpc0RhdGVPYmplY3QodmFsMikpIHx8XG4gICAgICAgICAgICAgICAgKGlzT2JqZWN0KHZhbDEpICYmIGlzT2JqZWN0KHZhbDIpKSB8fFxuICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHZhbDEpICYmIEFycmF5LmlzQXJyYXkodmFsMikpXG4gICAgICAgICAgICAgICAgPyAhZGVlcEVxdWFsKHZhbDEsIHZhbDIsIF9pbnRlcm5hbF92aXNpdGVkKVxuICAgICAgICAgICAgICAgIDogdmFsMSAhPT0gdmFsMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byBzdWJzY3JpYmUgdG8gZmllbGQgY2hhbmdlIGFuZCBpc29sYXRlIHJlLXJlbmRlcmluZyBhdCB0aGUgY29tcG9uZW50IGxldmVsLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNld2F0Y2gpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny10cy11c2V3YXRjaC1oOWk1ZSlcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCB7IGNvbnRyb2wgfSA9IHVzZUZvcm0oKTtcbiAqIGNvbnN0IHZhbHVlcyA9IHVzZVdhdGNoKHtcbiAqICAgbmFtZTogXCJmaWVsZE5hbWVcIlxuICogICBjb250cm9sLFxuICogfSlcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VXYXRjaChwcm9wcykge1xuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuICAgIGNvbnN0IHsgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgbmFtZSwgZGVmYXVsdFZhbHVlLCBkaXNhYmxlZCwgZXhhY3QsIGNvbXB1dGUsIH0gPSBwcm9wcyB8fCB7fTtcbiAgICBjb25zdCBfZGVmYXVsdFZhbHVlID0gUmVhY3QudXNlUmVmKGRlZmF1bHRWYWx1ZSk7XG4gICAgY29uc3QgX2NvbXB1dGUgPSBSZWFjdC51c2VSZWYoY29tcHV0ZSk7XG4gICAgY29uc3QgX2NvbXB1dGVGb3JtVmFsdWVzID0gUmVhY3QudXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgX3ByZXZDb250cm9sID0gUmVhY3QudXNlUmVmKGNvbnRyb2wpO1xuICAgIGNvbnN0IF9wcmV2TmFtZSA9IFJlYWN0LnVzZVJlZihuYW1lKTtcbiAgICBfY29tcHV0ZS5jdXJyZW50ID0gY29tcHV0ZTtcbiAgICBjb25zdCBbdmFsdWUsIHVwZGF0ZVZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gY29udHJvbC5fZ2V0V2F0Y2gobmFtZSwgX2RlZmF1bHRWYWx1ZS5jdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIF9jb21wdXRlLmN1cnJlbnQgPyBfY29tcHV0ZS5jdXJyZW50KGRlZmF1bHRWYWx1ZSkgOiBkZWZhdWx0VmFsdWU7XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0Q3VycmVudE91dHB1dCA9IFJlYWN0LnVzZUNhbGxiYWNrKCh2YWx1ZXMpID0+IHtcbiAgICAgICAgY29uc3QgZm9ybVZhbHVlcyA9IGdlbmVyYXRlV2F0Y2hPdXRwdXQobmFtZSwgY29udHJvbC5fbmFtZXMsIHZhbHVlcyB8fCBjb250cm9sLl9mb3JtVmFsdWVzLCBmYWxzZSwgX2RlZmF1bHRWYWx1ZS5jdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIF9jb21wdXRlLmN1cnJlbnQgPyBfY29tcHV0ZS5jdXJyZW50KGZvcm1WYWx1ZXMpIDogZm9ybVZhbHVlcztcbiAgICB9LCBbY29udHJvbC5fZm9ybVZhbHVlcywgY29udHJvbC5fbmFtZXMsIG5hbWVdKTtcbiAgICBjb25zdCByZWZyZXNoVmFsdWUgPSBSZWFjdC51c2VDYWxsYmFjaygodmFsdWVzKSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1WYWx1ZXMgPSBnZW5lcmF0ZVdhdGNoT3V0cHV0KG5hbWUsIGNvbnRyb2wuX25hbWVzLCB2YWx1ZXMgfHwgY29udHJvbC5fZm9ybVZhbHVlcywgZmFsc2UsIF9kZWZhdWx0VmFsdWUuY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoX2NvbXB1dGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkRm9ybVZhbHVlcyA9IF9jb21wdXRlLmN1cnJlbnQoZm9ybVZhbHVlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoY29tcHV0ZWRGb3JtVmFsdWVzLCBfY29tcHV0ZUZvcm1WYWx1ZXMuY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoY29tcHV0ZWRGb3JtVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgX2NvbXB1dGVGb3JtVmFsdWVzLmN1cnJlbnQgPSBjb21wdXRlZEZvcm1WYWx1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoZm9ybVZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbC5fZm9ybVZhbHVlcywgY29udHJvbC5fbmFtZXMsIGRpc2FibGVkLCBuYW1lXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChfcHJldkNvbnRyb2wuY3VycmVudCAhPT0gY29udHJvbCB8fFxuICAgICAgICAgICAgIWRlZXBFcXVhbChfcHJldk5hbWUuY3VycmVudCwgbmFtZSkpIHtcbiAgICAgICAgICAgIF9wcmV2Q29udHJvbC5jdXJyZW50ID0gY29udHJvbDtcbiAgICAgICAgICAgIF9wcmV2TmFtZS5jdXJyZW50ID0gbmFtZTtcbiAgICAgICAgICAgIHJlZnJlc2hWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sLl9zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGZvcm1TdGF0ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlczogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleGFjdCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoZm9ybVN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVmcmVzaFZhbHVlKGZvcm1TdGF0ZS52YWx1ZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSwgW2NvbnRyb2wsIGV4YWN0LCBuYW1lLCByZWZyZXNoVmFsdWVdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gY29udHJvbC5fcmVtb3ZlVW5tb3VudGVkKCkpO1xuICAgIC8vIElmIG5hbWUgb3IgY29udHJvbCBjaGFuZ2VkIGZvciB0aGlzIHJlbmRlciwgc3luY2hyb25vdXNseSByZWZsZWN0IHRoZVxuICAgIC8vIGxhdGVzdCB2YWx1ZSBzbyBjYWxsZXJzIChsaWtlIHVzZUNvbnRyb2xsZXIpIHNlZSB0aGUgY29ycmVjdCB2YWx1ZVxuICAgIC8vIGltbWVkaWF0ZWx5IG9uIHRoZSBzYW1lIHJlbmRlci5cbiAgICAvLyBPcHRpbWl6ZTogQ2hlY2sgY29udHJvbCByZWZlcmVuY2UgZmlyc3QgYmVmb3JlIGV4cGVuc2l2ZSBkZWVwRXF1YWxcbiAgICBjb25zdCBjb250cm9sQ2hhbmdlZCA9IF9wcmV2Q29udHJvbC5jdXJyZW50ICE9PSBjb250cm9sO1xuICAgIGNvbnN0IHByZXZOYW1lID0gX3ByZXZOYW1lLmN1cnJlbnQ7XG4gICAgLy8gQ2FjaGUgdGhlIGNvbXB1dGVkIG91dHB1dCB0byBhdm9pZCBkdXBsaWNhdGUgY2FsbHMgd2l0aGluIHRoZSBzYW1lIHJlbmRlclxuICAgIC8vIFdlIGluY2x1ZGUgc2hvdWxkUmV0dXJuSW1tZWRpYXRlIGluIGRlcHMgdG8gZW5zdXJlIHByb3BlciByZWNvbXB1dGF0aW9uXG4gICAgY29uc3QgY29tcHV0ZWRPdXRwdXQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lQ2hhbmdlZCA9ICFjb250cm9sQ2hhbmdlZCAmJiAhZGVlcEVxdWFsKHByZXZOYW1lLCBuYW1lKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkUmV0dXJuSW1tZWRpYXRlID0gY29udHJvbENoYW5nZWQgfHwgbmFtZUNoYW5nZWQ7XG4gICAgICAgIHJldHVybiBzaG91bGRSZXR1cm5JbW1lZGlhdGUgPyBnZXRDdXJyZW50T3V0cHV0KCkgOiBudWxsO1xuICAgIH0sIFtkaXNhYmxlZCwgY29udHJvbENoYW5nZWQsIG5hbWUsIHByZXZOYW1lLCBnZXRDdXJyZW50T3V0cHV0XSk7XG4gICAgcmV0dXJuIGNvbXB1dGVkT3V0cHV0ICE9PSBudWxsID8gY29tcHV0ZWRPdXRwdXQgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byB3b3JrIHdpdGggY29udHJvbGxlZCBjb21wb25lbnQsIHRoaXMgZnVuY3Rpb24gcHJvdmlkZSB5b3Ugd2l0aCBib3RoIGZvcm0gYW5kIGZpZWxkIGxldmVsIHN0YXRlLiBSZS1yZW5kZXIgaXMgaXNvbGF0ZWQgYXQgdGhlIGhvb2sgbGV2ZWwuXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWNvbnRyb2xsZXIpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3VzZWNvbnRyb2xsZXItMG84cHgpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdGhlIHBhdGggbmFtZSB0byB0aGUgZm9ybSBmaWVsZCB2YWx1ZSwgYW5kIHZhbGlkYXRpb24gcnVsZXMuXG4gKlxuICogQHJldHVybnMgZmllbGQgcHJvcGVydGllcywgZmllbGQgYW5kIGZvcm0gc3RhdGUuIHtAbGluayBVc2VDb250cm9sbGVyUmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIElucHV0KHByb3BzKSB7XG4gKiAgIGNvbnN0IHsgZmllbGQsIGZpZWxkU3RhdGUsIGZvcm1TdGF0ZSB9ID0gdXNlQ29udHJvbGxlcihwcm9wcyk7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDxpbnB1dCB7Li4uZmllbGR9IHBsYWNlaG9sZGVyPXtwcm9wcy5uYW1lfSAvPlxuICogICAgICAgPHA+e2ZpZWxkU3RhdGUuaXNUb3VjaGVkICYmIFwiVG91Y2hlZFwifTwvcD5cbiAqICAgICAgIDxwPntmb3JtU3RhdGUuaXNTdWJtaXR0ZWQgPyBcInN1Ym1pdHRlZFwiIDogXCJcIn08L3A+XG4gKiAgICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlQ29udHJvbGxlcihwcm9wcykge1xuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuICAgIGNvbnN0IHsgbmFtZSwgZGlzYWJsZWQsIGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIHNob3VsZFVucmVnaXN0ZXIsIGRlZmF1bHRWYWx1ZSwgfSA9IHByb3BzO1xuICAgIGNvbnN0IGlzQXJyYXlGaWVsZCA9IGlzTmFtZUluRmllbGRBcnJheShjb250cm9sLl9uYW1lcy5hcnJheSwgbmFtZSk7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlTWVtbyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gZ2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUsIGdldChjb250cm9sLl9kZWZhdWx0VmFsdWVzLCBuYW1lLCBkZWZhdWx0VmFsdWUpKSwgW2NvbnRyb2wsIG5hbWUsIGRlZmF1bHRWYWx1ZV0pO1xuICAgIGNvbnN0IHZhbHVlID0gdXNlV2F0Y2goe1xuICAgICAgICBjb250cm9sLFxuICAgICAgICBuYW1lLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZU1lbW8sXG4gICAgICAgIGV4YWN0OiB0cnVlLFxuICAgIH0pO1xuICAgIGNvbnN0IGZvcm1TdGF0ZSA9IHVzZUZvcm1TdGF0ZSh7XG4gICAgICAgIGNvbnRyb2wsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGV4YWN0OiB0cnVlLFxuICAgIH0pO1xuICAgIGNvbnN0IF9wcm9wcyA9IFJlYWN0LnVzZVJlZihwcm9wcyk7XG4gICAgY29uc3QgX3ByZXZpb3VzTmFtZVJlZiA9IFJlYWN0LnVzZVJlZih1bmRlZmluZWQpO1xuICAgIGNvbnN0IF9yZWdpc3RlclByb3BzID0gUmVhY3QudXNlUmVmKGNvbnRyb2wucmVnaXN0ZXIobmFtZSwge1xuICAgICAgICAuLi5wcm9wcy5ydWxlcyxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIC4uLihpc0Jvb2xlYW4ocHJvcHMuZGlzYWJsZWQpID8geyBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQgfSA6IHt9KSxcbiAgICB9KSk7XG4gICAgX3Byb3BzLmN1cnJlbnQgPSBwcm9wcztcbiAgICBjb25zdCBmaWVsZFN0YXRlID0gUmVhY3QudXNlTWVtbygoKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwge1xuICAgICAgICBpbnZhbGlkOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSxcbiAgICAgICAgfSxcbiAgICAgICAgaXNEaXJ0eToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gISFnZXQoZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBuYW1lKSxcbiAgICAgICAgfSxcbiAgICAgICAgaXNUb3VjaGVkOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSksXG4gICAgICAgIH0sXG4gICAgICAgIGlzVmFsaWRhdGluZzoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gISFnZXQoZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gZ2V0KGZvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgIH0pLCBbZm9ybVN0YXRlLCBuYW1lXSk7XG4gICAgY29uc3Qgb25DaGFuZ2UgPSBSZWFjdC51c2VDYWxsYmFjaygoZXZlbnQpID0+IF9yZWdpc3RlclByb3BzLmN1cnJlbnQub25DaGFuZ2Uoe1xuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiBnZXRFdmVudFZhbHVlKGV2ZW50KSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IEVWRU5UUy5DSEFOR0UsXG4gICAgfSksIFtuYW1lXSk7XG4gICAgY29uc3Qgb25CbHVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4gX3JlZ2lzdGVyUHJvcHMuY3VycmVudC5vbkJsdXIoe1xuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiBnZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSksXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiBFVkVOVFMuQkxVUixcbiAgICB9KSwgW25hbWUsIGNvbnRyb2wuX2Zvcm1WYWx1ZXNdKTtcbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VDYWxsYmFjaygoZWxtKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGlmIChmaWVsZCAmJiBlbG0pIHtcbiAgICAgICAgICAgIGZpZWxkLl9mLnJlZiA9IHtcbiAgICAgICAgICAgICAgICBmb2N1czogKCkgPT4gZWxtLmZvY3VzICYmIGVsbS5mb2N1cygpLFxuICAgICAgICAgICAgICAgIHNlbGVjdDogKCkgPT4gZWxtLnNlbGVjdCAmJiBlbG0uc2VsZWN0KCksXG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHk6IChtZXNzYWdlKSA9PiBlbG0uc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgcmVwb3J0VmFsaWRpdHk6ICgpID0+IGVsbS5yZXBvcnRWYWxpZGl0eSgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sLl9maWVsZHMsIG5hbWVdKTtcbiAgICBjb25zdCBmaWVsZCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIC4uLihpc0Jvb2xlYW4oZGlzYWJsZWQpIHx8IGZvcm1TdGF0ZS5kaXNhYmxlZFxuICAgICAgICAgICAgPyB7IGRpc2FibGVkOiBmb3JtU3RhdGUuZGlzYWJsZWQgfHwgZGlzYWJsZWQgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIG9uQ2hhbmdlLFxuICAgICAgICBvbkJsdXIsXG4gICAgICAgIHJlZixcbiAgICB9KSwgW25hbWUsIGRpc2FibGVkLCBmb3JtU3RhdGUuZGlzYWJsZWQsIG9uQ2hhbmdlLCBvbkJsdXIsIHJlZiwgdmFsdWVdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBfc2hvdWxkVW5yZWdpc3RlckZpZWxkID0gY29udHJvbC5fb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyIHx8IHNob3VsZFVucmVnaXN0ZXI7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzTmFtZSA9IF9wcmV2aW91c05hbWVSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHByZXZpb3VzTmFtZSAmJiBwcmV2aW91c05hbWUgIT09IG5hbWUgJiYgIWlzQXJyYXlGaWVsZCkge1xuICAgICAgICAgICAgY29udHJvbC51bnJlZ2lzdGVyKHByZXZpb3VzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbC5yZWdpc3RlcihuYW1lLCB7XG4gICAgICAgICAgICAuLi5fcHJvcHMuY3VycmVudC5ydWxlcyxcbiAgICAgICAgICAgIC4uLihpc0Jvb2xlYW4oX3Byb3BzLmN1cnJlbnQuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgPyB7IGRpc2FibGVkOiBfcHJvcHMuY3VycmVudC5kaXNhYmxlZCB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB1cGRhdGVNb3VudGVkID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChjb250cm9sLl9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLl9mKSB7XG4gICAgICAgICAgICAgICAgZmllbGQuX2YubW91bnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdXBkYXRlTW91bnRlZChuYW1lLCB0cnVlKTtcbiAgICAgICAgaWYgKF9zaG91bGRVbnJlZ2lzdGVyRmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2xvbmVPYmplY3QoZ2V0KGNvbnRyb2wuX29wdGlvbnMuZGVmYXVsdFZhbHVlcywgbmFtZSwgX3Byb3BzLmN1cnJlbnQuZGVmYXVsdFZhbHVlKSk7XG4gICAgICAgICAgICBzZXQoY29udHJvbC5fZGVmYXVsdFZhbHVlcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBzZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICFpc0FycmF5RmllbGQgJiYgY29udHJvbC5yZWdpc3RlcihuYW1lKTtcbiAgICAgICAgX3ByZXZpb3VzTmFtZVJlZi5jdXJyZW50ID0gbmFtZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIChpc0FycmF5RmllbGRcbiAgICAgICAgICAgICAgICA/IF9zaG91bGRVbnJlZ2lzdGVyRmllbGQgJiYgIWNvbnRyb2wuX3N0YXRlLmFjdGlvblxuICAgICAgICAgICAgICAgIDogX3Nob3VsZFVucmVnaXN0ZXJGaWVsZClcbiAgICAgICAgICAgICAgICA/IGNvbnRyb2wudW5yZWdpc3RlcihuYW1lKVxuICAgICAgICAgICAgICAgIDogdXBkYXRlTW91bnRlZChuYW1lLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgfSwgW25hbWUsIGNvbnRyb2wsIGlzQXJyYXlGaWVsZCwgc2hvdWxkVW5yZWdpc3Rlcl0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnRyb2wuX3NldERpc2FibGVkRmllbGQoe1xuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICB9KTtcbiAgICB9LCBbZGlzYWJsZWQsIG5hbWUsIGNvbnRyb2xdKTtcbiAgICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBmaWVsZCxcbiAgICAgICAgZm9ybVN0YXRlLFxuICAgICAgICBmaWVsZFN0YXRlLFxuICAgIH0pLCBbZmllbGQsIGZvcm1TdGF0ZSwgZmllbGRTdGF0ZV0pO1xufVxuXG4vKipcbiAqIENvbXBvbmVudCBiYXNlZCBvbiBgdXNlQ29udHJvbGxlcmAgaG9vayB0byB3b3JrIHdpdGggY29udHJvbGxlZCBjb21wb25lbnQuXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWNvbnRyb2xsZXIvY29udHJvbGxlcikg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY2LWNvbnRyb2xsZXItdHMtand5encpIOKAoiBbVmlkZW9dKGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9TjJVTmtfVUNWeUEpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdGhlIHBhdGggbmFtZSB0byB0aGUgZm9ybSBmaWVsZCB2YWx1ZSwgYW5kIHZhbGlkYXRpb24gcnVsZXMuXG4gKlxuICogQHJldHVybnMgcHJvdmlkZSBmaWVsZCBoYW5kbGVyIGZ1bmN0aW9ucywgZmllbGQgYW5kIGZvcm0gc3RhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IGNvbnRyb2wgfSA9IHVzZUZvcm08Rm9ybVZhbHVlcz4oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICAgIHRlc3Q6IFwiXCJcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybT5cbiAqICAgICAgIDxDb250cm9sbGVyXG4gKiAgICAgICAgIGNvbnRyb2w9e2NvbnRyb2x9XG4gKiAgICAgICAgIG5hbWU9XCJ0ZXN0XCJcbiAqICAgICAgICAgcmVuZGVyPXsoeyBmaWVsZDogeyBvbkNoYW5nZSwgb25CbHVyLCB2YWx1ZSwgcmVmIH0sIGZvcm1TdGF0ZSwgZmllbGRTdGF0ZSB9KSA9PiAoXG4gKiAgICAgICAgICAgPD5cbiAqICAgICAgICAgICAgIDxpbnB1dFxuICogICAgICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9IC8vIHNlbmQgdmFsdWUgdG8gaG9vayBmb3JtXG4gKiAgICAgICAgICAgICAgIG9uQmx1cj17b25CbHVyfSAvLyBub3RpZnkgd2hlbiBpbnB1dCBpcyB0b3VjaGVkXG4gKiAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX0gLy8gcmV0dXJuIHVwZGF0ZWQgdmFsdWVcbiAqICAgICAgICAgICAgICAgcmVmPXtyZWZ9IC8vIHNldCByZWYgZm9yIGZvY3VzIG1hbmFnZW1lbnRcbiAqICAgICAgICAgICAgIC8+XG4gKiAgICAgICAgICAgICA8cD57Zm9ybVN0YXRlLmlzU3VibWl0dGVkID8gXCJzdWJtaXR0ZWRcIiA6IFwiXCJ9PC9wPlxuICogICAgICAgICAgICAgPHA+e2ZpZWxkU3RhdGUuaXNUb3VjaGVkID8gXCJ0b3VjaGVkXCIgOiBcIlwifTwvcD5cbiAqICAgICAgICAgICA8Lz5cbiAqICAgICAgICAgKX1cbiAqICAgICAgIC8+XG4gKiAgICAgPC9mb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IENvbnRyb2xsZXIgPSAocHJvcHMpID0+IHByb3BzLnJlbmRlcih1c2VDb250cm9sbGVyKHByb3BzKSk7XG5cbmNvbnN0IGZsYXR0ZW4gPSAob2JqKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICBpZiAoaXNPYmplY3RUeXBlKG9ialtrZXldKSAmJiBvYmpba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbmVzdGVkID0gZmxhdHRlbihvYmpba2V5XSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5lc3RlZEtleSBvZiBPYmplY3Qua2V5cyhuZXN0ZWQpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2Ake2tleX0uJHtuZXN0ZWRLZXl9YF0gPSBuZXN0ZWRbbmVzdGVkS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbmNvbnN0IFBPU1RfUkVRVUVTVCA9ICdwb3N0Jztcbi8qKlxuICogRm9ybSBjb21wb25lbnQgdG8gbWFuYWdlIHN1Ym1pc3Npb24uXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdG8gc2V0dXAgc3VibWlzc2lvbiBkZXRhaWwuIHtAbGluayBGb3JtUHJvcHN9XG4gKlxuICogQHJldHVybnMgZm9ybSBjb21wb25lbnQgb3IgaGVhZGxlc3MgcmVuZGVyIHByb3AuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IGNvbnRyb2wsIGZvcm1TdGF0ZTogeyBlcnJvcnMgfSB9ID0gdXNlRm9ybSgpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Rm9ybSBhY3Rpb249XCIvYXBpXCIgY29udHJvbD17Y29udHJvbH0+XG4gKiAgICAgICA8aW5wdXQgey4uLnJlZ2lzdGVyKFwibmFtZVwiKX0gLz5cbiAqICAgICAgIDxwPntlcnJvcnM/LnJvb3Q/LnNlcnZlciAmJiAnU2VydmVyIGVycm9yJ308L3A+XG4gKiAgICAgICA8YnV0dG9uPlN1Ym1pdDwvYnV0dG9uPlxuICogICAgIDwvRm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBGb3JtKHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgb25TdWJtaXQsIGNoaWxkcmVuLCBhY3Rpb24sIG1ldGhvZCA9IFBPU1RfUkVRVUVTVCwgaGVhZGVycywgZW5jVHlwZSwgb25FcnJvciwgcmVuZGVyLCBvblN1Y2Nlc3MsIHZhbGlkYXRlU3RhdHVzLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgICBjb25zdCBzdWJtaXQgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIGxldCB0eXBlID0gJyc7XG4gICAgICAgIGF3YWl0IGNvbnRyb2wuaGFuZGxlU3VibWl0KGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgbGV0IGZvcm1EYXRhSnNvbiA9ICcnO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YUpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICBjb25zdCBmbGF0dGVuRm9ybVZhbHVlcyA9IGZsYXR0ZW4oY29udHJvbC5fZm9ybVZhbHVlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmbGF0dGVuRm9ybVZhbHVlcykge1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIGZsYXR0ZW5Gb3JtVmFsdWVzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uU3VibWl0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25TdWJtaXQoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGFKc29uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFN0cmluZ2lmeVN1Ym1pc3Npb25EYXRhID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyAmJiBoZWFkZXJzWydDb250ZW50LVR5cGUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY1R5cGUsXG4gICAgICAgICAgICAgICAgICAgIF0uc29tZSgodmFsdWUpID0+IHZhbHVlICYmIHZhbHVlLmluY2x1ZGVzKCdqc29uJykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFN0cmluZyhhY3Rpb24pLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4oZW5jVHlwZSAmJiBlbmNUeXBlICE9PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7ICdDb250ZW50LVR5cGUnOiBlbmNUeXBlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2hvdWxkU3RyaW5naWZ5U3VibWlzc2lvbkRhdGEgPyBmb3JtRGF0YUpzb24gOiBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbGlkYXRlU3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAhdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzcG9uc2Uuc3RhdHVzIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA+PSAzMDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yICYmIG9uRXJyb3IoeyByZXNwb25zZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBTdHJpbmcocmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzcyAmJiBvblN1Y2Nlc3MoeyByZXNwb25zZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yICYmIG9uRXJyb3IoeyBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKGV2ZW50KTtcbiAgICAgICAgaWYgKGhhc0Vycm9yICYmIHByb3BzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgIHByb3BzLmNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3BzLmNvbnRyb2wuc2V0RXJyb3IoJ3Jvb3Quc2VydmVyJywge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0TW91bnRlZCh0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHJlbmRlciA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByZW5kZXIoe1xuICAgICAgICBzdWJtaXQsXG4gICAgfSkpKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCB7IG5vVmFsaWRhdGU6IG1vdW50ZWQsIGFjdGlvbjogYWN0aW9uLCBtZXRob2Q6IG1ldGhvZCwgZW5jVHlwZTogZW5jVHlwZSwgb25TdWJtaXQ6IHN1Ym1pdCwgLi4ucmVzdCB9LCBjaGlsZHJlbikpO1xufVxuXG52YXIgYXBwZW5kRXJyb3JzID0gKG5hbWUsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZXJyb3JzLCB0eXBlLCBtZXNzYWdlKSA9PiB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWFcbiAgICA/IHtcbiAgICAgICAgLi4uZXJyb3JzW25hbWVdLFxuICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgLi4uKGVycm9yc1tuYW1lXSAmJiBlcnJvcnNbbmFtZV0udHlwZXMgPyBlcnJvcnNbbmFtZV0udHlwZXMgOiB7fSksXG4gICAgICAgICAgICBbdHlwZV06IG1lc3NhZ2UgfHwgdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9XG4gICAgOiB7fTtcblxudmFyIGNvbnZlcnRUb0FycmF5UGF5bG9hZCA9ICh2YWx1ZSkgPT4gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcblxudmFyIGNyZWF0ZVN1YmplY3QgPSAoKSA9PiB7XG4gICAgbGV0IF9vYnNlcnZlcnMgPSBbXTtcbiAgICBjb25zdCBuZXh0ID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgX29ic2VydmVycykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gKG9ic2VydmVyKSA9PiB7XG4gICAgICAgIF9vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIF9vYnNlcnZlcnMgPSBfb2JzZXJ2ZXJzLmZpbHRlcigobykgPT4gbyAhPT0gb2JzZXJ2ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICBfb2JzZXJ2ZXJzID0gW107XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYnNlcnZlcnM7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQsXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgdW5zdWJzY3JpYmUsXG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIGV4dHJhY3RGb3JtVmFsdWVzKGZpZWxkc1N0YXRlLCBmb3JtVmFsdWVzKSB7XG4gICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZmllbGRzU3RhdGUpIHtcbiAgICAgICAgaWYgKGZpZWxkc1N0YXRlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU3RhdGUgPSBmaWVsZHNTdGF0ZVtrZXldO1xuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IGZvcm1WYWx1ZXNba2V5XTtcbiAgICAgICAgICAgIGlmIChmaWVsZFN0YXRlICYmIGlzT2JqZWN0KGZpZWxkU3RhdGUpICYmIGZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXN0ZWRGaWVsZHNTdGF0ZSA9IGV4dHJhY3RGb3JtVmFsdWVzKGZpZWxkU3RhdGUsIGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChuZXN0ZWRGaWVsZHNTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSBuZXN0ZWRGaWVsZHNTdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZHNTdGF0ZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSBmaWVsZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5cbnZhciBpc0VtcHR5T2JqZWN0ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgIU9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG5cbnZhciBpc0ZpbGVJbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdmaWxlJztcblxudmFyIGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIGlzSFRNTEVsZW1lbnQgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIWlzV2ViKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb3duZXIgPSB2YWx1ZSA/IHZhbHVlLm93bmVyRG9jdW1lbnQgOiAwO1xuICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZlxuICAgICAgICAob3duZXIgJiYgb3duZXIuZGVmYXVsdFZpZXcgPyBvd25lci5kZWZhdWx0Vmlldy5IVE1MRWxlbWVudCA6IEhUTUxFbGVtZW50KSk7XG59O1xuXG52YXIgaXNNdWx0aXBsZVNlbGVjdCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09IGBzZWxlY3QtbXVsdGlwbGVgO1xuXG52YXIgaXNSYWRpb0lucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ3JhZGlvJztcblxudmFyIGlzUmFkaW9PckNoZWNrYm94ID0gKHJlZikgPT4gaXNSYWRpb0lucHV0KHJlZikgfHwgaXNDaGVja0JveElucHV0KHJlZik7XG5cbnZhciBsaXZlID0gKHJlZikgPT4gaXNIVE1MRWxlbWVudChyZWYpICYmIHJlZi5pc0Nvbm5lY3RlZDtcblxuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHVwZGF0ZVBhdGgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB1cGRhdGVQYXRoLnNsaWNlKDAsIC0xKS5sZW5ndGg7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gaXNVbmRlZmluZWQob2JqZWN0KSA/IGluZGV4KysgOiBvYmplY3RbdXBkYXRlUGF0aFtpbmRleCsrXV07XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiBpc0VtcHR5QXJyYXkob2JqKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhaXNVbmRlZmluZWQob2JqW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICBjb25zdCBwYXRocyA9IEFycmF5LmlzQXJyYXkocGF0aClcbiAgICAgICAgPyBwYXRoXG4gICAgICAgIDogaXNLZXkocGF0aClcbiAgICAgICAgICAgID8gW3BhdGhdXG4gICAgICAgICAgICA6IHN0cmluZ1RvUGF0aChwYXRoKTtcbiAgICBjb25zdCBjaGlsZE9iamVjdCA9IHBhdGhzLmxlbmd0aCA9PT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBwYXRocyk7XG4gICAgY29uc3QgaW5kZXggPSBwYXRocy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGtleSA9IHBhdGhzW2luZGV4XTtcbiAgICBpZiAoY2hpbGRPYmplY3QpIHtcbiAgICAgICAgZGVsZXRlIGNoaWxkT2JqZWN0W2tleV07XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gMCAmJlxuICAgICAgICAoKGlzT2JqZWN0KGNoaWxkT2JqZWN0KSAmJiBpc0VtcHR5T2JqZWN0KGNoaWxkT2JqZWN0KSkgfHxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNoaWxkT2JqZWN0KSAmJiBpc0VtcHR5QXJyYXkoY2hpbGRPYmplY3QpKSkpIHtcbiAgICAgICAgdW5zZXQob2JqZWN0LCBwYXRocy5zbGljZSgwLCAtMSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxuXG52YXIgb2JqZWN0SGFzRnVuY3Rpb24gPSAoZGF0YSkgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGF0YVtrZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gaXNUcmF2ZXJzYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAoaXNPYmplY3QodmFsdWUpICYmICFvYmplY3RIYXNGdW5jdGlvbih2YWx1ZSkpO1xufVxuZnVuY3Rpb24gbWFya0ZpZWxkc0RpcnR5KGRhdGEsIGZpZWxkcyA9IHt9KSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICBpZiAoaXNUcmF2ZXJzYWJsZShkYXRhW2tleV0pKSB7XG4gICAgICAgICAgICBmaWVsZHNba2V5XSA9IEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSA/IFtdIDoge307XG4gICAgICAgICAgICBtYXJrRmllbGRzRGlydHkoZGF0YVtrZXldLCBmaWVsZHNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzVW5kZWZpbmVkKGRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgIGZpZWxkc1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xufVxuZnVuY3Rpb24gZ2V0RGlydHlGaWVsZHMoZGF0YSwgZm9ybVZhbHVlcywgZGlydHlGaWVsZHNGcm9tVmFsdWVzKSB7XG4gICAgaWYgKCFkaXJ0eUZpZWxkc0Zyb21WYWx1ZXMpIHtcbiAgICAgICAgZGlydHlGaWVsZHNGcm9tVmFsdWVzID0gbWFya0ZpZWxkc0RpcnR5KGZvcm1WYWx1ZXMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChpc1RyYXZlcnNhYmxlKGRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChmb3JtVmFsdWVzKSB8fCBpc1ByaW1pdGl2ZShkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSA9IG1hcmtGaWVsZHNEaXJ0eShkYXRhW2tleV0sIEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSA/IFtdIDoge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0RGlydHlGaWVsZHMoZGF0YVtrZXldLCBpc051bGxPclVuZGVmaW5lZChmb3JtVmFsdWVzKSA/IHt9IDogZm9ybVZhbHVlc1trZXldLCBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSA9ICFkZWVwRXF1YWwoZGF0YVtrZXldLCBmb3JtVmFsdWVzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXM7XG59XG5cbmNvbnN0IGRlZmF1bHRSZXN1bHQgPSB7XG4gICAgdmFsdWU6IGZhbHNlLFxuICAgIGlzVmFsaWQ6IGZhbHNlLFxufTtcbmNvbnN0IHZhbGlkUmVzdWx0ID0geyB2YWx1ZTogdHJ1ZSwgaXNWYWxpZDogdHJ1ZSB9O1xudmFyIGdldENoZWNrYm94VmFsdWUgPSAob3B0aW9ucykgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG9wdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChvcHRpb24pID0+IG9wdGlvbiAmJiBvcHRpb24uY2hlY2tlZCAmJiAhb3B0aW9uLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgIC5tYXAoKG9wdGlvbikgPT4gb3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZXMsIGlzVmFsaWQ6ICEhdmFsdWVzLmxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zWzBdLmNoZWNrZWQgJiYgIW9wdGlvbnNbMF0uZGlzYWJsZWRcbiAgICAgICAgICAgID8gLy8gQHRzLWV4cGVjdC1lcnJvciBleHBlY3RlZCB0byB3b3JrIGluIHRoZSBicm93c2VyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5hdHRyaWJ1dGVzICYmICFpc1VuZGVmaW5lZChvcHRpb25zWzBdLmF0dHJpYnV0ZXMudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gaXNVbmRlZmluZWQob3B0aW9uc1swXS52YWx1ZSkgfHwgb3B0aW9uc1swXS52YWx1ZSA9PT0gJydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsaWRSZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyB2YWx1ZTogb3B0aW9uc1swXS52YWx1ZSwgaXNWYWxpZDogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgICAgIDogdmFsaWRSZXN1bHRcbiAgICAgICAgICAgIDogZGVmYXVsdFJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQ7XG59O1xuXG52YXIgZ2V0RmllbGRWYWx1ZUFzID0gKHZhbHVlLCB7IHZhbHVlQXNOdW1iZXIsIHZhbHVlQXNEYXRlLCBzZXRWYWx1ZUFzIH0pID0+IGlzVW5kZWZpbmVkKHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IHZhbHVlQXNOdW1iZXJcbiAgICAgICAgPyB2YWx1ZSA9PT0gJydcbiAgICAgICAgICAgID8gTmFOXG4gICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgICAgICAgICAgPyArdmFsdWVcbiAgICAgICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgIDogdmFsdWVBc0RhdGUgJiYgaXNTdHJpbmcodmFsdWUpXG4gICAgICAgICAgICA/IG5ldyBEYXRlKHZhbHVlKVxuICAgICAgICAgICAgOiBzZXRWYWx1ZUFzXG4gICAgICAgICAgICAgICAgPyBzZXRWYWx1ZUFzKHZhbHVlKVxuICAgICAgICAgICAgICAgIDogdmFsdWU7XG5cbmNvbnN0IGRlZmF1bHRSZXR1cm4gPSB7XG4gICAgaXNWYWxpZDogZmFsc2UsXG4gICAgdmFsdWU6IG51bGwsXG59O1xudmFyIGdldFJhZGlvVmFsdWUgPSAob3B0aW9ucykgPT4gQXJyYXkuaXNBcnJheShvcHRpb25zKVxuICAgID8gb3B0aW9ucy5yZWR1Y2UoKHByZXZpb3VzLCBvcHRpb24pID0+IG9wdGlvbiAmJiBvcHRpb24uY2hlY2tlZCAmJiAhb3B0aW9uLmRpc2FibGVkXG4gICAgICAgID8ge1xuICAgICAgICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb24udmFsdWUsXG4gICAgICAgIH1cbiAgICAgICAgOiBwcmV2aW91cywgZGVmYXVsdFJldHVybilcbiAgICA6IGRlZmF1bHRSZXR1cm47XG5cbmZ1bmN0aW9uIGdldEZpZWxkVmFsdWUoX2YpIHtcbiAgICBjb25zdCByZWYgPSBfZi5yZWY7XG4gICAgaWYgKGlzRmlsZUlucHV0KHJlZikpIHtcbiAgICAgICAgcmV0dXJuIHJlZi5maWxlcztcbiAgICB9XG4gICAgaWYgKGlzUmFkaW9JbnB1dChyZWYpKSB7XG4gICAgICAgIHJldHVybiBnZXRSYWRpb1ZhbHVlKF9mLnJlZnMpLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNNdWx0aXBsZVNlbGVjdChyZWYpKSB7XG4gICAgICAgIHJldHVybiBbLi4ucmVmLnNlbGVjdGVkT3B0aW9uc10ubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzQ2hlY2tCb3hJbnB1dChyZWYpKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGVja2JveFZhbHVlKF9mLnJlZnMpLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RmllbGRWYWx1ZUFzKGlzVW5kZWZpbmVkKHJlZi52YWx1ZSkgPyBfZi5yZWYudmFsdWUgOiByZWYudmFsdWUsIF9mKTtcbn1cblxudmFyIGdldFJlc29sdmVyT3B0aW9ucyA9IChmaWVsZHNOYW1lcywgX2ZpZWxkcywgY3JpdGVyaWFNb2RlLCBzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uKSA9PiB7XG4gICAgY29uc3QgZmllbGRzID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGZpZWxkc05hbWVzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBmaWVsZCAmJiBzZXQoZmllbGRzLCBuYW1lLCBmaWVsZC5fZik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyaXRlcmlhTW9kZSxcbiAgICAgICAgbmFtZXM6IFsuLi5maWVsZHNOYW1lc10sXG4gICAgICAgIGZpZWxkcyxcbiAgICAgICAgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbixcbiAgICB9O1xufTtcblxudmFyIGlzUmVnZXggPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuXG52YXIgZ2V0UnVsZVZhbHVlID0gKHJ1bGUpID0+IGlzVW5kZWZpbmVkKHJ1bGUpXG4gICAgPyBydWxlXG4gICAgOiBpc1JlZ2V4KHJ1bGUpXG4gICAgICAgID8gcnVsZS5zb3VyY2VcbiAgICAgICAgOiBpc09iamVjdChydWxlKVxuICAgICAgICAgICAgPyBpc1JlZ2V4KHJ1bGUudmFsdWUpXG4gICAgICAgICAgICAgICAgPyBydWxlLnZhbHVlLnNvdXJjZVxuICAgICAgICAgICAgICAgIDogcnVsZS52YWx1ZVxuICAgICAgICAgICAgOiBydWxlO1xuXG52YXIgZ2V0VmFsaWRhdGlvbk1vZGVzID0gKG1vZGUpID0+ICh7XG4gICAgaXNPblN1Ym1pdDogIW1vZGUgfHwgbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uU3VibWl0LFxuICAgIGlzT25CbHVyOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25CbHVyLFxuICAgIGlzT25DaGFuZ2U6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vbkNoYW5nZSxcbiAgICBpc09uQWxsOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUuYWxsLFxuICAgIGlzT25Ub3VjaDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uVG91Y2hlZCxcbn0pO1xuXG5jb25zdCBBU1lOQ19GVU5DVElPTiA9ICdBc3luY0Z1bmN0aW9uJztcbnZhciBoYXNQcm9taXNlVmFsaWRhdGlvbiA9IChmaWVsZFJlZmVyZW5jZSkgPT4gISFmaWVsZFJlZmVyZW5jZSAmJlxuICAgICEhZmllbGRSZWZlcmVuY2UudmFsaWRhdGUgJiZcbiAgICAhISgoaXNGdW5jdGlvbihmaWVsZFJlZmVyZW5jZS52YWxpZGF0ZSkgJiZcbiAgICAgICAgZmllbGRSZWZlcmVuY2UudmFsaWRhdGUuY29uc3RydWN0b3IubmFtZSA9PT0gQVNZTkNfRlVOQ1RJT04pIHx8XG4gICAgICAgIChpc09iamVjdChmaWVsZFJlZmVyZW5jZS52YWxpZGF0ZSkgJiZcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXMoZmllbGRSZWZlcmVuY2UudmFsaWRhdGUpLmZpbmQoKHZhbGlkYXRlRnVuY3Rpb24pID0+IHZhbGlkYXRlRnVuY3Rpb24uY29uc3RydWN0b3IubmFtZSA9PT0gQVNZTkNfRlVOQ1RJT04pKSk7XG5cbnZhciBoYXNWYWxpZGF0aW9uID0gKG9wdGlvbnMpID0+IG9wdGlvbnMubW91bnQgJiZcbiAgICAob3B0aW9ucy5yZXF1aXJlZCB8fFxuICAgICAgICBvcHRpb25zLm1pbiB8fFxuICAgICAgICBvcHRpb25zLm1heCB8fFxuICAgICAgICBvcHRpb25zLm1heExlbmd0aCB8fFxuICAgICAgICBvcHRpb25zLm1pbkxlbmd0aCB8fFxuICAgICAgICBvcHRpb25zLnBhdHRlcm4gfHxcbiAgICAgICAgb3B0aW9ucy52YWxpZGF0ZSk7XG5cbnZhciBpc1dhdGNoZWQgPSAobmFtZSwgX25hbWVzLCBpc0JsdXJFdmVudCkgPT4gIWlzQmx1ckV2ZW50ICYmXG4gICAgKF9uYW1lcy53YXRjaEFsbCB8fFxuICAgICAgICBfbmFtZXMud2F0Y2guaGFzKG5hbWUpIHx8XG4gICAgICAgIFsuLi5fbmFtZXMud2F0Y2hdLnNvbWUoKHdhdGNoTmFtZSkgPT4gbmFtZS5zdGFydHNXaXRoKHdhdGNoTmFtZSkgJiZcbiAgICAgICAgICAgIC9eXFwuXFx3Ky8udGVzdChuYW1lLnNsaWNlKHdhdGNoTmFtZS5sZW5ndGgpKSkpO1xuXG5jb25zdCBpdGVyYXRlRmllbGRzQnlBY3Rpb24gPSAoZmllbGRzLCBhY3Rpb24sIGZpZWxkc05hbWVzLCBhYm9ydEVhcmx5KSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgZmllbGRzTmFtZXMgfHwgT2JqZWN0LmtleXMoZmllbGRzKSkge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChmaWVsZHMsIGtleSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgeyBfZiwgLi4uY3VycmVudEZpZWxkIH0gPSBmaWVsZDtcbiAgICAgICAgICAgIGlmIChfZikge1xuICAgICAgICAgICAgICAgIGlmIChfZi5yZWZzICYmIF9mLnJlZnNbMF0gJiYgYWN0aW9uKF9mLnJlZnNbMF0sIGtleSkgJiYgIWFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9mLnJlZiAmJiBhY3Rpb24oX2YucmVmLCBfZi5uYW1lKSAmJiAhYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRlRmllbGRzQnlBY3Rpb24oY3VycmVudEZpZWxkLCBhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KGN1cnJlbnRGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGN1cnJlbnRGaWVsZCwgYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufTtcblxuZnVuY3Rpb24gc2NoZW1hRXJyb3JMb29rdXAoZXJyb3JzLCBfZmllbGRzLCBuYW1lKSB7XG4gICAgY29uc3QgZXJyb3IgPSBnZXQoZXJyb3JzLCBuYW1lKTtcbiAgICBpZiAoZXJyb3IgfHwgaXNLZXkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgbmFtZXMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgd2hpbGUgKG5hbWVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBuYW1lcy5qb2luKCcuJyk7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgIGNvbnN0IGZvdW5kRXJyb3IgPSBnZXQoZXJyb3JzLCBmaWVsZE5hbWUpO1xuICAgICAgICBpZiAoZmllbGQgJiYgIUFycmF5LmlzQXJyYXkoZmllbGQpICYmIG5hbWUgIT09IGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZEVycm9yICYmIGZvdW5kRXJyb3IudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZvdW5kRXJyb3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZEVycm9yICYmIGZvdW5kRXJyb3Iucm9vdCAmJiBmb3VuZEVycm9yLnJvb3QudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBgJHtmaWVsZE5hbWV9LnJvb3RgLFxuICAgICAgICAgICAgICAgIGVycm9yOiBmb3VuZEVycm9yLnJvb3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG5hbWVzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgIH07XG59XG5cbnZhciBzaG91bGRSZW5kZXJGb3JtU3RhdGUgPSAoZm9ybVN0YXRlRGF0YSwgX3Byb3h5Rm9ybVN0YXRlLCB1cGRhdGVGb3JtU3RhdGUsIGlzUm9vdCkgPT4ge1xuICAgIHVwZGF0ZUZvcm1TdGF0ZShmb3JtU3RhdGVEYXRhKTtcbiAgICBjb25zdCB7IG5hbWUsIC4uLmZvcm1TdGF0ZSB9ID0gZm9ybVN0YXRlRGF0YTtcbiAgICByZXR1cm4gKGlzRW1wdHlPYmplY3QoZm9ybVN0YXRlKSB8fFxuICAgICAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGUpLmxlbmd0aCA+PSBPYmplY3Qua2V5cyhfcHJveHlGb3JtU3RhdGUpLmxlbmd0aCB8fFxuICAgICAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGUpLmZpbmQoKGtleSkgPT4gX3Byb3h5Rm9ybVN0YXRlW2tleV0gPT09XG4gICAgICAgICAgICAoIWlzUm9vdCB8fCBWQUxJREFUSU9OX01PREUuYWxsKSkpO1xufTtcblxudmFyIHNob3VsZFN1YnNjcmliZUJ5TmFtZSA9IChuYW1lLCBzaWduYWxOYW1lLCBleGFjdCkgPT4gIW5hbWUgfHxcbiAgICAhc2lnbmFsTmFtZSB8fFxuICAgIG5hbWUgPT09IHNpZ25hbE5hbWUgfHxcbiAgICBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkuc29tZSgoY3VycmVudE5hbWUpID0+IGN1cnJlbnROYW1lICYmXG4gICAgICAgIChleGFjdFxuICAgICAgICAgICAgPyBjdXJyZW50TmFtZSA9PT0gc2lnbmFsTmFtZVxuICAgICAgICAgICAgOiBjdXJyZW50TmFtZS5zdGFydHNXaXRoKHNpZ25hbE5hbWUpIHx8XG4gICAgICAgICAgICAgICAgc2lnbmFsTmFtZS5zdGFydHNXaXRoKGN1cnJlbnROYW1lKSkpO1xuXG52YXIgc2tpcFZhbGlkYXRpb24gPSAoaXNCbHVyRXZlbnQsIGlzVG91Y2hlZCwgaXNTdWJtaXR0ZWQsIHJlVmFsaWRhdGVNb2RlLCBtb2RlKSA9PiB7XG4gICAgaWYgKG1vZGUuaXNPbkFsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc1N1Ym1pdHRlZCAmJiBtb2RlLmlzT25Ub3VjaCkge1xuICAgICAgICByZXR1cm4gIShpc1RvdWNoZWQgfHwgaXNCbHVyRXZlbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N1Ym1pdHRlZCA/IHJlVmFsaWRhdGVNb2RlLmlzT25CbHVyIDogbW9kZS5pc09uQmx1cikge1xuICAgICAgICByZXR1cm4gIWlzQmx1ckV2ZW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N1Ym1pdHRlZCA/IHJlVmFsaWRhdGVNb2RlLmlzT25DaGFuZ2UgOiBtb2RlLmlzT25DaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGlzQmx1ckV2ZW50O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciB1bnNldEVtcHR5QXJyYXkgPSAocmVmLCBuYW1lKSA9PiAhY29tcGFjdChnZXQocmVmLCBuYW1lKSkubGVuZ3RoICYmIHVuc2V0KHJlZiwgbmFtZSk7XG5cbnZhciB1cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yID0gKGVycm9ycywgZXJyb3IsIG5hbWUpID0+IHtcbiAgICBjb25zdCBmaWVsZEFycmF5RXJyb3JzID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGdldChlcnJvcnMsIG5hbWUpKTtcbiAgICBzZXQoZmllbGRBcnJheUVycm9ycywgJ3Jvb3QnLCBlcnJvcltuYW1lXSk7XG4gICAgc2V0KGVycm9ycywgbmFtZSwgZmllbGRBcnJheUVycm9ycyk7XG4gICAgcmV0dXJuIGVycm9ycztcbn07XG5cbmZ1bmN0aW9uIGdldFZhbGlkYXRlRXJyb3IocmVzdWx0LCByZWYsIHR5cGUgPSAndmFsaWRhdGUnKSB7XG4gICAgaWYgKGlzU3RyaW5nKHJlc3VsdCkgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQuZXZlcnkoaXNTdHJpbmcpKSB8fFxuICAgICAgICAoaXNCb29sZWFuKHJlc3VsdCkgJiYgIXJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBpc1N0cmluZyhyZXN1bHQpID8gcmVzdWx0IDogJycsXG4gICAgICAgICAgICByZWYsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG52YXIgZ2V0VmFsdWVBbmRNZXNzYWdlID0gKHZhbGlkYXRpb25EYXRhKSA9PiBpc09iamVjdCh2YWxpZGF0aW9uRGF0YSkgJiYgIWlzUmVnZXgodmFsaWRhdGlvbkRhdGEpXG4gICAgPyB2YWxpZGF0aW9uRGF0YVxuICAgIDoge1xuICAgICAgICB2YWx1ZTogdmFsaWRhdGlvbkRhdGEsXG4gICAgICAgIG1lc3NhZ2U6ICcnLFxuICAgIH07XG5cbnZhciB2YWxpZGF0ZUZpZWxkID0gYXN5bmMgKGZpZWxkLCBkaXNhYmxlZEZpZWxkTmFtZXMsIGZvcm1WYWx1ZXMsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiwgaXNGaWVsZEFycmF5KSA9PiB7XG4gICAgY29uc3QgeyByZWYsIHJlZnMsIHJlcXVpcmVkLCBtYXhMZW5ndGgsIG1pbkxlbmd0aCwgbWluLCBtYXgsIHBhdHRlcm4sIHZhbGlkYXRlLCBuYW1lLCB2YWx1ZUFzTnVtYmVyLCBtb3VudCwgfSA9IGZpZWxkLl9mO1xuICAgIGNvbnN0IGlucHV0VmFsdWUgPSBnZXQoZm9ybVZhbHVlcywgbmFtZSk7XG4gICAgaWYgKCFtb3VudCB8fCBkaXNhYmxlZEZpZWxkTmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRSZWYgPSByZWZzID8gcmVmc1swXSA6IHJlZjtcbiAgICBjb25zdCBzZXRDdXN0b21WYWxpZGl0eSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uICYmIGlucHV0UmVmLnJlcG9ydFZhbGlkaXR5KSB7XG4gICAgICAgICAgICBpbnB1dFJlZi5zZXRDdXN0b21WYWxpZGl0eShpc0Jvb2xlYW4obWVzc2FnZSkgPyAnJyA6IG1lc3NhZ2UgfHwgJycpO1xuICAgICAgICAgICAgaW5wdXRSZWYucmVwb3J0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZXJyb3IgPSB7fTtcbiAgICBjb25zdCBpc1JhZGlvID0gaXNSYWRpb0lucHV0KHJlZik7XG4gICAgY29uc3QgaXNDaGVja0JveCA9IGlzQ2hlY2tCb3hJbnB1dChyZWYpO1xuICAgIGNvbnN0IGlzUmFkaW9PckNoZWNrYm94ID0gaXNSYWRpbyB8fCBpc0NoZWNrQm94O1xuICAgIGNvbnN0IGlzRW1wdHkgPSAoKHZhbHVlQXNOdW1iZXIgfHwgaXNGaWxlSW5wdXQocmVmKSkgJiZcbiAgICAgICAgaXNVbmRlZmluZWQocmVmLnZhbHVlKSAmJlxuICAgICAgICBpc1VuZGVmaW5lZChpbnB1dFZhbHVlKSkgfHxcbiAgICAgICAgKGlzSFRNTEVsZW1lbnQocmVmKSAmJiByZWYudmFsdWUgPT09ICcnKSB8fFxuICAgICAgICBpbnB1dFZhbHVlID09PSAnJyB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlKSAmJiAhaW5wdXRWYWx1ZS5sZW5ndGgpO1xuICAgIGNvbnN0IGFwcGVuZEVycm9yc0N1cnJ5ID0gYXBwZW5kRXJyb3JzLmJpbmQobnVsbCwgbmFtZSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBlcnJvcik7XG4gICAgY29uc3QgZ2V0TWluTWF4TWVzc2FnZSA9IChleGNlZWRNYXgsIG1heExlbmd0aE1lc3NhZ2UsIG1pbkxlbmd0aE1lc3NhZ2UsIG1heFR5cGUgPSBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heExlbmd0aCwgbWluVHlwZSA9IElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWluTGVuZ3RoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBleGNlZWRNYXggPyBtYXhMZW5ndGhNZXNzYWdlIDogbWluTGVuZ3RoTWVzc2FnZTtcbiAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICB0eXBlOiBleGNlZWRNYXggPyBtYXhUeXBlIDogbWluVHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShleGNlZWRNYXggPyBtYXhUeXBlIDogbWluVHlwZSwgbWVzc2FnZSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBpZiAoaXNGaWVsZEFycmF5XG4gICAgICAgID8gIUFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkgfHwgIWlucHV0VmFsdWUubGVuZ3RoXG4gICAgICAgIDogcmVxdWlyZWQgJiZcbiAgICAgICAgICAgICgoIWlzUmFkaW9PckNoZWNrYm94ICYmIChpc0VtcHR5IHx8IGlzTnVsbE9yVW5kZWZpbmVkKGlucHV0VmFsdWUpKSkgfHxcbiAgICAgICAgICAgICAgICAoaXNCb29sZWFuKGlucHV0VmFsdWUpICYmICFpbnB1dFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChpc0NoZWNrQm94ICYmICFnZXRDaGVja2JveFZhbHVlKHJlZnMpLmlzVmFsaWQpIHx8XG4gICAgICAgICAgICAgICAgKGlzUmFkaW8gJiYgIWdldFJhZGlvVmFsdWUocmVmcykuaXNWYWxpZCkpKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIG1lc3NhZ2UgfSA9IGlzU3RyaW5nKHJlcXVpcmVkKVxuICAgICAgICAgICAgPyB7IHZhbHVlOiAhIXJlcXVpcmVkLCBtZXNzYWdlOiByZXF1aXJlZCB9XG4gICAgICAgICAgICA6IGdldFZhbHVlQW5kTWVzc2FnZShyZXF1aXJlZCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogSU5QVVRfVkFMSURBVElPTl9SVUxFUy5yZXF1aXJlZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJlZjogaW5wdXRSZWYsXG4gICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5yZXF1aXJlZCwgbWVzc2FnZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0VtcHR5ICYmICghaXNOdWxsT3JVbmRlZmluZWQobWluKSB8fCAhaXNOdWxsT3JVbmRlZmluZWQobWF4KSkpIHtcbiAgICAgICAgbGV0IGV4Y2VlZE1heDtcbiAgICAgICAgbGV0IGV4Y2VlZE1pbjtcbiAgICAgICAgY29uc3QgbWF4T3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1heCk7XG4gICAgICAgIGNvbnN0IG1pbk91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW4pO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGlucHV0VmFsdWUpICYmICFpc05hTihpbnB1dFZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVOdW1iZXIgPSByZWYudmFsdWVBc051bWJlciB8fFxuICAgICAgICAgICAgICAgIChpbnB1dFZhbHVlID8gK2lucHV0VmFsdWUgOiBpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobWF4T3V0cHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IHZhbHVlTnVtYmVyID4gbWF4T3V0cHV0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChtaW5PdXRwdXQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWluID0gdmFsdWVOdW1iZXIgPCBtaW5PdXRwdXQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZURhdGUgPSByZWYudmFsdWVBc0RhdGUgfHwgbmV3IERhdGUoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0VGltZVRvRGF0ZSA9ICh0aW1lKSA9PiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnRvRGF0ZVN0cmluZygpICsgJyAnICsgdGltZSk7XG4gICAgICAgICAgICBjb25zdCBpc1RpbWUgPSByZWYudHlwZSA9PSAndGltZSc7XG4gICAgICAgICAgICBjb25zdCBpc1dlZWsgPSByZWYudHlwZSA9PSAnd2Vlayc7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobWF4T3V0cHV0LnZhbHVlKSAmJiBpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWF4ID0gaXNUaW1lXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFRpbWVUb0RhdGUoaW5wdXRWYWx1ZSkgPiBjb252ZXJ0VGltZVRvRGF0ZShtYXhPdXRwdXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogaXNXZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGlucHV0VmFsdWUgPiBtYXhPdXRwdXQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVEYXRlID4gbmV3IERhdGUobWF4T3V0cHV0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhtaW5PdXRwdXQudmFsdWUpICYmIGlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBleGNlZWRNaW4gPSBpc1RpbWVcbiAgICAgICAgICAgICAgICAgICAgPyBjb252ZXJ0VGltZVRvRGF0ZShpbnB1dFZhbHVlKSA8IGNvbnZlcnRUaW1lVG9EYXRlKG1pbk91dHB1dC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiBpc1dlZWtcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaW5wdXRWYWx1ZSA8IG1pbk91dHB1dC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZURhdGUgPCBuZXcgRGF0ZShtaW5PdXRwdXQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleGNlZWRNYXggfHwgZXhjZWVkTWluKSB7XG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKCEhZXhjZWVkTWF4LCBtYXhPdXRwdXQubWVzc2FnZSwgbWluT3V0cHV0Lm1lc3NhZ2UsIElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWF4LCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1pbik7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KGVycm9yW25hbWVdLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoKG1heExlbmd0aCB8fCBtaW5MZW5ndGgpICYmXG4gICAgICAgICFpc0VtcHR5ICYmXG4gICAgICAgIChpc1N0cmluZyhpbnB1dFZhbHVlKSB8fCAoaXNGaWVsZEFycmF5ICYmIEFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkpKSkge1xuICAgICAgICBjb25zdCBtYXhMZW5ndGhPdXRwdXQgPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWF4TGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbWluTGVuZ3RoT3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1pbkxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGV4Y2VlZE1heCA9ICFpc051bGxPclVuZGVmaW5lZChtYXhMZW5ndGhPdXRwdXQudmFsdWUpICYmXG4gICAgICAgICAgICBpbnB1dFZhbHVlLmxlbmd0aCA+ICttYXhMZW5ndGhPdXRwdXQudmFsdWU7XG4gICAgICAgIGNvbnN0IGV4Y2VlZE1pbiA9ICFpc051bGxPclVuZGVmaW5lZChtaW5MZW5ndGhPdXRwdXQudmFsdWUpICYmXG4gICAgICAgICAgICBpbnB1dFZhbHVlLmxlbmd0aCA8ICttaW5MZW5ndGhPdXRwdXQudmFsdWU7XG4gICAgICAgIGlmIChleGNlZWRNYXggfHwgZXhjZWVkTWluKSB7XG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKGV4Y2VlZE1heCwgbWF4TGVuZ3RoT3V0cHV0Lm1lc3NhZ2UsIG1pbkxlbmd0aE91dHB1dC5tZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkoZXJyb3JbbmFtZV0ubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuICYmICFpc0VtcHR5ICYmIGlzU3RyaW5nKGlucHV0VmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IHBhdHRlcm5WYWx1ZSwgbWVzc2FnZSB9ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKHBhdHRlcm4pO1xuICAgICAgICBpZiAoaXNSZWdleChwYXR0ZXJuVmFsdWUpICYmICFpbnB1dFZhbHVlLm1hdGNoKHBhdHRlcm5WYWx1ZSkpIHtcbiAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IElOUFVUX1ZBTElEQVRJT05fUlVMRVMucGF0dGVybixcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sIG1lc3NhZ2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2YWxpZGF0ZSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlKGlucHV0VmFsdWUsIGZvcm1WYWx1ZXMpO1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IGdldFZhbGlkYXRlRXJyb3IocmVzdWx0LCBpbnB1dFJlZik7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVFcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi52YWxpZGF0ZUVycm9yLFxuICAgICAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnZhbGlkYXRlLCB2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkodmFsaWRhdGVFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgIGxldCB2YWxpZGF0aW9uUmVzdWx0ID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eU9iamVjdCh2YWxpZGF0aW9uUmVzdWx0KSAmJiAhdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gZ2V0VmFsaWRhdGVFcnJvcihhd2FpdCB2YWxpZGF0ZVtrZXldKGlucHV0VmFsdWUsIGZvcm1WYWx1ZXMpLCBpbnB1dFJlZiwga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsaWRhdGVFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KGtleSwgdmFsaWRhdGVFcnJvci5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkodmFsaWRhdGVFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB2YWxpZGF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0VtcHR5T2JqZWN0KHZhbGlkYXRpb25SZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogaW5wdXRSZWYsXG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbGlkYXRpb25SZXN1bHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEN1c3RvbVZhbGlkaXR5KHRydWUpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCxcbiAgICByZVZhbGlkYXRlTW9kZTogVkFMSURBVElPTl9NT0RFLm9uQ2hhbmdlLFxuICAgIHNob3VsZEZvY3VzRXJyb3I6IHRydWUsXG59O1xuZnVuY3Rpb24gY3JlYXRlRm9ybUNvbnRyb2wocHJvcHMgPSB7fSkge1xuICAgIGxldCBfb3B0aW9ucyA9IHtcbiAgICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIC4uLnByb3BzLFxuICAgIH07XG4gICAgbGV0IF9mb3JtU3RhdGUgPSB7XG4gICAgICAgIHN1Ym1pdENvdW50OiAwLFxuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgaXNSZWFkeTogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogaXNGdW5jdGlvbihfb3B0aW9ucy5kZWZhdWx0VmFsdWVzKSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczoge30sXG4gICAgICAgIGRpcnR5RmllbGRzOiB7fSxcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczoge30sXG4gICAgICAgIGVycm9yczogX29wdGlvbnMuZXJyb3JzIHx8IHt9LFxuICAgICAgICBkaXNhYmxlZDogX29wdGlvbnMuZGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgfTtcbiAgICBsZXQgX2ZpZWxkcyA9IHt9O1xuICAgIGxldCBfZGVmYXVsdFZhbHVlcyA9IGlzT2JqZWN0KF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMpIHx8IGlzT2JqZWN0KF9vcHRpb25zLnZhbHVlcylcbiAgICAgICAgPyBjbG9uZU9iamVjdChfb3B0aW9ucy5kZWZhdWx0VmFsdWVzIHx8IF9vcHRpb25zLnZhbHVlcykgfHwge31cbiAgICAgICAgOiB7fTtcbiAgICBsZXQgX2Zvcm1WYWx1ZXMgPSBfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyXG4gICAgICAgID8ge31cbiAgICAgICAgOiBjbG9uZU9iamVjdChfZGVmYXVsdFZhbHVlcyk7XG4gICAgbGV0IF9zdGF0ZSA9IHtcbiAgICAgICAgYWN0aW9uOiBmYWxzZSxcbiAgICAgICAgbW91bnQ6IGZhbHNlLFxuICAgICAgICB3YXRjaDogZmFsc2UsXG4gICAgfTtcbiAgICBsZXQgX25hbWVzID0ge1xuICAgICAgICBtb3VudDogbmV3IFNldCgpLFxuICAgICAgICBkaXNhYmxlZDogbmV3IFNldCgpLFxuICAgICAgICB1bk1vdW50OiBuZXcgU2V0KCksXG4gICAgICAgIGFycmF5OiBuZXcgU2V0KCksXG4gICAgICAgIHdhdGNoOiBuZXcgU2V0KCksXG4gICAgfTtcbiAgICBsZXQgZGVsYXlFcnJvckNhbGxiYWNrO1xuICAgIGxldCB0aW1lciA9IDA7XG4gICAgY29uc3QgX3Byb3h5Rm9ybVN0YXRlID0ge1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxuICAgICAgICB2YWxpZGF0aW5nRmllbGRzOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcnM6IGZhbHNlLFxuICAgIH07XG4gICAgbGV0IF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZSA9IHtcbiAgICAgICAgLi4uX3Byb3h5Rm9ybVN0YXRlLFxuICAgIH07XG4gICAgY29uc3QgX3N1YmplY3RzID0ge1xuICAgICAgICBhcnJheTogY3JlYXRlU3ViamVjdCgpLFxuICAgICAgICBzdGF0ZTogY3JlYXRlU3ViamVjdCgpLFxuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkRGlzcGxheUFsbEFzc29jaWF0ZWRFcnJvcnMgPSBfb3B0aW9ucy5jcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGw7XG4gICAgY29uc3QgZGVib3VuY2UgPSAoY2FsbGJhY2spID0+ICh3YWl0KSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChjYWxsYmFjaywgd2FpdCk7XG4gICAgfTtcbiAgICBjb25zdCBfc2V0VmFsaWQgPSBhc3luYyAoc2hvdWxkVXBkYXRlVmFsaWQpID0+IHtcbiAgICAgICAgaWYgKCFfb3B0aW9ucy5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmlzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVWYWxpZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSBfb3B0aW9ucy5yZXNvbHZlclxuICAgICAgICAgICAgICAgID8gaXNFbXB0eU9iamVjdCgoYXdhaXQgX3J1blNjaGVtYSgpKS5lcnJvcnMpXG4gICAgICAgICAgICAgICAgOiBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZCAhPT0gX2Zvcm1TdGF0ZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfdXBkYXRlSXNWYWxpZGF0aW5nID0gKG5hbWVzLCBpc1ZhbGlkYXRpbmcpID0+IHtcbiAgICAgICAgaWYgKCFfb3B0aW9ucy5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkYXRpbmcgfHxcbiAgICAgICAgICAgICAgICBfcHJveHlGb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcyB8fFxuICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5pc1ZhbGlkYXRpbmcgfHxcbiAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcykpIHtcbiAgICAgICAgICAgIChuYW1lcyB8fCBBcnJheS5mcm9tKF9uYW1lcy5tb3VudCkpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2V0KF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcywgbmFtZSwgaXNWYWxpZGF0aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpbmdGaWVsZHM6IF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcyxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6ICFpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX3NldEZpZWxkQXJyYXkgPSAobmFtZSwgdmFsdWVzID0gW10sIG1ldGhvZCwgYXJncywgc2hvdWxkU2V0VmFsdWVzID0gdHJ1ZSwgc2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUgPSB0cnVlKSA9PiB7XG4gICAgICAgIGlmIChhcmdzICYmIG1ldGhvZCAmJiAhX29wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIF9zdGF0ZS5hY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmIEFycmF5LmlzQXJyYXkoZ2V0KF9maWVsZHMsIG5hbWUpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gbWV0aG9kKGdldChfZmllbGRzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xuICAgICAgICAgICAgICAgIHNob3VsZFNldFZhbHVlcyAmJiBzZXQoX2ZpZWxkcywgbmFtZSwgZmllbGRWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IG1ldGhvZChnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0VmFsdWVzICYmIHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB1bnNldEVtcHR5QXJyYXkoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChfcHJveHlGb3JtU3RhdGUudG91Y2hlZEZpZWxkcyB8fFxuICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS50b3VjaGVkRmllbGRzKSAmJlxuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3VjaGVkRmllbGRzID0gbWV0aG9kKGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0VmFsdWVzICYmIHNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUsIHRvdWNoZWRGaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcyB8fCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuZGlydHlGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBfZm9ybVN0YXRlLmRpcnR5RmllbGRzID0gZ2V0RGlydHlGaWVsZHMoX2RlZmF1bHRWYWx1ZXMsIF9mb3JtVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGlzRGlydHk6IF9nZXREaXJ0eShuYW1lLCB2YWx1ZXMpLFxuICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzOiBfZm9ybVN0YXRlLmRpcnR5RmllbGRzLFxuICAgICAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgaXNWYWxpZDogX2Zvcm1TdGF0ZS5pc1ZhbGlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUVycm9ycyA9IChuYW1lLCBlcnJvcikgPT4ge1xuICAgICAgICBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBfc2V0RXJyb3JzID0gKGVycm9ycykgPT4ge1xuICAgICAgICBfZm9ybVN0YXRlLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZVZhbGlkQW5kVmFsdWUgPSAobmFtZSwgc2hvdWxkU2tpcFNldFZhbHVlQXMsIHZhbHVlLCByZWYpID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZ2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBpc1VuZGVmaW5lZCh2YWx1ZSkgPyBnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpIDogdmFsdWUpO1xuICAgICAgICAgICAgaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChyZWYgJiYgcmVmLmRlZmF1bHRDaGVja2VkKSB8fFxuICAgICAgICAgICAgICAgIHNob3VsZFNraXBTZXRWYWx1ZUFzXG4gICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIHNob3VsZFNraXBTZXRWYWx1ZUFzID8gZGVmYXVsdFZhbHVlIDogZ2V0RmllbGRWYWx1ZShmaWVsZC5fZikpXG4gICAgICAgICAgICAgICAgOiBzZXRGaWVsZFZhbHVlKG5hbWUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICBfc3RhdGUubW91bnQgJiYgX3NldFZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZVRvdWNoQW5kRGlydHkgPSAobmFtZSwgZmllbGRWYWx1ZSwgaXNCbHVyRXZlbnQsIHNob3VsZERpcnR5LCBzaG91bGRSZW5kZXIpID0+IHtcbiAgICAgICAgbGV0IHNob3VsZFVwZGF0ZUZpZWxkID0gZmFsc2U7XG4gICAgICAgIGxldCBpc1ByZXZpb3VzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFfb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgaWYgKCFpc0JsdXJFdmVudCB8fCBzaG91bGREaXJ0eSkge1xuICAgICAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUuaXNEaXJ0eSB8fCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgPSBfZm9ybVN0YXRlLmlzRGlydHk7XG4gICAgICAgICAgICAgICAgICAgIF9mb3JtU3RhdGUuaXNEaXJ0eSA9IG91dHB1dC5pc0RpcnR5ID0gX2dldERpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkID0gaXNQcmV2aW91c0RpcnR5ICE9PSBvdXRwdXQuaXNEaXJ0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50RmllbGRQcmlzdGluZSA9IGRlZXBFcXVhbChnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpLCBmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgPSAhIWdldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpc0N1cnJlbnRGaWVsZFByaXN0aW5lXG4gICAgICAgICAgICAgICAgICAgID8gdW5zZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgOiBzZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmRpcnR5RmllbGRzID0gX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcztcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCA9XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoKF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgIT09ICFpc0N1cnJlbnRGaWVsZFByaXN0aW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUHJldmlvdXNGaWVsZFRvdWNoZWQgPSBnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUHJldmlvdXNGaWVsZFRvdWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSwgaXNCbHVyRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQudG91Y2hlZEZpZWxkcyA9IF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcztcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9wcm94eUZvcm1TdGF0ZS50b3VjaGVkRmllbGRzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS50b3VjaGVkRmllbGRzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRmllbGRUb3VjaGVkICE9PSBpc0JsdXJFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgJiYgc2hvdWxkUmVuZGVyICYmIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNob3VsZFVwZGF0ZUZpZWxkID8gb3V0cHV0IDoge307XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRSZW5kZXJCeUVycm9yID0gKG5hbWUsIGlzVmFsaWQsIGVycm9yLCBmaWVsZFN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRmllbGRFcnJvciA9IGdldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZVZhbGlkID0gKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8IF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5pc1ZhbGlkKSAmJlxuICAgICAgICAgICAgaXNCb29sZWFuKGlzVmFsaWQpICYmXG4gICAgICAgICAgICBfZm9ybVN0YXRlLmlzVmFsaWQgIT09IGlzVmFsaWQ7XG4gICAgICAgIGlmIChfb3B0aW9ucy5kZWxheUVycm9yICYmIGVycm9yKSB7XG4gICAgICAgICAgICBkZWxheUVycm9yQ2FsbGJhY2sgPSBkZWJvdW5jZSgoKSA9PiB1cGRhdGVFcnJvcnMobmFtZSwgZXJyb3IpKTtcbiAgICAgICAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayhfb3B0aW9ucy5kZWxheUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICBkZWxheUVycm9yQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICA/IHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpXG4gICAgICAgICAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChlcnJvciA/ICFkZWVwRXF1YWwocHJldmlvdXNGaWVsZEVycm9yLCBlcnJvcikgOiBwcmV2aW91c0ZpZWxkRXJyb3IpIHx8XG4gICAgICAgICAgICAhaXNFbXB0eU9iamVjdChmaWVsZFN0YXRlKSB8fFxuICAgICAgICAgICAgc2hvdWxkVXBkYXRlVmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGb3JtU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uZmllbGRTdGF0ZSxcbiAgICAgICAgICAgICAgICAuLi4oc2hvdWxkVXBkYXRlVmFsaWQgJiYgaXNCb29sZWFuKGlzVmFsaWQpID8geyBpc1ZhbGlkIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9mb3JtU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICAuLi51cGRhdGVkRm9ybVN0YXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHVwZGF0ZWRGb3JtU3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfcnVuU2NoZW1hID0gYXN5bmMgKG5hbWUpID0+IHtcbiAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhuYW1lLCB0cnVlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX29wdGlvbnMucmVzb2x2ZXIoX2Zvcm1WYWx1ZXMsIF9vcHRpb25zLmNvbnRleHQsIGdldFJlc29sdmVyT3B0aW9ucyhuYW1lIHx8IF9uYW1lcy5tb3VudCwgX2ZpZWxkcywgX29wdGlvbnMuY3JpdGVyaWFNb2RlLCBfb3B0aW9ucy5zaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uKSk7XG4gICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcobmFtZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBjb25zdCBleGVjdXRlU2NoZW1hQW5kVXBkYXRlU3RhdGUgPSBhc3luYyAobmFtZXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IF9ydW5TY2hlbWEobmFtZXMpO1xuICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgICAgICA6IHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9mb3JtU3RhdGUuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfTtcbiAgICBjb25zdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24gPSBhc3luYyAoZmllbGRzLCBzaG91bGRPbmx5Q2hlY2tWYWxpZCwgY29udGV4dCA9IHtcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgfSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgX2YsIC4uLmZpZWxkVmFsdWUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgIGlmIChfZikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0ZpZWxkQXJyYXlSb290ID0gX25hbWVzLmFycmF5LmhhcyhfZi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNQcm9taXNlRnVuY3Rpb24gPSBmaWVsZC5fZiAmJiBoYXNQcm9taXNlVmFsaWRhdGlvbihmaWVsZC5fZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2VGdW5jdGlvbiAmJiBfcHJveHlGb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhbX2YubmFtZV0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkRXJyb3IgPSBhd2FpdCB2YWxpZGF0ZUZpZWxkKGZpZWxkLCBfbmFtZXMuZGlzYWJsZWQsIF9mb3JtVmFsdWVzLCBzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycywgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiAmJiAhc2hvdWxkT25seUNoZWNrVmFsaWQsIGlzRmllbGRBcnJheVJvb3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlRnVuY3Rpb24gJiYgX3Byb3h5Rm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcoW19mLm5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRFcnJvcltfZi5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZE9ubHlDaGVja1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIXNob3VsZE9ubHlDaGVja1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZ2V0KGZpZWxkRXJyb3IsIF9mLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBpc0ZpZWxkQXJyYXlSb290XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvcihfZm9ybVN0YXRlLmVycm9ycywgZmllbGRFcnJvciwgX2YubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9mLm5hbWUsIGZpZWxkRXJyb3JbX2YubmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgX2YubmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAhaXNFbXB0eU9iamVjdChmaWVsZFZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKGZpZWxkVmFsdWUsIHNob3VsZE9ubHlDaGVja1ZhbGlkLCBjb250ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQudmFsaWQ7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlVW5tb3VudGVkID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgX25hbWVzLnVuTW91bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgZmllbGQgJiZcbiAgICAgICAgICAgICAgICAoZmllbGQuX2YucmVmc1xuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkLl9mLnJlZnMuZXZlcnkoKHJlZikgPT4gIWxpdmUocmVmKSlcbiAgICAgICAgICAgICAgICAgICAgOiAhbGl2ZShmaWVsZC5fZi5yZWYpKSAmJlxuICAgICAgICAgICAgICAgIHVucmVnaXN0ZXIobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgX25hbWVzLnVuTW91bnQgPSBuZXcgU2V0KCk7XG4gICAgfTtcbiAgICBjb25zdCBfZ2V0RGlydHkgPSAobmFtZSwgZGF0YSkgPT4gIV9vcHRpb25zLmRpc2FibGVkICYmXG4gICAgICAgIChuYW1lICYmIGRhdGEgJiYgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBkYXRhKSxcbiAgICAgICAgICAgICFkZWVwRXF1YWwoZ2V0VmFsdWVzKCksIF9kZWZhdWx0VmFsdWVzKSk7XG4gICAgY29uc3QgX2dldFdhdGNoID0gKG5hbWVzLCBkZWZhdWx0VmFsdWUsIGlzR2xvYmFsKSA9PiBnZW5lcmF0ZVdhdGNoT3V0cHV0KG5hbWVzLCBfbmFtZXMsIHtcbiAgICAgICAgLi4uKF9zdGF0ZS5tb3VudFxuICAgICAgICAgICAgPyBfZm9ybVZhbHVlc1xuICAgICAgICAgICAgOiBpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICAgICAgPyBfZGVmYXVsdFZhbHVlc1xuICAgICAgICAgICAgICAgIDogaXNTdHJpbmcobmFtZXMpXG4gICAgICAgICAgICAgICAgICAgID8geyBbbmFtZXNdOiBkZWZhdWx0VmFsdWUgfVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZSksXG4gICAgfSwgaXNHbG9iYWwsIGRlZmF1bHRWYWx1ZSk7XG4gICAgY29uc3QgX2dldEZpZWxkQXJyYXkgPSAobmFtZSkgPT4gY29tcGFjdChnZXQoX3N0YXRlLm1vdW50ID8gX2Zvcm1WYWx1ZXMgOiBfZGVmYXVsdFZhbHVlcywgbmFtZSwgX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciA/IGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSwgW10pIDogW10pKTtcbiAgICBjb25zdCBzZXRGaWVsZFZhbHVlID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGxldCBmaWVsZFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBmaWVsZC5fZjtcbiAgICAgICAgICAgIGlmIChmaWVsZFJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICFmaWVsZFJlZmVyZW5jZS5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGdldEZpZWxkVmFsdWVBcyh2YWx1ZSwgZmllbGRSZWZlcmVuY2UpKTtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgaXNIVE1MRWxlbWVudChmaWVsZFJlZmVyZW5jZS5yZWYpICYmIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNdWx0aXBsZVNlbGVjdChmaWVsZFJlZmVyZW5jZS5yZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIFsuLi5maWVsZFJlZmVyZW5jZS5yZWYub3B0aW9uc10uZm9yRWFjaCgob3B0aW9uUmVmKSA9PiAob3B0aW9uUmVmLnNlbGVjdGVkID0gZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25SZWYudmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkUmVmZXJlbmNlLnJlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hlY2tCb3hJbnB1dChmaWVsZFJlZmVyZW5jZS5yZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWZzLmZvckVhY2goKGNoZWNrYm94UmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja2JveFJlZi5kZWZhdWx0Q2hlY2tlZCB8fCAhY2hlY2tib3hSZWYuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94UmVmLmNoZWNrZWQgPSAhIWZpZWxkVmFsdWUuZmluZCgoZGF0YSkgPT4gZGF0YSA9PT0gY2hlY2tib3hSZWYudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3hSZWYuY2hlY2tlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9PT0gY2hlY2tib3hSZWYudmFsdWUgfHwgISFmaWVsZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWZzLmZvckVhY2goKHJhZGlvUmVmKSA9PiAocmFkaW9SZWYuY2hlY2tlZCA9IHJhZGlvUmVmLnZhbHVlID09PSBmaWVsZFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGaWxlSW5wdXQoZmllbGRSZWZlcmVuY2UucmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWYudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmZXJlbmNlLnJlZi52YWx1ZSA9IGZpZWxkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmllbGRSZWZlcmVuY2UucmVmLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogY2xvbmVPYmplY3QoX2Zvcm1WYWx1ZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKG9wdGlvbnMuc2hvdWxkRGlydHkgfHwgb3B0aW9ucy5zaG91bGRUb3VjaCkgJiZcbiAgICAgICAgICAgIHVwZGF0ZVRvdWNoQW5kRGlydHkobmFtZSwgZmllbGRWYWx1ZSwgb3B0aW9ucy5zaG91bGRUb3VjaCwgb3B0aW9ucy5zaG91bGREaXJ0eSwgdHJ1ZSk7XG4gICAgICAgIG9wdGlvbnMuc2hvdWxkVmFsaWRhdGUgJiYgdHJpZ2dlcihuYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldFZhbHVlcyA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkS2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlLmhhc093blByb3BlcnR5KGZpZWxkS2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWUgPSB2YWx1ZVtmaWVsZEtleV07XG4gICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBuYW1lICsgJy4nICsgZmllbGRLZXk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgKF9uYW1lcy5hcnJheS5oYXMobmFtZSkgfHxcbiAgICAgICAgICAgICAgICBpc09iamVjdChmaWVsZFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChmaWVsZCAmJiAhZmllbGQuX2YpKSAmJlxuICAgICAgICAgICAgICAgICFpc0RhdGVPYmplY3QoZmllbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IHNldFZhbHVlcyhmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgOiBzZXRGaWVsZFZhbHVlKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldFZhbHVlID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IGlzRmllbGRBcnJheSA9IF9uYW1lcy5hcnJheS5oYXMobmFtZSk7XG4gICAgICAgIGNvbnN0IGNsb25lVmFsdWUgPSBjbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgIHNldChfZm9ybVZhbHVlcywgbmFtZSwgY2xvbmVWYWx1ZSk7XG4gICAgICAgIGlmIChpc0ZpZWxkQXJyYXkpIHtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5hcnJheS5uZXh0KHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlczogY2xvbmVPYmplY3QoX2Zvcm1WYWx1ZXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoKF9wcm94eUZvcm1TdGF0ZS5pc0RpcnR5IHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5Rm9ybVN0YXRlLmRpcnR5RmllbGRzIHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmlzRGlydHkgfHxcbiAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuZGlydHlGaWVsZHMpICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGREaXJ0eSkge1xuICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlydHlGaWVsZHM6IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcyksXG4gICAgICAgICAgICAgICAgICAgIGlzRGlydHk6IF9nZXREaXJ0eShuYW1lLCBjbG9uZVZhbHVlKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkICYmICFmaWVsZC5fZiAmJiAhaXNOdWxsT3JVbmRlZmluZWQoY2xvbmVWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IHNldFZhbHVlcyhuYW1lLCBjbG9uZVZhbHVlLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogc2V0RmllbGRWYWx1ZShuYW1lLCBjbG9uZVZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpc1dhdGNoZWQobmFtZSwgX25hbWVzKSAmJiBfc3ViamVjdHMuc3RhdGUubmV4dCh7IC4uLl9mb3JtU3RhdGUsIG5hbWUgfSk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIG5hbWU6IF9zdGF0ZS5tb3VudCA/IG5hbWUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBfc3RhdGUubW91bnQgPSB0cnVlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGxldCBuYW1lID0gdGFyZ2V0Lm5hbWU7XG4gICAgICAgIGxldCBpc0ZpZWxkVmFsdWVVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IF91cGRhdGVJc0ZpZWxkVmFsdWVVcGRhdGVkID0gKGZpZWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlzRmllbGRWYWx1ZVVwZGF0ZWQgPVxuICAgICAgICAgICAgICAgIE51bWJlci5pc05hTihmaWVsZFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNEYXRlT2JqZWN0KGZpZWxkVmFsdWUpICYmIGlzTmFOKGZpZWxkVmFsdWUuZ2V0VGltZSgpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgZGVlcEVxdWFsKGZpZWxkVmFsdWUsIGdldChfZm9ybVZhbHVlcywgbmFtZSwgZmllbGRWYWx1ZSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCA9IGdldFZhbGlkYXRpb25Nb2Rlcyhfb3B0aW9ucy5tb2RlKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCA9IGdldFZhbGlkYXRpb25Nb2Rlcyhfb3B0aW9ucy5yZVZhbGlkYXRlTW9kZSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gdGFyZ2V0LnR5cGVcbiAgICAgICAgICAgICAgICA/IGdldEZpZWxkVmFsdWUoZmllbGQuX2YpXG4gICAgICAgICAgICAgICAgOiBnZXRFdmVudFZhbHVlKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGlzQmx1ckV2ZW50ID0gZXZlbnQudHlwZSA9PT0gRVZFTlRTLkJMVVIgfHwgZXZlbnQudHlwZSA9PT0gRVZFTlRTLkZPQ1VTX09VVDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNraXBWYWxpZGF0aW9uID0gKCFoYXNWYWxpZGF0aW9uKGZpZWxkLl9mKSAmJlxuICAgICAgICAgICAgICAgICFfb3B0aW9ucy5yZXNvbHZlciAmJlxuICAgICAgICAgICAgICAgICFnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICAgIWZpZWxkLl9mLmRlcHMpIHx8XG4gICAgICAgICAgICAgICAgc2tpcFZhbGlkYXRpb24oaXNCbHVyRXZlbnQsIGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLCBfZm9ybVN0YXRlLmlzU3VibWl0dGVkLCB2YWxpZGF0aW9uTW9kZUFmdGVyU3VibWl0LCB2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCk7XG4gICAgICAgICAgICBjb25zdCB3YXRjaGVkID0gaXNXYXRjaGVkKG5hbWUsIF9uYW1lcywgaXNCbHVyRXZlbnQpO1xuICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuX2Yub25CbHVyICYmIGZpZWxkLl9mLm9uQmx1cihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayAmJiBkZWxheUVycm9yQ2FsbGJhY2soMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQuX2Yub25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5vbkNoYW5nZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWVsZFN0YXRlID0gdXBkYXRlVG91Y2hBbmREaXJ0eShuYW1lLCBmaWVsZFZhbHVlLCBpc0JsdXJFdmVudCk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZW5kZXIgPSAhaXNFbXB0eU9iamVjdChmaWVsZFN0YXRlKSB8fCB3YXRjaGVkO1xuICAgICAgICAgICAgIWlzQmx1ckV2ZW50ICYmXG4gICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBldmVudC50eXBlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX29wdGlvbnMubW9kZSA9PT0gJ29uQmx1cicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zZXRWYWxpZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3NldFZhbGlkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzaG91bGRSZW5kZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyBuYW1lLCAuLi4od2F0Y2hlZCA/IHt9IDogZmllbGRTdGF0ZSkgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIWlzQmx1ckV2ZW50ICYmIHdhdGNoZWQgJiYgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlIH0pO1xuICAgICAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IF9ydW5TY2hlbWEoW25hbWVdKTtcbiAgICAgICAgICAgICAgICBfdXBkYXRlSXNGaWVsZFZhbHVlVXBkYXRlZChmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaWVsZFZhbHVlVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0Vycm9yTG9va3VwUmVzdWx0ID0gc2NoZW1hRXJyb3JMb29rdXAoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvckxvb2t1cFJlc3VsdCA9IHNjaGVtYUVycm9yTG9va3VwKGVycm9ycywgX2ZpZWxkcywgcHJldmlvdXNFcnJvckxvb2t1cFJlc3VsdC5uYW1lIHx8IG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycm9yTG9va3VwUmVzdWx0LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gZXJyb3JMb29rdXBSZXN1bHQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGlzRW1wdHlPYmplY3QoZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKFtuYW1lXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAoYXdhaXQgdmFsaWRhdGVGaWVsZChmaWVsZCwgX25hbWVzLmRpc2FibGVkLCBfZm9ybVZhbHVlcywgc2hvdWxkRGlzcGxheUFsbEFzc29jaWF0ZWRFcnJvcnMsIF9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24pKVtuYW1lXTtcbiAgICAgICAgICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5kZXBzICYmXG4gICAgICAgICAgICAgICAgICAgICghQXJyYXkuaXNBcnJheShmaWVsZC5fZi5kZXBzKSB8fCBmaWVsZC5fZi5kZXBzLmxlbmd0aCA+IDApICYmXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoZmllbGQuX2YuZGVwcyk7XG4gICAgICAgICAgICAgICAgc2hvdWxkUmVuZGVyQnlFcnJvcihuYW1lLCBpc1ZhbGlkLCBlcnJvciwgZmllbGRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF9mb2N1c0lucHV0ID0gKHJlZiwga2V5KSA9PiB7XG4gICAgICAgIGlmIChnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIGtleSkgJiYgcmVmLmZvY3VzKSB7XG4gICAgICAgICAgICByZWYuZm9jdXMoKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIGNvbnN0IHRyaWdnZXIgPSBhc3luYyAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGxldCBpc1ZhbGlkO1xuICAgICAgICBsZXQgdmFsaWRhdGlvblJlc3VsdDtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lKTtcbiAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBhd2FpdCBleGVjdXRlU2NoZW1hQW5kVXBkYXRlU3RhdGUoaXNVbmRlZmluZWQobmFtZSkgPyBuYW1lIDogZmllbGROYW1lcyk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gaXNFbXB0eU9iamVjdChlcnJvcnMpO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IG5hbWVcbiAgICAgICAgICAgICAgICA/ICFmaWVsZE5hbWVzLnNvbWUoKG5hbWUpID0+IGdldChlcnJvcnMsIG5hbWUpKVxuICAgICAgICAgICAgICAgIDogaXNWYWxpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gKGF3YWl0IFByb21pc2UuYWxsKGZpZWxkTmFtZXMubWFwKGFzeW5jIChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oZmllbGQgJiYgZmllbGQuX2YgPyB7IFtmaWVsZE5hbWVdOiBmaWVsZCB9IDogZmllbGQpO1xuICAgICAgICAgICAgfSkpKS5ldmVyeShCb29sZWFuKTtcbiAgICAgICAgICAgICEoIXZhbGlkYXRpb25SZXN1bHQgJiYgIV9mb3JtU3RhdGUuaXNWYWxpZCkgJiYgX3NldFZhbGlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gaXNWYWxpZCA9IGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihfZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAuLi4oIWlzU3RyaW5nKG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgKChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNWYWxpZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCAhPT0gX2Zvcm1TdGF0ZS5pc1ZhbGlkKVxuICAgICAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgICAgICA6IHsgbmFtZSB9KSxcbiAgICAgICAgICAgIC4uLihfb3B0aW9ucy5yZXNvbHZlciB8fCAhbmFtZSA/IHsgaXNWYWxpZCB9IDoge30pLFxuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMuc2hvdWxkRm9jdXMgJiZcbiAgICAgICAgICAgICF2YWxpZGF0aW9uUmVzdWx0ICYmXG4gICAgICAgICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oX2ZpZWxkcywgX2ZvY3VzSW5wdXQsIG5hbWUgPyBmaWVsZE5hbWVzIDogX25hbWVzLm1vdW50KTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25SZXN1bHQ7XG4gICAgfTtcbiAgICBjb25zdCBnZXRWYWx1ZXMgPSAoZmllbGROYW1lcywgY29uZmlnKSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSB7XG4gICAgICAgICAgICAuLi4oX3N0YXRlLm1vdW50ID8gX2Zvcm1WYWx1ZXMgOiBfZGVmYXVsdFZhbHVlcyksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IGV4dHJhY3RGb3JtVmFsdWVzKGNvbmZpZy5kaXJ0eUZpZWxkcyA/IF9mb3JtU3RhdGUuZGlydHlGaWVsZHMgOiBfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGZpZWxkTmFtZXMpXG4gICAgICAgICAgICA/IHZhbHVlc1xuICAgICAgICAgICAgOiBpc1N0cmluZyhmaWVsZE5hbWVzKVxuICAgICAgICAgICAgICAgID8gZ2V0KHZhbHVlcywgZmllbGROYW1lcylcbiAgICAgICAgICAgICAgICA6IGZpZWxkTmFtZXMubWFwKChuYW1lKSA9PiBnZXQodmFsdWVzLCBuYW1lKSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRGaWVsZFN0YXRlID0gKG5hbWUsIGZvcm1TdGF0ZSkgPT4gKHtcbiAgICAgICAgaW52YWxpZDogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5lcnJvcnMsIG5hbWUpLFxuICAgICAgICBpc0RpcnR5OiAhIWdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLmRpcnR5RmllbGRzLCBuYW1lKSxcbiAgICAgICAgZXJyb3I6IGdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLmVycm9ycywgbmFtZSksXG4gICAgICAgIGlzVmFsaWRhdGluZzogISFnZXQoX2Zvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLCBuYW1lKSxcbiAgICAgICAgaXNUb3VjaGVkOiAhIWdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLnRvdWNoZWRGaWVsZHMsIG5hbWUpLFxuICAgIH0pO1xuICAgIGNvbnN0IGNsZWFyRXJyb3JzID0gKG5hbWUpID0+IHtcbiAgICAgICAgbmFtZSAmJlxuICAgICAgICAgICAgY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpLmZvckVhY2goKGlucHV0TmFtZSkgPT4gdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIGlucHV0TmFtZSkpO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBlcnJvcnM6IG5hbWUgPyBfZm9ybVN0YXRlLmVycm9ycyA6IHt9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNldEVycm9yID0gKG5hbWUsIGVycm9yLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZiA9IChnZXQoX2ZpZWxkcywgbmFtZSwgeyBfZjoge30gfSkuX2YgfHwge30pLnJlZjtcbiAgICAgICAgY29uc3QgY3VycmVudEVycm9yID0gZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSB8fCB7fTtcbiAgICAgICAgLy8gRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgZXJyb3IgbWVzc2FnZXMgZWxzZXdoZXJlIGluIHRoZSBvYmplY3QgdHJlZS5cbiAgICAgICAgY29uc3QgeyByZWY6IGN1cnJlbnRSZWYsIG1lc3NhZ2UsIHR5cGUsIC4uLnJlc3RPZkVycm9yVHJlZSB9ID0gY3VycmVudEVycm9yO1xuICAgICAgICBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIHtcbiAgICAgICAgICAgIC4uLnJlc3RPZkVycm9yVHJlZSxcbiAgICAgICAgICAgIC4uLmVycm9yLFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICB9KTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5zaG91bGRGb2N1cyAmJiByZWYgJiYgcmVmLmZvY3VzICYmIHJlZi5mb2N1cygpO1xuICAgIH07XG4gICAgY29uc3Qgd2F0Y2ggPSAobmFtZSwgZGVmYXVsdFZhbHVlKSA9PiBpc0Z1bmN0aW9uKG5hbWUpXG4gICAgICAgID8gX3N1YmplY3RzLnN0YXRlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiAocGF5bG9hZCkgPT4gJ3ZhbHVlcycgaW4gcGF5bG9hZCAmJlxuICAgICAgICAgICAgICAgIG5hbWUoX2dldFdhdGNoKHVuZGVmaW5lZCwgZGVmYXVsdFZhbHVlKSwgcGF5bG9hZCksXG4gICAgICAgIH0pXG4gICAgICAgIDogX2dldFdhdGNoKG5hbWUsIGRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgY29uc3QgX3N1YnNjcmliZSA9IChwcm9wcykgPT4gX3N1YmplY3RzLnN0YXRlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IChmb3JtU3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRTdWJzY3JpYmVCeU5hbWUocHJvcHMubmFtZSwgZm9ybVN0YXRlLm5hbWUsIHByb3BzLmV4YWN0KSAmJlxuICAgICAgICAgICAgICAgIHNob3VsZFJlbmRlckZvcm1TdGF0ZShmb3JtU3RhdGUsIHByb3BzLmZvcm1TdGF0ZSB8fCBfcHJveHlGb3JtU3RhdGUsIF9zZXRGb3JtU3RhdGUsIHByb3BzLnJlUmVuZGVyUm9vdCkpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5jYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxuICAgICAgICAgICAgICAgICAgICAuLi5fZm9ybVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAuLi5mb3JtU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXM6IF9kZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pLnVuc3Vic2NyaWJlO1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IChwcm9wcykgPT4ge1xuICAgICAgICBfc3RhdGUubW91bnQgPSB0cnVlO1xuICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5fcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUsXG4gICAgICAgICAgICAuLi5wcm9wcy5mb3JtU3RhdGUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgZm9ybVN0YXRlOiBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdW5yZWdpc3RlciA9IChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgbmFtZSA/IGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lKSA6IF9uYW1lcy5tb3VudCkge1xuICAgICAgICAgICAgX25hbWVzLm1vdW50LmRlbGV0ZShmaWVsZE5hbWUpO1xuICAgICAgICAgICAgX25hbWVzLmFycmF5LmRlbGV0ZShmaWVsZE5hbWUpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHVuc2V0KF9maWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1WYWx1ZXMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwRXJyb3IgJiYgdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwRGlydHkgJiYgdW5zZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgICFvcHRpb25zLmtlZXBUb3VjaGVkICYmIHVuc2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgICFvcHRpb25zLmtlZXBJc1ZhbGlkYXRpbmcgJiZcbiAgICAgICAgICAgICAgICB1bnNldChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciAmJlxuICAgICAgICAgICAgICAgICFvcHRpb25zLmtlZXBEZWZhdWx0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICB1bnNldChfZGVmYXVsdFZhbHVlcywgZmllbGROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKSxcbiAgICAgICAgfSk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAuLi4oIW9wdGlvbnMua2VlcERpcnR5ID8ge30gOiB7IGlzRGlydHk6IF9nZXREaXJ0eSgpIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgIW9wdGlvbnMua2VlcElzVmFsaWQgJiYgX3NldFZhbGlkKCk7XG4gICAgfTtcbiAgICBjb25zdCBfc2V0RGlzYWJsZWRGaWVsZCA9ICh7IGRpc2FibGVkLCBuYW1lLCB9KSA9PiB7XG4gICAgICAgIGlmICgoaXNCb29sZWFuKGRpc2FibGVkKSAmJiBfc3RhdGUubW91bnQpIHx8XG4gICAgICAgICAgICAhIWRpc2FibGVkIHx8XG4gICAgICAgICAgICBfbmFtZXMuZGlzYWJsZWQuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBkaXNhYmxlZCA/IF9uYW1lcy5kaXNhYmxlZC5hZGQobmFtZSkgOiBfbmFtZXMuZGlzYWJsZWQuZGVsZXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlciA9IChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgbGV0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBjb25zdCBkaXNhYmxlZElzRGVmaW5lZCA9IGlzQm9vbGVhbihvcHRpb25zLmRpc2FibGVkKSB8fCBpc0Jvb2xlYW4oX29wdGlvbnMuZGlzYWJsZWQpO1xuICAgICAgICBzZXQoX2ZpZWxkcywgbmFtZSwge1xuICAgICAgICAgICAgLi4uKGZpZWxkIHx8IHt9KSxcbiAgICAgICAgICAgIF9mOiB7XG4gICAgICAgICAgICAgICAgLi4uKGZpZWxkICYmIGZpZWxkLl9mID8gZmllbGQuX2YgOiB7IHJlZjogeyBuYW1lIH0gfSksXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBtb3VudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIF9uYW1lcy5tb3VudC5hZGQobmFtZSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgX3NldERpc2FibGVkRmllbGQoe1xuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBpc0Jvb2xlYW4ob3B0aW9ucy5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIDogX29wdGlvbnMuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlVmFsaWRBbmRWYWx1ZShuYW1lLCB0cnVlLCBvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uKGRpc2FibGVkSXNEZWZpbmVkXG4gICAgICAgICAgICAgICAgPyB7IGRpc2FibGVkOiBvcHRpb25zLmRpc2FibGVkIHx8IF9vcHRpb25zLmRpc2FibGVkIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIC4uLihfb3B0aW9ucy5wcm9ncmVzc2l2ZVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogISFvcHRpb25zLnJlcXVpcmVkLFxuICAgICAgICAgICAgICAgICAgICBtaW46IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1pbiksXG4gICAgICAgICAgICAgICAgICAgIG1heDogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWF4KSxcbiAgICAgICAgICAgICAgICAgICAgbWluTGVuZ3RoOiBnZXRSdWxlVmFsdWUob3B0aW9ucy5taW5MZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBtYXhMZW5ndGg6IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1heExlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGdldFJ1bGVWYWx1ZShvcHRpb25zLnBhdHRlcm4pLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgICAgIG9uQmx1cjogb25DaGFuZ2UsXG4gICAgICAgICAgICByZWY6IChyZWYpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyKG5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRSZWYgPSBpc1VuZGVmaW5lZChyZWYudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZi5xdWVyeVNlbGVjdG9yQWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZWYucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsc2VsZWN0LHRleHRhcmVhJylbMF0gfHwgcmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZWZcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYWRpb09yQ2hlY2tib3ggPSBpc1JhZGlvT3JDaGVja2JveChmaWVsZFJlZik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZnMgPSBmaWVsZC5fZi5yZWZzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFkaW9PckNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZnMuZmluZCgob3B0aW9uKSA9PiBvcHRpb24gPT09IGZpZWxkUmVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWVsZFJlZiA9PT0gZmllbGQuX2YucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0KF9maWVsZHMsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmllbGQuX2YsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHJhZGlvT3JDaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5yZWZzLmZpbHRlcihsaXZlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpKSA/IFt7fV0gOiBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiB7IHR5cGU6IGZpZWxkUmVmLnR5cGUsIG5hbWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHsgcmVmOiBmaWVsZFJlZiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWxpZEFuZFZhbHVlKG5hbWUsIGZhbHNlLCB1bmRlZmluZWQsIGZpZWxkUmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLl9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5fZi5tb3VudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyIHx8IG9wdGlvbnMuc2hvdWxkVW5yZWdpc3RlcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEoaXNOYW1lSW5GaWVsZEFycmF5KF9uYW1lcy5hcnJheSwgbmFtZSkgJiYgX3N0YXRlLmFjdGlvbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF9uYW1lcy51bk1vdW50LmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgX2ZvY3VzRXJyb3IgPSAoKSA9PiBfb3B0aW9ucy5zaG91bGRGb2N1c0Vycm9yICYmXG4gICAgICAgIGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihfZmllbGRzLCBfZm9jdXNJbnB1dCwgX25hbWVzLm1vdW50KTtcbiAgICBjb25zdCBfZGlzYWJsZUZvcm0gPSAoZGlzYWJsZWQpID0+IHtcbiAgICAgICAgaWYgKGlzQm9vbGVhbihkaXNhYmxlZCkpIHtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgZGlzYWJsZWQgfSk7XG4gICAgICAgICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oX2ZpZWxkcywgKHJlZiwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRGaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5kaXNhYmxlZCA9IGN1cnJlbnRGaWVsZC5fZi5kaXNhYmxlZCB8fCBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudEZpZWxkLl9mLnJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RmllbGQuX2YucmVmcy5mb3JFYWNoKChpbnB1dFJlZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0UmVmLmRpc2FibGVkID0gY3VycmVudEZpZWxkLl9mLmRpc2FibGVkIHx8IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAwLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IChvblZhbGlkLCBvbkludmFsaWQpID0+IGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGxldCBvblZhbGlkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUucGVyc2lzdCAmJlxuICAgICAgICAgICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZFZhbHVlcyA9IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgaXNTdWJtaXR0aW5nOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVycm9ycywgdmFsdWVzIH0gPSBhd2FpdCBfcnVuU2NoZW1hKCk7XG4gICAgICAgICAgICBfZm9ybVN0YXRlLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgICAgIGZpZWxkVmFsdWVzID0gY2xvbmVPYmplY3QodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihfZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX25hbWVzLmRpc2FibGVkLnNpemUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBfbmFtZXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB1bnNldChmaWVsZFZhbHVlcywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsICdyb290Jyk7XG4gICAgICAgIGlmIChpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUuZXJyb3JzKSkge1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGVycm9yczoge30sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25WYWxpZChmaWVsZFZhbHVlcywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvblZhbGlkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvbkludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBvbkludmFsaWQoeyAuLi5fZm9ybVN0YXRlLmVycm9ycyB9LCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9mb2N1c0Vycm9yKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KF9mb2N1c0Vycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBpc1N1Ym1pdHRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGlzRW1wdHlPYmplY3QoX2Zvcm1TdGF0ZS5lcnJvcnMpICYmICFvblZhbGlkRXJyb3IsXG4gICAgICAgICAgICBzdWJtaXRDb3VudDogX2Zvcm1TdGF0ZS5zdWJtaXRDb3VudCArIDEsXG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9uVmFsaWRFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgb25WYWxpZEVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXNldEZpZWxkID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBpZiAoZ2V0KF9maWVsZHMsIG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQob3B0aW9ucy5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWUobmFtZSwgY2xvbmVPYmplY3QoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWUobmFtZSwgb3B0aW9ucy5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgIHNldChfZGVmYXVsdFZhbHVlcywgbmFtZSwgY2xvbmVPYmplY3Qob3B0aW9ucy5kZWZhdWx0VmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwVG91Y2hlZCkge1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcERpcnR5KSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgX2Zvcm1TdGF0ZS5pc0RpcnR5ID0gb3B0aW9ucy5kZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgPyBfZ2V0RGlydHkobmFtZSwgY2xvbmVPYmplY3QoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSkpXG4gICAgICAgICAgICAgICAgICAgIDogX2dldERpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkICYmIF9zZXRWYWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfcmVzZXQgPSAoZm9ybVZhbHVlcywga2VlcFN0YXRlT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRWYWx1ZXMgPSBmb3JtVmFsdWVzID8gY2xvbmVPYmplY3QoZm9ybVZhbHVlcykgOiBfZGVmYXVsdFZhbHVlcztcbiAgICAgICAgY29uc3QgY2xvbmVVcGRhdGVkVmFsdWVzID0gY2xvbmVPYmplY3QodXBkYXRlZFZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGlzRW1wdHlSZXNldFZhbHVlcyA9IGlzRW1wdHlPYmplY3QoZm9ybVZhbHVlcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGlzRW1wdHlSZXNldFZhbHVlcyA/IF9kZWZhdWx0VmFsdWVzIDogY2xvbmVVcGRhdGVkVmFsdWVzO1xuICAgICAgICBpZiAoIWtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgICAgIF9kZWZhdWx0VmFsdWVzID0gdXBkYXRlZFZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtlZXBTdGF0ZU9wdGlvbnMua2VlcFZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzVG9DaGVjayA9IG5ldyBTZXQoW1xuICAgICAgICAgICAgICAgICAgICAuLi5fbmFtZXMubW91bnQsXG4gICAgICAgICAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcykpLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIEFycmF5LmZyb20oZmllbGRzVG9DaGVjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIGZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2V0KHZhbHVlcywgZmllbGROYW1lLCBnZXQoX2Zvcm1WYWx1ZXMsIGZpZWxkTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNldFZhbHVlKGZpZWxkTmFtZSwgZ2V0KHZhbHVlcywgZmllbGROYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2ViICYmIGlzVW5kZWZpbmVkKGZvcm1WYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBfbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLl9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBBcnJheS5pc0FycmF5KGZpZWxkLl9mLnJlZnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmllbGQuX2YucmVmc1swXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkLl9mLnJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNIVE1MRWxlbWVudChmaWVsZFJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybSA9IGZpZWxkUmVmZXJlbmNlLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZWVwU3RhdGVPcHRpb25zLmtlZXBGaWVsZHNSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgX25hbWVzLm1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZShmaWVsZE5hbWUsIGdldCh2YWx1ZXMsIGZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfZmllbGRzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2Zvcm1WYWx1ZXMgPSBfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyXG4gICAgICAgICAgICAgICAgPyBrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzXG4gICAgICAgICAgICAgICAgICAgID8gY2xvbmVPYmplY3QoX2RlZmF1bHRWYWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgIDoge31cbiAgICAgICAgICAgICAgICA6IGNsb25lT2JqZWN0KHZhbHVlcyk7XG4gICAgICAgICAgICBfc3ViamVjdHMuYXJyYXkubmV4dCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLnZhbHVlcyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLnZhbHVlcyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX25hbWVzID0ge1xuICAgICAgICAgICAgbW91bnQ6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5VmFsdWVzID8gX25hbWVzLm1vdW50IDogbmV3IFNldCgpLFxuICAgICAgICAgICAgdW5Nb3VudDogbmV3IFNldCgpLFxuICAgICAgICAgICAgYXJyYXk6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB3YXRjaDogbmV3IFNldCgpLFxuICAgICAgICAgICAgd2F0Y2hBbGw6IGZhbHNlLFxuICAgICAgICAgICAgZm9jdXM6ICcnLFxuICAgICAgICB9O1xuICAgICAgICBfc3RhdGUubW91bnQgPVxuICAgICAgICAgICAgIV9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8XG4gICAgICAgICAgICAgICAgISFrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1ZhbGlkIHx8XG4gICAgICAgICAgICAgICAgISFrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVZhbHVlcyB8fFxuICAgICAgICAgICAgICAgICghX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciAmJiAhaXNFbXB0eU9iamVjdCh2YWx1ZXMpKTtcbiAgICAgICAgX3N0YXRlLndhdGNoID0gISFfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBzdWJtaXRDb3VudDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwU3VibWl0Q291bnRcbiAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuc3VibWl0Q291bnRcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBpc0RpcnR5OiBpc0VtcHR5UmVzZXRWYWx1ZXNcbiAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVxuICAgICAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuaXNEaXJ0eVxuICAgICAgICAgICAgICAgICAgICA6ICEhKGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFkZWVwRXF1YWwoZm9ybVZhbHVlcywgX2RlZmF1bHRWYWx1ZXMpKSxcbiAgICAgICAgICAgIGlzU3VibWl0dGVkOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1N1Ym1pdHRlZFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZFxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBkaXJ0eUZpZWxkczogaXNFbXB0eVJlc2V0VmFsdWVzXG4gICAgICAgICAgICAgICAgPyB7fVxuICAgICAgICAgICAgICAgIDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgPyBrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzICYmIF9mb3JtVmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkc1xuICAgICAgICAgICAgICAgICAgICA6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiYgZm9ybVZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgZm9ybVZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuZGlydHlGaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgdG91Y2hlZEZpZWxkczoga2VlcFN0YXRlT3B0aW9ucy5rZWVwVG91Y2hlZFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzXG4gICAgICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgICAgIGVycm9yczoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRXJyb3JzID8gX2Zvcm1TdGF0ZS5lcnJvcnMgOiB7fSxcbiAgICAgICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwSXNTdWJtaXRTdWNjZXNzZnVsXG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLmlzU3VibWl0U3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczogX2RlZmF1bHRWYWx1ZXMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoZm9ybVZhbHVlcywga2VlcFN0YXRlT3B0aW9ucykgPT4gX3Jlc2V0KGlzRnVuY3Rpb24oZm9ybVZhbHVlcylcbiAgICAgICAgPyBmb3JtVmFsdWVzKF9mb3JtVmFsdWVzKVxuICAgICAgICA6IGZvcm1WYWx1ZXMsIGtlZXBTdGF0ZU9wdGlvbnMpO1xuICAgIGNvbnN0IHNldEZvY3VzID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBmaWVsZCAmJiBmaWVsZC5fZjtcbiAgICAgICAgaWYgKGZpZWxkUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFJlZiA9IGZpZWxkUmVmZXJlbmNlLnJlZnNcbiAgICAgICAgICAgICAgICA/IGZpZWxkUmVmZXJlbmNlLnJlZnNbMF1cbiAgICAgICAgICAgICAgICA6IGZpZWxkUmVmZXJlbmNlLnJlZjtcbiAgICAgICAgICAgIGlmIChmaWVsZFJlZi5mb2N1cykge1xuICAgICAgICAgICAgICAgIGZpZWxkUmVmLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGRTZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihmaWVsZFJlZi5zZWxlY3QpICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmLnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfc2V0Rm9ybVN0YXRlID0gKHVwZGF0ZWRGb3JtU3RhdGUpID0+IHtcbiAgICAgICAgX2Zvcm1TdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAuLi51cGRhdGVkRm9ybVN0YXRlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgX3Jlc2V0RGVmYXVsdFZhbHVlcyA9ICgpID0+IGlzRnVuY3Rpb24oX29wdGlvbnMuZGVmYXVsdFZhbHVlcykgJiZcbiAgICAgICAgX29wdGlvbnMuZGVmYXVsdFZhbHVlcygpLnRoZW4oKHZhbHVlcykgPT4ge1xuICAgICAgICAgICAgcmVzZXQodmFsdWVzLCBfb3B0aW9ucy5yZXNldE9wdGlvbnMpO1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgcmVnaXN0ZXIsXG4gICAgICAgICAgICB1bnJlZ2lzdGVyLFxuICAgICAgICAgICAgZ2V0RmllbGRTdGF0ZSxcbiAgICAgICAgICAgIGhhbmRsZVN1Ym1pdCxcbiAgICAgICAgICAgIHNldEVycm9yLFxuICAgICAgICAgICAgX3N1YnNjcmliZSxcbiAgICAgICAgICAgIF9ydW5TY2hlbWEsXG4gICAgICAgICAgICBfZm9jdXNFcnJvcixcbiAgICAgICAgICAgIF9nZXRXYXRjaCxcbiAgICAgICAgICAgIF9nZXREaXJ0eSxcbiAgICAgICAgICAgIF9zZXRWYWxpZCxcbiAgICAgICAgICAgIF9zZXRGaWVsZEFycmF5LFxuICAgICAgICAgICAgX3NldERpc2FibGVkRmllbGQsXG4gICAgICAgICAgICBfc2V0RXJyb3JzLFxuICAgICAgICAgICAgX2dldEZpZWxkQXJyYXksXG4gICAgICAgICAgICBfcmVzZXQsXG4gICAgICAgICAgICBfcmVzZXREZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgX3JlbW92ZVVubW91bnRlZCxcbiAgICAgICAgICAgIF9kaXNhYmxlRm9ybSxcbiAgICAgICAgICAgIF9zdWJqZWN0cyxcbiAgICAgICAgICAgIF9wcm94eUZvcm1TdGF0ZSxcbiAgICAgICAgICAgIGdldCBfZmllbGRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZmllbGRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfZm9ybVZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Zvcm1WYWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9zdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0YXRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBfc3RhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc3RhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgX2RlZmF1bHRWYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9kZWZhdWx0VmFsdWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfbmFtZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYW1lcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX25hbWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX25hbWVzID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9mb3JtU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mb3JtU3RhdGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9vcHRpb25zKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfb3B0aW9ucztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX29wdGlvbnModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uX29wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIHRyaWdnZXIsXG4gICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICBoYW5kbGVTdWJtaXQsXG4gICAgICAgIHdhdGNoLFxuICAgICAgICBzZXRWYWx1ZSxcbiAgICAgICAgZ2V0VmFsdWVzLFxuICAgICAgICByZXNldCxcbiAgICAgICAgcmVzZXRGaWVsZCxcbiAgICAgICAgY2xlYXJFcnJvcnMsXG4gICAgICAgIHVucmVnaXN0ZXIsXG4gICAgICAgIHNldEVycm9yLFxuICAgICAgICBzZXRGb2N1cyxcbiAgICAgICAgZ2V0RmllbGRTdGF0ZSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGhvZHMsXG4gICAgICAgIGZvcm1Db250cm9sOiBtZXRob2RzLFxuICAgIH07XG59XG5cbnZhciBnZW5lcmF0ZUlkID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICB9XG4gICAgY29uc3QgZCA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcgPyBEYXRlLm5vdygpIDogcGVyZm9ybWFuY2Uubm93KCkgKiAxMDAwO1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2ICsgZCkgJSAxNiB8IDA7XG4gICAgICAgIHJldHVybiAoYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4KS50b1N0cmluZygxNik7XG4gICAgfSk7XG59O1xuXG52YXIgZ2V0Rm9jdXNGaWVsZE5hbWUgPSAobmFtZSwgaW5kZXgsIG9wdGlvbnMgPSB7fSkgPT4gb3B0aW9ucy5zaG91bGRGb2N1cyB8fCBpc1VuZGVmaW5lZChvcHRpb25zLnNob3VsZEZvY3VzKVxuICAgID8gb3B0aW9ucy5mb2N1c05hbWUgfHxcbiAgICAgICAgYCR7bmFtZX0uJHtpc1VuZGVmaW5lZChvcHRpb25zLmZvY3VzSW5kZXgpID8gaW5kZXggOiBvcHRpb25zLmZvY3VzSW5kZXh9LmBcbiAgICA6ICcnO1xuXG52YXIgYXBwZW5kQXQgPSAoZGF0YSwgdmFsdWUpID0+IFtcbiAgICAuLi5kYXRhLFxuICAgIC4uLmNvbnZlcnRUb0FycmF5UGF5bG9hZCh2YWx1ZSksXG5dO1xuXG52YXIgZmlsbEVtcHR5QXJyYXkgPSAodmFsdWUpID0+IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKCgpID0+IHVuZGVmaW5lZCkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGluc2VydChkYXRhLCBpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAuLi5kYXRhLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKHZhbHVlKSxcbiAgICAgICAgLi4uZGF0YS5zbGljZShpbmRleCksXG4gICAgXTtcbn1cblxudmFyIG1vdmVBcnJheUF0ID0gKGRhdGEsIGZyb20sIHRvKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWZpbmVkKGRhdGFbdG9dKSkge1xuICAgICAgICBkYXRhW3RvXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZGF0YS5zcGxpY2UodG8sIDAsIGRhdGEuc3BsaWNlKGZyb20sIDEpWzBdKTtcbiAgICByZXR1cm4gZGF0YTtcbn07XG5cbnZhciBwcmVwZW5kQXQgPSAoZGF0YSwgdmFsdWUpID0+IFtcbiAgICAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpLFxuICAgIC4uLmNvbnZlcnRUb0FycmF5UGF5bG9hZChkYXRhKSxcbl07XG5cbmZ1bmN0aW9uIHJlbW92ZUF0SW5kZXhlcyhkYXRhLCBpbmRleGVzKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IHRlbXAgPSBbLi4uZGF0YV07XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgICAgIHRlbXAuc3BsaWNlKGluZGV4IC0gaSwgMSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhY3QodGVtcCkubGVuZ3RoID8gdGVtcCA6IFtdO1xufVxudmFyIHJlbW92ZUFycmF5QXQgPSAoZGF0YSwgaW5kZXgpID0+IGlzVW5kZWZpbmVkKGluZGV4KVxuICAgID8gW11cbiAgICA6IHJlbW92ZUF0SW5kZXhlcyhkYXRhLCBjb252ZXJ0VG9BcnJheVBheWxvYWQoaW5kZXgpLnNvcnQoKGEsIGIpID0+IGEgLSBiKSk7XG5cbnZhciBzd2FwQXJyYXlBdCA9IChkYXRhLCBpbmRleEEsIGluZGV4QikgPT4ge1xuICAgIFtkYXRhW2luZGV4QV0sIGRhdGFbaW5kZXhCXV0gPSBbZGF0YVtpbmRleEJdLCBkYXRhW2luZGV4QV1dO1xufTtcblxudmFyIHVwZGF0ZUF0ID0gKGZpZWxkVmFsdWVzLCBpbmRleCwgdmFsdWUpID0+IHtcbiAgICBmaWVsZFZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gZmllbGRWYWx1ZXM7XG59O1xuXG4vKipcbiAqIEEgY3VzdG9tIGhvb2sgdGhhdCBleHBvc2VzIGNvbnZlbmllbnQgbWV0aG9kcyB0byBwZXJmb3JtIG9wZXJhdGlvbnMgd2l0aCBhIGxpc3Qgb2YgZHluYW1pYyBpbnB1dHMgdGhhdCBuZWVkIHRvIGJlIGFwcGVuZGVkLCB1cGRhdGVkLCByZW1vdmVkIGV0Yy4g4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXVzZWZpZWxkYXJyYXktc3N1Z24pIOKAoiBbVmlkZW9dKGh0dHBzOi8veW91dHUuYmUvNE1yYmZHU0ZZMkEpXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZpZWxkYXJyYXkpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS11c2VmaWVsZGFycmF5LXNzdWduKVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIHVzZUZpZWxkQXJyYXkgcHJvcHNcbiAqXG4gKiBAcmV0dXJucyBtZXRob2RzIC0gZnVuY3Rpb25zIHRvIG1hbmlwdWxhdGUgd2l0aCB0aGUgRmllbGQgQXJyYXlzIChkeW5hbWljIGlucHV0cykge0BsaW5rIFVzZUZpZWxkQXJyYXlSZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyLCBjb250cm9sLCBoYW5kbGVTdWJtaXQsIHJlc2V0LCB0cmlnZ2VyLCBzZXRFcnJvciB9ID0gdXNlRm9ybSh7XG4gKiAgICAgZGVmYXVsdFZhbHVlczoge1xuICogICAgICAgdGVzdDogW11cbiAqICAgICB9XG4gKiAgIH0pO1xuICogICBjb25zdCB7IGZpZWxkcywgYXBwZW5kIH0gPSB1c2VGaWVsZEFycmF5KHtcbiAqICAgICBjb250cm9sLFxuICogICAgIG5hbWU6IFwidGVzdFwiXG4gKiAgIH0pO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0KGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSkpfT5cbiAqICAgICAgIHtmaWVsZHMubWFwKChpdGVtLCBpbmRleCkgPT4gKFxuICogICAgICAgICAgPGlucHV0IGtleT17aXRlbS5pZH0gey4uLnJlZ2lzdGVyKGB0ZXN0LiR7aW5kZXh9LmZpcnN0TmFtZWApfSAgLz5cbiAqICAgICAgICkpfVxuICogICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17KCkgPT4gYXBwZW5kKHsgZmlyc3ROYW1lOiBcImJpbGxcIiB9KX0+XG4gKiAgICAgICAgIGFwcGVuZFxuICogICAgICAgPC9idXR0b24+XG4gKiAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgPC9mb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUZpZWxkQXJyYXkocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCB7IGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIG5hbWUsIGtleU5hbWUgPSAnaWQnLCBzaG91bGRVbnJlZ2lzdGVyLCBydWxlcywgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtmaWVsZHMsIHNldEZpZWxkc10gPSBSZWFjdC51c2VTdGF0ZShjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpKTtcbiAgICBjb25zdCBpZHMgPSBSZWFjdC51c2VSZWYoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKS5tYXAoZ2VuZXJhdGVJZCkpO1xuICAgIGNvbnN0IF9hY3Rpb25lZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgY29udHJvbC5fbmFtZXMuYXJyYXkuYWRkKG5hbWUpO1xuICAgIFJlYWN0LnVzZU1lbW8oKCkgPT4gcnVsZXMgJiZcbiAgICAgICAgZmllbGRzLmxlbmd0aCA+PSAwICYmXG4gICAgICAgIGNvbnRyb2wucmVnaXN0ZXIobmFtZSwgcnVsZXMpLCBbY29udHJvbCwgbmFtZSwgZmllbGRzLmxlbmd0aCwgcnVsZXNdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGNvbnRyb2wuX3N1YmplY3RzLmFycmF5LnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6ICh7IHZhbHVlcywgbmFtZTogZmllbGRBcnJheU5hbWUsIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZEFycmF5TmFtZSA9PT0gbmFtZSB8fCAhZmllbGRBcnJheU5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldCh2YWx1ZXMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkVmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRGaWVsZHMoZmllbGRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZHMuY3VycmVudCA9IGZpZWxkVmFsdWVzLm1hcChnZW5lcmF0ZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSkudW5zdWJzY3JpYmUsIFtjb250cm9sLCBuYW1lXSk7XG4gICAgY29uc3QgdXBkYXRlVmFsdWVzID0gUmVhY3QudXNlQ2FsbGJhY2soKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKSA9PiB7XG4gICAgICAgIF9hY3Rpb25lZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgfSwgW2NvbnRyb2wsIG5hbWVdKTtcbiAgICBjb25zdCBhcHBlbmQgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgYXBwZW5kVmFsdWUgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBhcHBlbmRBdChjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpLCBhcHBlbmRWYWx1ZSk7XG4gICAgICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzID0gZ2V0Rm9jdXNGaWVsZE5hbWUobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMubGVuZ3RoIC0gMSwgb3B0aW9ucyk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gYXBwZW5kQXQoaWRzLmN1cnJlbnQsIGFwcGVuZFZhbHVlLm1hcChnZW5lcmF0ZUlkKSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGFwcGVuZEF0LCB7XG4gICAgICAgICAgICBhcmdBOiBmaWxsRW1wdHlBcnJheSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcHJlcGVuZCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBwcmVwZW5kVmFsdWUgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBwcmVwZW5kQXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgcHJlcGVuZFZhbHVlKTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSBnZXRGb2N1c0ZpZWxkTmFtZShuYW1lLCAwLCBvcHRpb25zKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSBwcmVwZW5kQXQoaWRzLmN1cnJlbnQsIHByZXBlbmRWYWx1ZS5tYXAoZ2VuZXJhdGVJZCkpO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBwcmVwZW5kQXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGZpbGxFbXB0eUFycmF5KHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUgPSAoaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSByZW1vdmVBcnJheUF0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGluZGV4KTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSByZW1vdmVBcnJheUF0KGlkcy5jdXJyZW50LCBpbmRleCk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgICFBcnJheS5pc0FycmF5KGdldChjb250cm9sLl9maWVsZHMsIG5hbWUpKSAmJlxuICAgICAgICAgICAgc2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgcmVtb3ZlQXJyYXlBdCwge1xuICAgICAgICAgICAgYXJnQTogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0JDEgPSAoaW5kZXgsIHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGluc2VydFZhbHVlID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGNsb25lT2JqZWN0KHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gaW5zZXJ0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGluZGV4LCBpbnNlcnRWYWx1ZSk7XG4gICAgICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzID0gZ2V0Rm9jdXNGaWVsZE5hbWUobmFtZSwgaW5kZXgsIG9wdGlvbnMpO1xuICAgICAgICBpZHMuY3VycmVudCA9IGluc2VydChpZHMuY3VycmVudCwgaW5kZXgsIGluc2VydFZhbHVlLm1hcChnZW5lcmF0ZUlkKSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGluc2VydCwge1xuICAgICAgICAgICAgYXJnQTogaW5kZXgsXG4gICAgICAgICAgICBhcmdCOiBmaWxsRW1wdHlBcnJheSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc3dhcCA9IChpbmRleEEsIGluZGV4QikgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSk7XG4gICAgICAgIHN3YXBBcnJheUF0KHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBpbmRleEEsIGluZGV4Qik7XG4gICAgICAgIHN3YXBBcnJheUF0KGlkcy5jdXJyZW50LCBpbmRleEEsIGluZGV4Qik7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIHN3YXBBcnJheUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleEEsXG4gICAgICAgICAgICBhcmdCOiBpbmRleEIsXG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmUgPSAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpO1xuICAgICAgICBtb3ZlQXJyYXlBdCh1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgZnJvbSwgdG8pO1xuICAgICAgICBtb3ZlQXJyYXlBdChpZHMuY3VycmVudCwgZnJvbSwgdG8pO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBtb3ZlQXJyYXlBdCwge1xuICAgICAgICAgICAgYXJnQTogZnJvbSxcbiAgICAgICAgICAgIGFyZ0I6IHRvLFxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGUgPSAoaW5kZXgsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVZhbHVlID0gY2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHVwZGF0ZUF0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGluZGV4LCB1cGRhdGVWYWx1ZSk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXS5tYXAoKGl0ZW0sIGkpID0+ICFpdGVtIHx8IGkgPT09IGluZGV4ID8gZ2VuZXJhdGVJZCgpIDogaWRzLmN1cnJlbnRbaV0pO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHMoWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXSk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIHVwZGF0ZUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleCxcbiAgICAgICAgICAgIGFyZ0I6IHVwZGF0ZVZhbHVlLFxuICAgICAgICB9LCB0cnVlLCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCByZXBsYWNlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGNsb25lT2JqZWN0KHZhbHVlKSk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMubWFwKGdlbmVyYXRlSWQpO1xuICAgICAgICB1cGRhdGVWYWx1ZXMoWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXSk7XG4gICAgICAgIHNldEZpZWxkcyhbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCBbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdLCAoZGF0YSkgPT4gZGF0YSwge30sIHRydWUsIGZhbHNlKTtcbiAgICB9O1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnRyb2wuX3N0YXRlLmFjdGlvbiA9IGZhbHNlO1xuICAgICAgICBpc1dhdGNoZWQobmFtZSwgY29udHJvbC5fbmFtZXMpICYmXG4gICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAuLi5jb250cm9sLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKF9hY3Rpb25lZC5jdXJyZW50ICYmXG4gICAgICAgICAgICAoIWdldFZhbGlkYXRpb25Nb2Rlcyhjb250cm9sLl9vcHRpb25zLm1vZGUpLmlzT25TdWJtaXQgfHxcbiAgICAgICAgICAgICAgICBjb250cm9sLl9mb3JtU3RhdGUuaXNTdWJtaXR0ZWQpICYmXG4gICAgICAgICAgICAhZ2V0VmFsaWRhdGlvbk1vZGVzKGNvbnRyb2wuX29wdGlvbnMucmVWYWxpZGF0ZU1vZGUpLmlzT25TdWJtaXQpIHtcbiAgICAgICAgICAgIGlmIChjb250cm9sLl9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5fcnVuU2NoZW1hKFtuYW1lXSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZ2V0KHJlc3VsdC5lcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0Vycm9yID0gZ2V0KGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoIWVycm9yICYmIGV4aXN0aW5nRXJyb3IudHlwZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV4aXN0aW5nRXJyb3IudHlwZSAhPT0gZXJyb3IudHlwZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdFcnJvci5tZXNzYWdlICE9PSBlcnJvci5tZXNzYWdlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZXJyb3IgJiYgZXJyb3IudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNldChjb250cm9sLl9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCBlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuc2V0KGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBjb250cm9sLl9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLl9mICYmXG4gICAgICAgICAgICAgICAgICAgICEoZ2V0VmFsaWRhdGlvbk1vZGVzKGNvbnRyb2wuX29wdGlvbnMucmVWYWxpZGF0ZU1vZGUpLmlzT25TdWJtaXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbGlkYXRpb25Nb2Rlcyhjb250cm9sLl9vcHRpb25zLm1vZGUpLmlzT25TdWJtaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRmllbGQoZmllbGQsIGNvbnRyb2wuX25hbWVzLmRpc2FibGVkLCBjb250cm9sLl9mb3JtVmFsdWVzLCBjb250cm9sLl9vcHRpb25zLmNyaXRlcmlhTW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLmFsbCwgY29udHJvbC5fb3B0aW9ucy5zaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uLCB0cnVlKS50aGVuKChlcnJvcikgPT4gIWlzRW1wdHlPYmplY3QoZXJyb3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IHVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgZXJyb3IsIG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgJiZcbiAgICAgICAgICAgIGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihjb250cm9sLl9maWVsZHMsIChyZWYsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sLl9uYW1lcy5mb2N1cyAmJlxuICAgICAgICAgICAgICAgICAgICBrZXkuc3RhcnRzV2l0aChjb250cm9sLl9uYW1lcy5mb2N1cykgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVmLmZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzID0gJyc7XG4gICAgICAgIGNvbnRyb2wuX3NldFZhbGlkKCk7XG4gICAgICAgIF9hY3Rpb25lZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSwgW2ZpZWxkcywgbmFtZSwgY29udHJvbF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICFnZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSkgJiYgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZU1vdW50ZWQgPSAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChjb250cm9sLl9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCAmJiBmaWVsZC5fZikge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZC5fZi5tb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb250cm9sLl9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgfHwgc2hvdWxkVW5yZWdpc3RlclxuICAgICAgICAgICAgICAgID8gY29udHJvbC51bnJlZ2lzdGVyKG5hbWUpXG4gICAgICAgICAgICAgICAgOiB1cGRhdGVNb3VudGVkKG5hbWUsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbbmFtZSwgY29udHJvbCwga2V5TmFtZSwgc2hvdWxkVW5yZWdpc3Rlcl0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN3YXA6IFJlYWN0LnVzZUNhbGxiYWNrKHN3YXAsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgbW92ZTogUmVhY3QudXNlQ2FsbGJhY2sobW92ZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBwcmVwZW5kOiBSZWFjdC51c2VDYWxsYmFjayhwcmVwZW5kLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIGFwcGVuZDogUmVhY3QudXNlQ2FsbGJhY2soYXBwZW5kLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIHJlbW92ZTogUmVhY3QudXNlQ2FsbGJhY2socmVtb3ZlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIGluc2VydDogUmVhY3QudXNlQ2FsbGJhY2soaW5zZXJ0JDEsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgdXBkYXRlOiBSZWFjdC51c2VDYWxsYmFjayh1cGRhdGUsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgcmVwbGFjZTogUmVhY3QudXNlQ2FsbGJhY2socmVwbGFjZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBmaWVsZHM6IFJlYWN0LnVzZU1lbW8oKCkgPT4gZmllbGRzLm1hcCgoZmllbGQsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgICAgICBba2V5TmFtZV06IGlkcy5jdXJyZW50W2luZGV4XSB8fCBnZW5lcmF0ZUlkKCksXG4gICAgICAgIH0pKSwgW2ZpZWxkcywga2V5TmFtZV0pLFxuICAgIH07XG59XG5cbi8qKlxuICogQ3VzdG9tIGhvb2sgdG8gbWFuYWdlIHRoZSBlbnRpcmUgZm9ybS5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZm9ybSkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLWdldC1zdGFydGVkLXRzLTVrc21tKSDigKIgW1ZpZGVvXShodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PVJrWHY0QVhYQ180KVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIGZvcm0gY29uZmlndXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBwYXJhbWV0ZXJzLlxuICpcbiAqIEByZXR1cm5zIG1ldGhvZHMgLSBpbmRpdmlkdWFsIGZ1bmN0aW9ucyB0byBtYW5hZ2UgdGhlIGZvcm0gc3RhdGUuIHtAbGluayBVc2VGb3JtUmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciwgaGFuZGxlU3VibWl0LCB3YXRjaCwgZm9ybVN0YXRlOiB7IGVycm9ycyB9IH0gPSB1c2VGb3JtKCk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIGNvbnNvbGUubG9nKHdhdGNoKFwiZXhhbXBsZVwiKSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXQob25TdWJtaXQpfT5cbiAqICAgICAgIDxpbnB1dCBkZWZhdWx0VmFsdWU9XCJ0ZXN0XCIgey4uLnJlZ2lzdGVyKFwiZXhhbXBsZVwiKX0gLz5cbiAqICAgICAgIDxpbnB1dCB7Li4ucmVnaXN0ZXIoXCJleGFtcGxlUmVxdWlyZWRcIiwgeyByZXF1aXJlZDogdHJ1ZSB9KX0gLz5cbiAqICAgICAgIHtlcnJvcnMuZXhhbXBsZVJlcXVpcmVkICYmIDxzcGFuPlRoaXMgZmllbGQgaXMgcmVxdWlyZWQ8L3NwYW4+fVxuICogICAgICAgPGJ1dHRvbj5TdWJtaXQ8L2J1dHRvbj5cbiAqICAgICA8L2Zvcm0+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlRm9ybShwcm9wcyA9IHt9KSB7XG4gICAgY29uc3QgX2Zvcm1Db250cm9sID0gUmVhY3QudXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgX3ZhbHVlcyA9IFJlYWN0LnVzZVJlZih1bmRlZmluZWQpO1xuICAgIGNvbnN0IFtmb3JtU3RhdGUsIHVwZGF0ZUZvcm1TdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgICAgIGlzRGlydHk6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxuICAgICAgICBpc0xvYWRpbmc6IGlzRnVuY3Rpb24ocHJvcHMuZGVmYXVsdFZhbHVlcyksXG4gICAgICAgIGlzU3VibWl0dGVkOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIHN1Ym1pdENvdW50OiAwLFxuICAgICAgICBkaXJ0eUZpZWxkczoge30sXG4gICAgICAgIHRvdWNoZWRGaWVsZHM6IHt9LFxuICAgICAgICB2YWxpZGF0aW5nRmllbGRzOiB7fSxcbiAgICAgICAgZXJyb3JzOiBwcm9wcy5lcnJvcnMgfHwge30sXG4gICAgICAgIGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCB8fCBmYWxzZSxcbiAgICAgICAgaXNSZWFkeTogZmFsc2UsXG4gICAgICAgIGRlZmF1bHRWYWx1ZXM6IGlzRnVuY3Rpb24ocHJvcHMuZGVmYXVsdFZhbHVlcylcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHByb3BzLmRlZmF1bHRWYWx1ZXMsXG4gICAgfSk7XG4gICAgaWYgKCFfZm9ybUNvbnRyb2wuY3VycmVudCkge1xuICAgICAgICBpZiAocHJvcHMuZm9ybUNvbnRyb2wpIHtcbiAgICAgICAgICAgIF9mb3JtQ29udHJvbC5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIC4uLnByb3BzLmZvcm1Db250cm9sLFxuICAgICAgICAgICAgICAgIGZvcm1TdGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlcyAmJiAhaXNGdW5jdGlvbihwcm9wcy5kZWZhdWx0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHByb3BzLmZvcm1Db250cm9sLnJlc2V0KHByb3BzLmRlZmF1bHRWYWx1ZXMsIHByb3BzLnJlc2V0T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGZvcm1Db250cm9sLCAuLi5yZXN0IH0gPSBjcmVhdGVGb3JtQ29udHJvbChwcm9wcyk7XG4gICAgICAgICAgICBfZm9ybUNvbnRyb2wuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgICAgIGZvcm1TdGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29udHJvbCA9IF9mb3JtQ29udHJvbC5jdXJyZW50LmNvbnRyb2w7XG4gICAgY29udHJvbC5fb3B0aW9ucyA9IHByb3BzO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBzdWIgPSBjb250cm9sLl9zdWJzY3JpYmUoe1xuICAgICAgICAgICAgZm9ybVN0YXRlOiBjb250cm9sLl9wcm94eUZvcm1TdGF0ZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB1cGRhdGVGb3JtU3RhdGUoeyAuLi5jb250cm9sLl9mb3JtU3RhdGUgfSksXG4gICAgICAgICAgICByZVJlbmRlclJvb3Q6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB1cGRhdGVGb3JtU3RhdGUoKGRhdGEpID0+ICh7XG4gICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgaXNSZWFkeTogdHJ1ZSxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb250cm9sLl9mb3JtU3RhdGUuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgfSwgW2NvbnRyb2xdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gY29udHJvbC5fZGlzYWJsZUZvcm0ocHJvcHMuZGlzYWJsZWQpLCBbY29udHJvbCwgcHJvcHMuZGlzYWJsZWRdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHJvcHMubW9kZSkge1xuICAgICAgICAgICAgY29udHJvbC5fb3B0aW9ucy5tb2RlID0gcHJvcHMubW9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMucmVWYWxpZGF0ZU1vZGUpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX29wdGlvbnMucmVWYWxpZGF0ZU1vZGUgPSBwcm9wcy5yZVZhbGlkYXRlTW9kZTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sLCBwcm9wcy5tb2RlLCBwcm9wcy5yZVZhbGlkYXRlTW9kZV0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9wcy5lcnJvcnMpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX3NldEVycm9ycyhwcm9wcy5lcnJvcnMpO1xuICAgICAgICAgICAgY29udHJvbC5fZm9jdXNFcnJvcigpO1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2wsIHByb3BzLmVycm9yc10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHByb3BzLnNob3VsZFVucmVnaXN0ZXIgJiZcbiAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogY29udHJvbC5fZ2V0V2F0Y2goKSxcbiAgICAgICAgICAgIH0pO1xuICAgIH0sIFtjb250cm9sLCBwcm9wcy5zaG91bGRVbnJlZ2lzdGVyXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlLmlzRGlydHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzRGlydHkgPSBjb250cm9sLl9nZXREaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKGlzRGlydHkgIT09IGZvcm1TdGF0ZS5pc0RpcnR5KSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgIGlzRGlydHksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbCwgZm9ybVN0YXRlLmlzRGlydHldKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHJvcHMudmFsdWVzICYmICFkZWVwRXF1YWwocHJvcHMudmFsdWVzLCBfdmFsdWVzLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBjb250cm9sLl9yZXNldChwcm9wcy52YWx1ZXMsIHtcbiAgICAgICAgICAgICAgICBrZWVwRmllbGRzUmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgIC4uLmNvbnRyb2wuX29wdGlvbnMucmVzZXRPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdmFsdWVzLmN1cnJlbnQgPSBwcm9wcy52YWx1ZXM7XG4gICAgICAgICAgICB1cGRhdGVGb3JtU3RhdGUoKHN0YXRlKSA9PiAoeyAuLi5zdGF0ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sLl9yZXNldERlZmF1bHRWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sLCBwcm9wcy52YWx1ZXNdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNvbnRyb2wuX3N0YXRlLm1vdW50KSB7XG4gICAgICAgICAgICBjb250cm9sLl9zZXRWYWxpZCgpO1xuICAgICAgICAgICAgY29udHJvbC5fc3RhdGUubW91bnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sLl9zdGF0ZS53YXRjaCkge1xuICAgICAgICAgICAgY29udHJvbC5fc3RhdGUud2F0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5jb250cm9sLl9mb3JtU3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbC5fcmVtb3ZlVW5tb3VudGVkKCk7XG4gICAgfSk7XG4gICAgX2Zvcm1Db250cm9sLmN1cnJlbnQuZm9ybVN0YXRlID0gZ2V0UHJveHlGb3JtU3RhdGUoZm9ybVN0YXRlLCBjb250cm9sKTtcbiAgICByZXR1cm4gX2Zvcm1Db250cm9sLmN1cnJlbnQ7XG59XG5cbi8qKlxuICogV2F0Y2ggY29tcG9uZW50IHRoYXQgc3Vic2NyaWJlcyB0byBmb3JtIGZpZWxkIGNoYW5nZXMgYW5kIHJlLXJlbmRlcnMgd2hlbiB3YXRjaGVkIGZpZWxkcyB1cGRhdGUuXG4gKlxuICogQHBhcmFtIGNvbnRyb2wgLSBUaGUgZm9ybSBjb250cm9sIG9iamVjdCBmcm9tIHVzZUZvcm1cbiAqIEBwYXJhbSBuYW1lcyAtIEFycmF5IG9mIGZpZWxkIG5hbWVzIHRvIHdhdGNoIGZvciBjaGFuZ2VzXG4gKiBAcGFyYW0gcmVuZGVyIC0gVGhlIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgd2F0Y2hlZCB2YWx1ZXMgYW5kIHJldHVybnMgUmVhY3ROb2RlXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIGNhbGxpbmcgcmVuZGVyIGZ1bmN0aW9uIHdpdGggd2F0Y2hlZCB2YWx1ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGBXYXRjaGAgY29tcG9uZW50IG9ubHkgcmUtcmVuZGVyIHdoZW4gdGhlIHZhbHVlcyBvZiBgZm9vYCwgYGJhcmAsIGFuZCBgYmF6LnF1eGAgY2hhbmdlLlxuICogVGhlIHR5cGVzIG9mIGBmb29gLCBgYmFyYCwgYW5kIGBiYXoucXV4YCBhcmUgcHJlY2lzZWx5IGluZmVycmVkLlxuICpcbiAqIGBgYHRzeFxuICogY29uc3QgeyBjb250cm9sIH0gPSB1c2VGb3JtKCk7XG4gKlxuICogPFdhdGNoXG4gKiAgIGNvbnRyb2w9e2NvbnRyb2x9XG4gKiAgIG5hbWVzPXtbJ2ZvbycsICdiYXInLCAnYmF6LnF1eCddfVxuICogICByZW5kZXI9eyhbZm9vLCBiYXIsIGJhel9xdXhdKSA9PiA8ZGl2Pntmb299e2Jhcn17YmF6X3F1eH08L2Rpdj59XG4gKiAvPlxuICogYGBgXG4gKi9cbmNvbnN0IFdhdGNoID0gKHsgY29udHJvbCwgbmFtZXMsIHJlbmRlciwgfSkgPT4gcmVuZGVyKHVzZVdhdGNoKHsgY29udHJvbCwgbmFtZTogbmFtZXMgfSkpO1xuXG5leHBvcnQgeyBDb250cm9sbGVyLCBGb3JtLCBGb3JtUHJvdmlkZXIsIFdhdGNoLCBhcHBlbmRFcnJvcnMsIGNyZWF0ZUZvcm1Db250cm9sLCBnZXQsIHNldCwgdXNlQ29udHJvbGxlciwgdXNlRmllbGRBcnJheSwgdXNlRm9ybSwgdXNlRm9ybUNvbnRleHQsIHVzZUZvcm1TdGF0ZSwgdXNlV2F0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5tanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJpc0NoZWNrQm94SW5wdXQiLCJlbGVtZW50IiwidHlwZSIsImlzRGF0ZU9iamVjdCIsInZhbHVlIiwiRGF0ZSIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNPYmplY3RUeXBlIiwiaXNPYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJnZXRFdmVudFZhbHVlIiwiZXZlbnQiLCJ0YXJnZXQiLCJjaGVja2VkIiwiZ2V0Tm9kZVBhcmVudE5hbWUiLCJuYW1lIiwic3Vic3RyaW5nIiwic2VhcmNoIiwiaXNOYW1lSW5GaWVsZEFycmF5IiwibmFtZXMiLCJoYXMiLCJpc1BsYWluT2JqZWN0IiwidGVtcE9iamVjdCIsInByb3RvdHlwZUNvcHkiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiaXNXZWIiLCJ3aW5kb3ciLCJIVE1MRWxlbWVudCIsImRvY3VtZW50IiwiY2xvbmVPYmplY3QiLCJkYXRhIiwiY29weSIsImlzRmlsZUxpc3RJbnN0YW5jZSIsIkZpbGVMaXN0IiwiQmxvYiIsIk9iamVjdCIsImNyZWF0ZSIsImdldFByb3RvdHlwZU9mIiwia2V5IiwiaXNLZXkiLCJ0ZXN0IiwiaXNVbmRlZmluZWQiLCJ2YWwiLCJ1bmRlZmluZWQiLCJjb21wYWN0IiwiZmlsdGVyIiwiQm9vbGVhbiIsInN0cmluZ1RvUGF0aCIsImlucHV0IiwicmVwbGFjZSIsInNwbGl0IiwiZ2V0Iiwib2JqZWN0IiwicGF0aCIsImRlZmF1bHRWYWx1ZSIsInJlc3VsdCIsInJlZHVjZSIsImlzQm9vbGVhbiIsInNldCIsImluZGV4IiwidGVtcFBhdGgiLCJsZW5ndGgiLCJsYXN0SW5kZXgiLCJuZXdWYWx1ZSIsIm9ialZhbHVlIiwiaXNOYU4iLCJFVkVOVFMiLCJCTFVSIiwiRk9DVVNfT1VUIiwiQ0hBTkdFIiwiVkFMSURBVElPTl9NT0RFIiwib25CbHVyIiwib25DaGFuZ2UiLCJvblN1Ym1pdCIsIm9uVG91Y2hlZCIsImFsbCIsIklOUFVUX1ZBTElEQVRJT05fUlVMRVMiLCJtYXgiLCJtaW4iLCJtYXhMZW5ndGgiLCJtaW5MZW5ndGgiLCJwYXR0ZXJuIiwicmVxdWlyZWQiLCJ2YWxpZGF0ZSIsIkhvb2tGb3JtQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsInVzZUZvcm1Db250ZXh0IiwidXNlQ29udGV4dCIsIkZvcm1Qcm92aWRlciIsInByb3BzIiwiY2hpbGRyZW4iLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJnZXRQcm94eUZvcm1TdGF0ZSIsImZvcm1TdGF0ZSIsImNvbnRyb2wiLCJsb2NhbFByb3h5Rm9ybVN0YXRlIiwiaXNSb290IiwiZGVmYXVsdFZhbHVlcyIsIl9kZWZhdWx0VmFsdWVzIiwiZGVmaW5lUHJvcGVydHkiLCJfa2V5IiwiX3Byb3h5Rm9ybVN0YXRlIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZUZvcm1TdGF0ZSIsIm1ldGhvZHMiLCJkaXNhYmxlZCIsImV4YWN0IiwidXBkYXRlRm9ybVN0YXRlIiwidXNlU3RhdGUiLCJfZm9ybVN0YXRlIiwiX2xvY2FsUHJveHlGb3JtU3RhdGUiLCJ1c2VSZWYiLCJpc0RpcnR5IiwiaXNMb2FkaW5nIiwiZGlydHlGaWVsZHMiLCJ0b3VjaGVkRmllbGRzIiwidmFsaWRhdGluZ0ZpZWxkcyIsImlzVmFsaWRhdGluZyIsImlzVmFsaWQiLCJlcnJvcnMiLCJfc3Vic2NyaWJlIiwiY3VycmVudCIsImNhbGxiYWNrIiwiX3NldFZhbGlkIiwidXNlTWVtbyIsImlzU3RyaW5nIiwiZ2VuZXJhdGVXYXRjaE91dHB1dCIsIl9uYW1lcyIsImZvcm1WYWx1ZXMiLCJpc0dsb2JhbCIsIndhdGNoIiwiYWRkIiwibWFwIiwiZmllbGROYW1lIiwid2F0Y2hBbGwiLCJpc1ByaW1pdGl2ZSIsImRlZXBFcXVhbCIsIm9iamVjdDEiLCJvYmplY3QyIiwiX2ludGVybmFsX3Zpc2l0ZWQiLCJXZWFrU2V0IiwiZ2V0VGltZSIsImtleXMxIiwia2V5cyIsImtleXMyIiwidmFsMSIsImluY2x1ZGVzIiwidmFsMiIsInVzZVdhdGNoIiwiY29tcHV0ZSIsIl9kZWZhdWx0VmFsdWUiLCJfY29tcHV0ZSIsIl9jb21wdXRlRm9ybVZhbHVlcyIsIl9wcmV2Q29udHJvbCIsIl9wcmV2TmFtZSIsInVwZGF0ZVZhbHVlIiwiX2dldFdhdGNoIiwiZ2V0Q3VycmVudE91dHB1dCIsInVzZUNhbGxiYWNrIiwidmFsdWVzIiwiX2Zvcm1WYWx1ZXMiLCJyZWZyZXNoVmFsdWUiLCJjb21wdXRlZEZvcm1WYWx1ZXMiLCJfcmVtb3ZlVW5tb3VudGVkIiwiY29udHJvbENoYW5nZWQiLCJwcmV2TmFtZSIsImNvbXB1dGVkT3V0cHV0IiwibmFtZUNoYW5nZWQiLCJzaG91bGRSZXR1cm5JbW1lZGlhdGUiLCJ1c2VDb250cm9sbGVyIiwic2hvdWxkVW5yZWdpc3RlciIsImlzQXJyYXlGaWVsZCIsImFycmF5IiwiZGVmYXVsdFZhbHVlTWVtbyIsIl9wcm9wcyIsIl9wcmV2aW91c05hbWVSZWYiLCJfcmVnaXN0ZXJQcm9wcyIsInJlZ2lzdGVyIiwicnVsZXMiLCJmaWVsZFN0YXRlIiwiZGVmaW5lUHJvcGVydGllcyIsImludmFsaWQiLCJlbnVtZXJhYmxlIiwiaXNUb3VjaGVkIiwiZXJyb3IiLCJyZWYiLCJlbG0iLCJmaWVsZCIsIl9maWVsZHMiLCJfZiIsImZvY3VzIiwic2VsZWN0Iiwic2V0Q3VzdG9tVmFsaWRpdHkiLCJtZXNzYWdlIiwicmVwb3J0VmFsaWRpdHkiLCJfc2hvdWxkVW5yZWdpc3RlckZpZWxkIiwiX29wdGlvbnMiLCJwcmV2aW91c05hbWUiLCJ1bnJlZ2lzdGVyIiwidXBkYXRlTW91bnRlZCIsIm1vdW50IiwiX3N0YXRlIiwiYWN0aW9uIiwiX3NldERpc2FibGVkRmllbGQiLCJDb250cm9sbGVyIiwicmVuZGVyIiwiZmxhdHRlbiIsIm9iaiIsIm91dHB1dCIsIm5lc3RlZCIsIm5lc3RlZEtleSIsIlBPU1RfUkVRVUVTVCIsIkZvcm0iLCJtb3VudGVkIiwic2V0TW91bnRlZCIsIm1ldGhvZCIsImhlYWRlcnMiLCJlbmNUeXBlIiwib25FcnJvciIsIm9uU3VjY2VzcyIsInZhbGlkYXRlU3RhdHVzIiwicmVzdCIsInN1Ym1pdCIsImhhc0Vycm9yIiwiaGFuZGxlU3VibWl0IiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImZvcm1EYXRhSnNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJfYSIsImZsYXR0ZW5Gb3JtVmFsdWVzIiwiYXBwZW5kIiwic2hvdWxkU3RyaW5naWZ5U3VibWlzc2lvbkRhdGEiLCJzb21lIiwicmVzcG9uc2UiLCJmZXRjaCIsIlN0cmluZyIsImJvZHkiLCJzdGF0dXMiLCJfc3ViamVjdHMiLCJzdGF0ZSIsIm5leHQiLCJpc1N1Ym1pdFN1Y2Nlc3NmdWwiLCJzZXRFcnJvciIsIkZyYWdtZW50Iiwibm9WYWxpZGF0ZSIsImFwcGVuZEVycm9ycyIsInZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSIsInR5cGVzIiwiY29udmVydFRvQXJyYXlQYXlsb2FkIiwiY3JlYXRlU3ViamVjdCIsIl9vYnNlcnZlcnMiLCJvYnNlcnZlciIsInN1YnNjcmliZSIsInB1c2giLCJ1bnN1YnNjcmliZSIsIm8iLCJvYnNlcnZlcnMiLCJleHRyYWN0Rm9ybVZhbHVlcyIsImZpZWxkc1N0YXRlIiwiZmllbGRWYWx1ZSIsIm5lc3RlZEZpZWxkc1N0YXRlIiwiaXNFbXB0eU9iamVjdCIsImlzRmlsZUlucHV0IiwiaXNGdW5jdGlvbiIsImlzSFRNTEVsZW1lbnQiLCJvd25lciIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImlzTXVsdGlwbGVTZWxlY3QiLCJpc1JhZGlvSW5wdXQiLCJpc1JhZGlvT3JDaGVja2JveCIsImxpdmUiLCJpc0Nvbm5lY3RlZCIsImJhc2VHZXQiLCJ1cGRhdGVQYXRoIiwic2xpY2UiLCJpc0VtcHR5QXJyYXkiLCJ1bnNldCIsInBhdGhzIiwiY2hpbGRPYmplY3QiLCJvYmplY3RIYXNGdW5jdGlvbiIsImlzVHJhdmVyc2FibGUiLCJtYXJrRmllbGRzRGlydHkiLCJmaWVsZHMiLCJnZXREaXJ0eUZpZWxkcyIsImRpcnR5RmllbGRzRnJvbVZhbHVlcyIsImRlZmF1bHRSZXN1bHQiLCJ2YWxpZFJlc3VsdCIsImdldENoZWNrYm94VmFsdWUiLCJvcHRpb25zIiwib3B0aW9uIiwiYXR0cmlidXRlcyIsImdldEZpZWxkVmFsdWVBcyIsInZhbHVlQXNOdW1iZXIiLCJ2YWx1ZUFzRGF0ZSIsInNldFZhbHVlQXMiLCJOYU4iLCJkZWZhdWx0UmV0dXJuIiwiZ2V0UmFkaW9WYWx1ZSIsInByZXZpb3VzIiwiZ2V0RmllbGRWYWx1ZSIsImZpbGVzIiwicmVmcyIsInNlbGVjdGVkT3B0aW9ucyIsImdldFJlc29sdmVyT3B0aW9ucyIsImZpZWxkc05hbWVzIiwiY3JpdGVyaWFNb2RlIiwic2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiIsImlzUmVnZXgiLCJSZWdFeHAiLCJnZXRSdWxlVmFsdWUiLCJydWxlIiwic291cmNlIiwiZ2V0VmFsaWRhdGlvbk1vZGVzIiwibW9kZSIsImlzT25TdWJtaXQiLCJpc09uQmx1ciIsImlzT25DaGFuZ2UiLCJpc09uQWxsIiwiaXNPblRvdWNoIiwiQVNZTkNfRlVOQ1RJT04iLCJoYXNQcm9taXNlVmFsaWRhdGlvbiIsImZpZWxkUmVmZXJlbmNlIiwiZmluZCIsInZhbGlkYXRlRnVuY3Rpb24iLCJoYXNWYWxpZGF0aW9uIiwiaXNXYXRjaGVkIiwiaXNCbHVyRXZlbnQiLCJ3YXRjaE5hbWUiLCJzdGFydHNXaXRoIiwiaXRlcmF0ZUZpZWxkc0J5QWN0aW9uIiwiYWJvcnRFYXJseSIsImN1cnJlbnRGaWVsZCIsInNjaGVtYUVycm9yTG9va3VwIiwiam9pbiIsImZvdW5kRXJyb3IiLCJyb290IiwicG9wIiwic2hvdWxkUmVuZGVyRm9ybVN0YXRlIiwiZm9ybVN0YXRlRGF0YSIsInNob3VsZFN1YnNjcmliZUJ5TmFtZSIsInNpZ25hbE5hbWUiLCJjdXJyZW50TmFtZSIsInNraXBWYWxpZGF0aW9uIiwiaXNTdWJtaXR0ZWQiLCJyZVZhbGlkYXRlTW9kZSIsInVuc2V0RW1wdHlBcnJheSIsInVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IiLCJmaWVsZEFycmF5RXJyb3JzIiwiZ2V0VmFsaWRhdGVFcnJvciIsImV2ZXJ5IiwiZ2V0VmFsdWVBbmRNZXNzYWdlIiwidmFsaWRhdGlvbkRhdGEiLCJ2YWxpZGF0ZUZpZWxkIiwiZGlzYWJsZWRGaWVsZE5hbWVzIiwiaXNGaWVsZEFycmF5IiwiaW5wdXRWYWx1ZSIsImlucHV0UmVmIiwiaXNSYWRpbyIsImlzQ2hlY2tCb3giLCJpc0VtcHR5IiwiYXBwZW5kRXJyb3JzQ3VycnkiLCJiaW5kIiwiZ2V0TWluTWF4TWVzc2FnZSIsImV4Y2VlZE1heCIsIm1heExlbmd0aE1lc3NhZ2UiLCJtaW5MZW5ndGhNZXNzYWdlIiwibWF4VHlwZSIsIm1pblR5cGUiLCJleGNlZWRNaW4iLCJtYXhPdXRwdXQiLCJtaW5PdXRwdXQiLCJ2YWx1ZU51bWJlciIsInZhbHVlRGF0ZSIsImNvbnZlcnRUaW1lVG9EYXRlIiwidGltZSIsInRvRGF0ZVN0cmluZyIsImlzVGltZSIsImlzV2VlayIsIm1heExlbmd0aE91dHB1dCIsIm1pbkxlbmd0aE91dHB1dCIsInBhdHRlcm5WYWx1ZSIsIm1hdGNoIiwidmFsaWRhdGVFcnJvciIsInZhbGlkYXRpb25SZXN1bHQiLCJkZWZhdWx0T3B0aW9ucyIsInNob3VsZEZvY3VzRXJyb3IiLCJjcmVhdGVGb3JtQ29udHJvbCIsInN1Ym1pdENvdW50IiwiaXNSZWFkeSIsImlzU3VibWl0dGluZyIsIlNldCIsInVuTW91bnQiLCJkZWxheUVycm9yQ2FsbGJhY2siLCJ0aW1lciIsIl9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZSIsInNob3VsZERpc3BsYXlBbGxBc3NvY2lhdGVkRXJyb3JzIiwiZGVib3VuY2UiLCJ3YWl0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInNob3VsZFVwZGF0ZVZhbGlkIiwicmVzb2x2ZXIiLCJfcnVuU2NoZW1hIiwiZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uIiwiX3VwZGF0ZUlzVmFsaWRhdGluZyIsImZyb20iLCJmb3JFYWNoIiwiX3NldEZpZWxkQXJyYXkiLCJhcmdzIiwic2hvdWxkU2V0VmFsdWVzIiwic2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUiLCJmaWVsZFZhbHVlcyIsImFyZ0EiLCJhcmdCIiwiX2dldERpcnR5IiwidXBkYXRlRXJyb3JzIiwiX3NldEVycm9ycyIsInVwZGF0ZVZhbGlkQW5kVmFsdWUiLCJzaG91bGRTa2lwU2V0VmFsdWVBcyIsImRlZmF1bHRDaGVja2VkIiwic2V0RmllbGRWYWx1ZSIsInVwZGF0ZVRvdWNoQW5kRGlydHkiLCJzaG91bGREaXJ0eSIsInNob3VsZFJlbmRlciIsInNob3VsZFVwZGF0ZUZpZWxkIiwiaXNQcmV2aW91c0RpcnR5IiwiaXNDdXJyZW50RmllbGRQcmlzdGluZSIsImlzUHJldmlvdXNGaWVsZFRvdWNoZWQiLCJzaG91bGRSZW5kZXJCeUVycm9yIiwicHJldmlvdXNGaWVsZEVycm9yIiwiZGVsYXlFcnJvciIsInVwZGF0ZWRGb3JtU3RhdGUiLCJjb250ZXh0IiwiZXhlY3V0ZVNjaGVtYUFuZFVwZGF0ZVN0YXRlIiwic2hvdWxkT25seUNoZWNrVmFsaWQiLCJ2YWxpZCIsImlzRmllbGRBcnJheVJvb3QiLCJpc1Byb21pc2VGdW5jdGlvbiIsImZpZWxkRXJyb3IiLCJnZXRWYWx1ZXMiLCJfZ2V0RmllbGRBcnJheSIsIm9wdGlvblJlZiIsInNlbGVjdGVkIiwiY2hlY2tib3hSZWYiLCJyYWRpb1JlZiIsInNob3VsZFRvdWNoIiwic2hvdWxkVmFsaWRhdGUiLCJ0cmlnZ2VyIiwic2V0VmFsdWVzIiwiZmllbGRLZXkiLCJzZXRWYWx1ZSIsImNsb25lVmFsdWUiLCJpc0ZpZWxkVmFsdWVVcGRhdGVkIiwiX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQiLCJOdW1iZXIiLCJ2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCIsInZhbGlkYXRpb25Nb2RlQWZ0ZXJTdWJtaXQiLCJzaG91bGRTa2lwVmFsaWRhdGlvbiIsImRlcHMiLCJ3YXRjaGVkIiwicmVhZE9ubHkiLCJwcmV2aW91c0Vycm9yTG9va3VwUmVzdWx0IiwiZXJyb3JMb29rdXBSZXN1bHQiLCJfZm9jdXNJbnB1dCIsImZpZWxkTmFtZXMiLCJQcm9taXNlIiwic2hvdWxkRm9jdXMiLCJjb25maWciLCJnZXRGaWVsZFN0YXRlIiwiY2xlYXJFcnJvcnMiLCJpbnB1dE5hbWUiLCJjdXJyZW50RXJyb3IiLCJjdXJyZW50UmVmIiwicmVzdE9mRXJyb3JUcmVlIiwicGF5bG9hZCIsIl9zZXRGb3JtU3RhdGUiLCJyZVJlbmRlclJvb3QiLCJkZWxldGUiLCJrZWVwVmFsdWUiLCJrZWVwRXJyb3IiLCJrZWVwRGlydHkiLCJrZWVwVG91Y2hlZCIsImtlZXBJc1ZhbGlkYXRpbmciLCJrZWVwRGVmYXVsdFZhbHVlIiwia2VlcElzVmFsaWQiLCJkaXNhYmxlZElzRGVmaW5lZCIsInByb2dyZXNzaXZlIiwiZmllbGRSZWYiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmFkaW9PckNoZWNrYm94IiwiX2ZvY3VzRXJyb3IiLCJfZGlzYWJsZUZvcm0iLCJvblZhbGlkIiwib25JbnZhbGlkIiwiZSIsIm9uVmFsaWRFcnJvciIsInByZXZlbnREZWZhdWx0IiwicGVyc2lzdCIsInNpemUiLCJyZXNldEZpZWxkIiwiX3Jlc2V0Iiwia2VlcFN0YXRlT3B0aW9ucyIsInVwZGF0ZWRWYWx1ZXMiLCJjbG9uZVVwZGF0ZWRWYWx1ZXMiLCJpc0VtcHR5UmVzZXRWYWx1ZXMiLCJrZWVwRGVmYXVsdFZhbHVlcyIsImtlZXBWYWx1ZXMiLCJrZWVwRGlydHlWYWx1ZXMiLCJmaWVsZHNUb0NoZWNrIiwiZm9ybSIsImNsb3Nlc3QiLCJyZXNldCIsImtlZXBGaWVsZHNSZWYiLCJrZWVwU3VibWl0Q291bnQiLCJrZWVwSXNTdWJtaXR0ZWQiLCJrZWVwRXJyb3JzIiwia2VlcElzU3VibWl0U3VjY2Vzc2Z1bCIsInNldEZvY3VzIiwic2hvdWxkU2VsZWN0IiwiX3Jlc2V0RGVmYXVsdFZhbHVlcyIsInRoZW4iLCJyZXNldE9wdGlvbnMiLCJmb3JtQ29udHJvbCIsImdlbmVyYXRlSWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwiZCIsInBlcmZvcm1hbmNlIiwibm93IiwiYyIsInIiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJnZXRGb2N1c0ZpZWxkTmFtZSIsImZvY3VzTmFtZSIsImZvY3VzSW5kZXgiLCJhcHBlbmRBdCIsImZpbGxFbXB0eUFycmF5IiwiaW5zZXJ0IiwibW92ZUFycmF5QXQiLCJ0byIsInNwbGljZSIsInByZXBlbmRBdCIsInJlbW92ZUF0SW5kZXhlcyIsImluZGV4ZXMiLCJpIiwidGVtcCIsInJlbW92ZUFycmF5QXQiLCJzb3J0IiwiYSIsImIiLCJzd2FwQXJyYXlBdCIsImluZGV4QSIsImluZGV4QiIsInVwZGF0ZUF0IiwidXNlRmllbGRBcnJheSIsImtleU5hbWUiLCJzZXRGaWVsZHMiLCJpZHMiLCJfYWN0aW9uZWQiLCJmaWVsZEFycmF5TmFtZSIsInVwZGF0ZVZhbHVlcyIsInVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzIiwiYXBwZW5kVmFsdWUiLCJwcmVwZW5kIiwicHJlcGVuZFZhbHVlIiwicmVtb3ZlIiwiaW5zZXJ0JDEiLCJpbnNlcnRWYWx1ZSIsInN3YXAiLCJtb3ZlIiwidXBkYXRlIiwiaXRlbSIsImV4aXN0aW5nRXJyb3IiLCJ1c2VGb3JtIiwiX2Zvcm1Db250cm9sIiwiX3ZhbHVlcyIsInN1YiIsIldhdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-hook-form/dist/index.esm.mjs\n");

/***/ })

};
;